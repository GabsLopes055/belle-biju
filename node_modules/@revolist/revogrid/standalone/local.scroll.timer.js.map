{"file":"local.scroll.timer.js","mappings":"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","names":[],"sources":["src/services/local.scroll.service.ts","src/services/local.scroll.timer.ts"],"sourcesContent":["import type { DimensionType, ViewPortScrollEvent } from '@type';\nimport { scaleValue } from '../utils';\n\ninterface Config {\n  skipAnimationFrame?: boolean;\n  // scroll event inited and direction cached\n  // scrollingService.proxyScroll get tiggered\n  // setScroll event called from scrollingService\n  runScroll(e: ViewPortScrollEvent): void;\n  // all operation finished, apply scroll values\n  applyScroll(e: ViewPortScrollEvent): void;\n}\n\ntype Params = {\n  contentSize: number;\n  virtualContentSize?: number;\n  clientSize: number;\n  virtualSize: number;\n  maxSize?: number;\n};\n\nconst initialParams: Params = {\n  contentSize: 0,\n  clientSize: 0,\n  virtualSize: 0,\n  maxSize: 0,\n};\nconst NO_COORDINATE = -1;\n\n/**\n * Based on content size, client size and virtual size\n * return full size\n */\nexport function getContentSize(\n  contentSize: number,\n  clientSize: number,\n  virtualSize = 0,\n): number {\n  return contentSize + (virtualSize ? clientSize - virtualSize : 0);\n}\n\nexport default class LocalScrollService {\n  private preventArtificialScroll: Record<DimensionType, (() => void) | null> = {\n    rgRow: null,\n    rgCol: null,\n  };\n  // to check if scroll changed\n  private previousScroll: Record<DimensionType, number> = {\n    rgRow: NO_COORDINATE,\n    rgCol: NO_COORDINATE,\n  };\n  private params: Record<DimensionType, Params> = {\n    rgRow: { ...initialParams },\n    rgCol: { ...initialParams },\n  };\n\n  constructor(private cfg: Config) {}\n\n  setParams(params: Params, dimension: DimensionType) {\n    const virtualContentSize = getContentSize(\n      params.contentSize,\n      params.clientSize,\n      params.virtualSize,\n    );\n    this.params[dimension] = {\n      ...params,\n      maxSize: virtualContentSize - params.clientSize,\n      virtualContentSize,\n    };\n  }\n\n  // apply scroll values after scroll done\n  async setScroll(e: ViewPortScrollEvent) {\n    this.cancelScroll(e.dimension);\n\n    // start frame animation\n    const frameAnimation = new Promise<void>((resolve, reject) => {\n      // for example safari desktop has issues with animation frame\n      if (this.cfg.skipAnimationFrame) {\n        return resolve();\n      }\n      const animationId = window.requestAnimationFrame(() => {\n        resolve();\n      });\n      this.preventArtificialScroll[e.dimension] = reject.bind(\n        null,\n        animationId,\n      );\n    });\n\n    try {\n      await frameAnimation;\n      const params = this.getParams(e.dimension);\n      e.coordinate = Math.ceil(e.coordinate);\n      this.previousScroll[e.dimension] = this.wrapCoordinate(\n        e.coordinate,\n        params,\n      );\n      this.preventArtificialScroll[e.dimension] = null;\n      this.cfg.applyScroll({\n        ...e,\n        coordinate: params.virtualSize\n          ? this.convert(e.coordinate, params, false)\n          : e.coordinate,\n      });\n    } catch (id) {\n      window.cancelAnimationFrame(id);\n    }\n  }\n\n  /**\n   * On scroll event started\n   */\n  scroll(\n    coordinate: number,\n    dimension: DimensionType,\n    force = false,\n    delta?: number,\n    outside = false,\n  ) {\n    // cancel all previous scrolls for same dimension\n    this.cancelScroll(dimension);\n\n    // drop if no change\n    if (!force && this.previousScroll[dimension] === coordinate) {\n      this.previousScroll[dimension] = NO_COORDINATE;\n      return;\n    }\n\n    const param = this.getParams(dimension);\n    // let component know about scroll event started\n    this.cfg.runScroll({\n      dimension: dimension,\n      coordinate: param.virtualSize\n        ? this.convert(coordinate, param)\n        : coordinate,\n      delta,\n      outside,\n    });\n  }\n\n  private getParams(dimension: DimensionType): Params {\n    return this.params[dimension];\n  }\n\n  // check if scroll outside of region to avoid looping\n  private wrapCoordinate(c: number, param: Params): number {\n    if (c < 0) {\n      return NO_COORDINATE;\n    }\n\n    if (typeof param.maxSize === 'number' && c > param.maxSize) {\n      return param.maxSize;\n    }\n    return c;\n  }\n\n  // prevent already started scroll, performance optimization\n  private cancelScroll(dimension: DimensionType) {\n    this.preventArtificialScroll[dimension]?.();\n    this.preventArtificialScroll[dimension] = null;\n  }\n\n  /* convert virtual to real and back, scale range */\n  private convert(pos: number, param: Params, toReal = true): number {\n    const minRange = param.clientSize;\n    const from: [number, number] = [0, (param.virtualContentSize ?? minRange) - minRange];\n    const to: [number, number] = [0, param.contentSize - param.virtualSize];\n    if (toReal) {\n      return scaleValue(pos, from, to);\n    }\n    return scaleValue(pos, to, from);\n  }\n}\n","import type { DimensionType } from '@type';\n/**\n * Apply changes only if mousewheel event happened some time ago (scrollThrottling)\n */\nexport class LocalScrollTimer {\n  /**\n   * Last mw event time for trigger scroll function below\n   * If mousewheel function was ignored we still need to trigger render\n   */\n  private mouseWheelScrollTimestamp: Record<DimensionType, number> = {\n    rgCol: 0,\n    rgRow: 0,\n  };\n  private lastKnownScrollCoordinate: Record<DimensionType, number> = {\n    rgCol: 0,\n    rgRow: 0,\n  };\n\n  constructor(private scrollThrottling = 10) {}\n\n  setCoordinate(e: { dimension: DimensionType; coordinate: number }) {\n    this.lastKnownScrollCoordinate[e.dimension] = e.coordinate;\n  }\n\n  /**\n   * Remember last mw event time\n   */\n  latestScrollUpdate(dimension: DimensionType) {\n    this.mouseWheelScrollTimestamp[dimension] = new Date().getTime();\n  }\n\n  /**\n   * Check if scroll is ready to accept new value\n   */\n  isReady(type: DimensionType, coordinate: number) {\n    const change = new Date().getTime() - this.mouseWheelScrollTimestamp[type];\n    // apply after throttling\n    return (\n      change > this.scrollThrottling &&\n      coordinate !== this.lastKnownScrollCoordinate[type]\n    );\n  }\n}\n"],"version":3}