{"file":"revogr-temp-range2.js","mappings":";;;;;;;;AAAA,MAAM,uBAAuB,GAAG,41MAA41M,CAAC;AAC73M,8BAAe,uBAAuB;;MCazB,WAAW;;;;QAoBL,aAAQ,GAAG,QAAQ,CAAC,CAAC,CAAc,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;;;;;IAExE,QAAQ,CAAC,CAAc;QAC7B,CAAC,aAAD,CAAC,uBAAD,CAAC,CAAE,cAAc,CAAC;YAChB,KAAK,EAAE,SAAS;YAChB,MAAM,EAAE,SAAS;SAClB,CAAC,CAAC;KACJ;IAED,kBAAkB;QAChB,IAAI,IAAI,CAAC,EAAE,EAAE;YACX,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SACxB;KACF;IAED,MAAM;QACJ,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAClD,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QACtD,IAAI,CAAC,IAAI,EAAE;YACT,OAAO;SACR;QACD,IAAI,UAAU,GAAG,QAAQ,CAAC;QAC1B,IAAI,UAAU,GAAG,OAAO,CAAC;QACzB,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC9B,IAAI,CAAC,KAAK,EAAE;YACV,OAAO;SACR;QACD,IAAI,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;YACpB,UAAU,GAAG,KAAK,CAAC;SACpB;QACD,IAAI,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE;YACpB,UAAU,GAAG,MAAM,CAAC;SACrB;QACD,MAAM,cAAc,GAAG,GAAG,UAAU,IAAI,UAAU,EAAE,CAAC;QACrD,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,EACvB,IAAI,CAAC,YAAY,CAAC,KAAK,EACvB,IAAI,CAAC,YAAY,CAAC,KAAK,CACxB,CAAC;QACF,MAAM,MAAM,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACtC,MAAM,KAAK,GAAG;YACZ,KAAK,EAAE;gBACL,CAAC,sBAAsB,GAAG,IAAI;gBAC9B,CAAC,IAAI,IAAI,EAAE,GAAG,IAAI;aACnB;YACD,KAAK,EAAE,MAAM;YACb,MAAM,EAAE,KAAK;SACd,CAAC;QACF,QACE,EAAC,IAAI,oBAAK,KAAK,GACb,WAAK,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAI,CACpD,EACP;KACH;IAEO,QAAQ;QACd,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,KAAK,EAAE;YACT,OAAO,KAAK,CAAC;SACd;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC/C,IAAI,CAAC,KAAK,EAAE;YACV,OAAO,IAAI,CAAC;SACb;QACD,uCACK,KAAK,KACR,EAAE,EAAE,KAAK,CAAC,CAAC,EACX,EAAE,EAAE,KAAK,CAAC,CAAC,IACX;KACH;;;;;;;;;;;;;;;;;;;;;;;","names":[],"sources":["src/components/selectionTempRange/revogr-temp-range-style.scss?tag=revogr-temp-range","src/components/selectionTempRange/revogr-temp-range.tsx"],"sourcesContent":[".temp-bg-range {\n  display: block !important;\n  position: absolute;\n  pointer-events: none;\n  z-index: 9;\n  border: 1px solid rgb(255, 94, 0);\n  box-sizing: border-box;\n\n  &.Selection {\n    border: 1px dashed gray;\n  }\n\n  > div {\n    width: 1px;\n    height: 1px;\n    position: absolute;\n\n    &.top {\n      top: -1px;\n    }\n\n    &.bottom {\n      bottom: -1px;\n    }\n\n    &.left {\n      left: -1px;\n    }\n\n    &.right {\n      right: -1px;\n    }\n  }\n}\n","import { Component, Prop, h, Host } from '@stencil/core';\nimport throttle from 'lodash/throttle';\nimport { TMP_SELECTION_BG_CLASS } from '../../utils/consts';\nimport { getCell, styleByCellProps } from '../overlay/selection.utils';\nimport { DimensionSettingsState, SelectionStoreState, RangeArea } from '@type';\nimport type { Observable } from '../../utils';\n\n/**\n * Temporary range selection component. Shows temporary range selection.\n */\n@Component({\n  tag: 'revogr-temp-range',\n  styleUrl: 'revogr-temp-range-style.scss',\n})\nexport class RevogrFocus {\n  /**\n   * Dynamic stores\n   */\n\n  /**\n   * Selection store, shows current selection and focus\n   */\n  @Prop() selectionStore: Observable<SelectionStoreState>;\n\n  /**\n   * Dimension row store\n   */\n  @Prop() dimensionRow: Observable<DimensionSettingsState>;\n  /**\n   * Dimension column store\n   */\n  @Prop() dimensionCol: Observable<DimensionSettingsState>;\n\n  el?: HTMLElement;\n  private readonly onChange = throttle((e: HTMLElement) => this.doChange(e), 300);\n\n  private doChange(e: HTMLElement) {\n    e?.scrollIntoView({\n      block: 'nearest',\n      inline: 'nearest',\n    });\n  }\n\n  componentDidRender() {\n    if (this.el) {\n      this.onChange(this.el);\n    }\n  }\n\n  render() {\n    const data = this.selectionStore.get('tempRange');\n    const type = this.selectionStore.get('tempRangeType');\n    if (!data) {\n      return;\n    }\n    let directionY = 'bottom';\n    let derectionX = 'right';\n    const range = this.getRange();\n    if (!range) {\n      return;\n    }\n    if (data.y < range.y) {\n      directionY = 'top';\n    }\n    if (data.x < range.x) {\n      derectionX = 'left';\n    }\n    const directionClass = `${derectionX} ${directionY}`;\n    const cell = getCell(data,\n      this.dimensionRow.state,\n      this.dimensionCol.state\n    );\n    const styles = styleByCellProps(cell);\n    const props = {\n      class: {\n        [TMP_SELECTION_BG_CLASS]: true,\n        [type || '']: true,\n      },\n      style: styles,\n      hidden: false\n    };\n    return (\n      <Host {...props}>\n        <div class={directionClass} ref={(e) => (this.el = e)} />\n      </Host>\n    );\n  }\n\n  private getRange(): RangeArea | null {\n    const range = this.selectionStore.get('range');\n    if (range) {\n      return range;\n    }\n    const focus = this.selectionStore.get('focus');\n    if (!focus) {\n      return null;\n    }\n    return {\n      ...focus,\n      x1: focus.x,\n      y1: focus.y,\n    };\n  }\n}\n"],"version":3}