{"file":"dimension.helpers.js","mappings":";;;;;;AAEA;AACA,IAAIA,kBAAgB,GAAG,UAAU;AACjC,IAAI,eAAe,GAAGA,kBAAgB,GAAG,CAAC,CAAC;AAC3C;AACA;AACA,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK;AAC5B,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE;AAC/D,EAAE,IAAI,GAAG,GAAG,CAAC;AACb,MAAM,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;AAC9C,EAAE,IAAI,IAAI,KAAK,CAAC,EAAE;AAClB,IAAI,OAAO,CAAC,CAAC;AACb,GAAG;AACH;AACA,EAAE,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;AAC1B,EAAE,IAAI,QAAQ,GAAG,KAAK,KAAK,KAAK;AAChC,MAAM,SAAS,GAAG,KAAK,KAAK,IAAI;AAChC,MAAM,WAAW,GAAG,QAAQ,CAAC,KAAK,CAAC;AACnC,MAAM,cAAc,GAAG,KAAK,KAAK,SAAS,CAAC;AAC3C;AACA,EAAE,OAAO,GAAG,GAAG,IAAI,EAAE;AACrB,IAAI,IAAI,GAAG,GAAG,WAAW,CAAC,CAAC,GAAG,GAAG,IAAI,IAAI,CAAC,CAAC;AAC3C,QAAQ,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACvC,QAAQ,YAAY,GAAG,QAAQ,KAAK,SAAS;AAC7C,QAAQ,SAAS,GAAG,QAAQ,KAAK,IAAI;AACrC,QAAQ,cAAc,GAAG,QAAQ,KAAK,QAAQ;AAC9C,QAAQ,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACzC;AACA,IAAI,IAAI,QAAQ,EAAE;AAClB,MAAM,IAAI,MAAM,GAAG,UAAU,IAAI,cAAc,CAAC;AAChD,KAAK,MAAM,IAAI,cAAc,EAAE;AAC/B,MAAM,MAAM,GAAG,cAAc,KAAK,UAAU,IAAI,YAAY,CAAC,CAAC;AAC9D,KAAK,MAAM,IAAI,SAAS,EAAE;AAC1B,MAAM,MAAM,GAAG,cAAc,IAAI,YAAY,KAAK,UAAU,IAAI,CAAC,SAAS,CAAC,CAAC;AAC5E,KAAK,MAAM,IAAI,WAAW,EAAE;AAC5B,MAAM,MAAM,GAAG,cAAc,IAAI,YAAY,IAAI,CAAC,SAAS,KAAK,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC;AAC5F,KAAK,MAAM,IAAI,SAAS,IAAI,WAAW,EAAE;AACzC,MAAM,MAAM,GAAG,KAAK,CAAC;AACrB,KAAK,MAAM;AACX,MAAM,MAAM,GAAG,UAAU,IAAI,QAAQ,IAAI,KAAK,KAAK,QAAQ,GAAG,KAAK,CAAC,CAAC;AACrE,KAAK;AACL,IAAI,IAAI,MAAM,EAAE;AAChB,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AACpB,KAAK,MAAM;AACX,MAAM,IAAI,GAAG,GAAG,CAAC;AACjB,KAAK;AACL,GAAG;AACH,EAAE,OAAO,SAAS,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;AAC1C;;AC5DA;AACA,IAAI,gBAAgB,GAAG,UAAU;AACjC,IAAI,qBAAqB,GAAG,gBAAgB,KAAK,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,eAAe,CAAC,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE;AACnD,EAAE,IAAI,GAAG,GAAG,CAAC;AACb,MAAM,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;AAChD;AACA,EAAE,IAAI,OAAO,KAAK,IAAI,QAAQ,IAAI,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,qBAAqB,EAAE;AACpF,IAAI,OAAO,GAAG,GAAG,IAAI,EAAE;AACvB,MAAM,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,IAAI,MAAM,CAAC;AAClC,UAAU,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;AAChC;AACA,MAAM,IAAI,QAAQ,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC;AAClD,WAAW,UAAU,IAAI,QAAQ,IAAI,KAAK,KAAK,QAAQ,GAAG,KAAK,CAAC,CAAC,EAAE;AACnE,QAAQ,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AACtB,OAAO,MAAM;AACb,QAAQ,IAAI,GAAG,GAAG,CAAC;AACnB,OAAO;AACP,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,GAAG;AACH,EAAE,OAAO,iBAAiB,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;AAC/D;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE;AACnC,EAAE,OAAO,eAAe,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACvC;;ACIA;;;;;SAKgB,sBAAsB,CACpC,cAAsB,EACtB,WAAgC,EAAE;IAElC,MAAM,eAAe,GAAa,EAAE,CAAC;IACrC,MAAM,mBAAmB,GAAyC,EAAE,CAAC;IACrE,MAAM,WAAW,GAAsC,EAAE,CAAC;;IAG1D,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IAC3E,IAAI,QAAkC,CAAC;IACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC1C,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,OAAO,GAAiB;YAC5B,SAAS;YACT,KAAK,EAAE,CAAC;YACR,GAAG,EAAE,CAAC;SACP,CAAC;;QAEF,IAAI,QAAQ,EAAE;YACZ,MAAM,YAAY,GAChB,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,GAAG,CAAC,IAAI,cAAc,CAAC;YACxD,OAAO,CAAC,KAAK,GAAG,YAAY,GAAG,QAAQ,CAAC,GAAG,CAAC;SAC7C;aAAM;YACL,OAAO,CAAC,KAAK,GAAG,SAAS,GAAG,cAAc,CAAC;SAC5C;QACD,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;QAClD,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACpC,WAAW,CAAC,SAAS,CAAC,GAAG,mBAAmB,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;QAC1D,QAAQ,GAAG,OAAO,CAAC;KACpB;IACD,OAAO;QACL,OAAO,EAAE,UAAU;QACnB,eAAe,EAAE,CAAC,GAAG,eAAe,CAAC;QACrC,mBAAmB,oBAAO,mBAAmB,CAAE;QAC/C,WAAW;KACZ,CAAC;AACJ,CAAC;AAED;;;MAGa,iBAAiB,GAAG,CAC/B,EACE,OAAO,EACP,eAAe,EACf,cAAc,EACd,mBAAmB,GAC+E,EACpG,GAAW;IAEX,MAAM,IAAI,GAAiB;QACzB,SAAS,EAAE,CAAC;QACZ,KAAK,EAAE,CAAC;QACR,GAAG,EAAE,CAAC;KACP,CAAC;IACF,MAAM,YAAY,GAAG,OAAO,CAAC,MAAM,GAAG,WAAW,CAAC,eAAe,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;IAE5E,IAAI,CAAC,YAAY,EAAE;QACjB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,cAAc,CAAC,CAAC;QAClD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,GAAG,cAAc,CAAC;QAC7C,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC;QACvC,OAAO,IAAI,CAAC;KACb;IACD,MAAM,YAAY,GAAG,mBAAmB,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;;IAE3D,IAAI,YAAY,CAAC,GAAG,GAAG,GAAG,EAAE;QAC1B,OAAO,YAAY,CAAC;KACrB;;IAED,MAAM,WAAW,GAAG,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC;IAC3C,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,cAAc,CAAC,CAAC;IAC/D,IAAI,CAAC,SAAS,GAAG,YAAY,CAAC,SAAS,GAAG,CAAC,GAAG,aAAa,CAAC;IAC5D,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC,GAAG,GAAG,aAAa,GAAG,cAAc,CAAC;IAC/D,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC;IACvC,OAAO,IAAI,CAAC;AACd,EAAE;SAEc,cAAc,CAC5B,SAGC,EACD,KAAa;IAEb,IAAI,IAAI,GAAiB;QACvB,SAAS,EAAE,KAAK;QAChB,KAAK,EAAE,CAAC;QACR,GAAG,EAAE,CAAC;KACP,CAAC;;IAEF,IAAI,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;QAChC,OAAO,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;KACrC;IAED,MAAM,YAAY,GAAG,SAAS,CAAC,OAAO,CAAC,MAAM;UACzC,WAAW,CAAC,SAAS,CAAC,OAAO,EAAE,KAAK,CAAC;UACrC,CAAC,CAAC;;IAEN,IAAI,CAAC,YAAY,EAAE;QACjB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,cAAc,CAAC;QACvD,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,cAAc,CAAC;QACjD,OAAO,IAAI,CAAC;KACb;;IAED,MAAM,YAAY,GAChB,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7D,IAAI,CAAC,KAAK;QACR,YAAY,CAAC,GAAG;YAChB,CAAC,KAAK,GAAG,YAAY,CAAC,SAAS,GAAG,CAAC,IAAI,SAAS,CAAC,cAAc,CAAC;IAClE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,cAAc,CAAC;IACjD,OAAO,IAAI,CAAC;AACd;;;;","names":["MAX_ARRAY_LENGTH"],"sources":["node_modules/lodash/_baseSortedIndexBy.js","node_modules/lodash/_baseSortedIndex.js","node_modules/lodash/sortedIndex.js","src/store/dimension/dimension.helpers.ts"],"sourcesContent":["import isSymbol from './isSymbol.js';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeMin = Math.min;\n\n/**\n * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n * which invokes `iteratee` for `value` and each element of `array` to compute\n * their sort ranking. The iteratee is invoked with one argument; (value).\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {Function} iteratee The iteratee invoked per element.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndexBy(array, value, iteratee, retHighest) {\n  var low = 0,\n      high = array == null ? 0 : array.length;\n  if (high === 0) {\n    return 0;\n  }\n\n  value = iteratee(value);\n  var valIsNaN = value !== value,\n      valIsNull = value === null,\n      valIsSymbol = isSymbol(value),\n      valIsUndefined = value === undefined;\n\n  while (low < high) {\n    var mid = nativeFloor((low + high) / 2),\n        computed = iteratee(array[mid]),\n        othIsDefined = computed !== undefined,\n        othIsNull = computed === null,\n        othIsReflexive = computed === computed,\n        othIsSymbol = isSymbol(computed);\n\n    if (valIsNaN) {\n      var setLow = retHighest || othIsReflexive;\n    } else if (valIsUndefined) {\n      setLow = othIsReflexive && (retHighest || othIsDefined);\n    } else if (valIsNull) {\n      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n    } else if (valIsSymbol) {\n      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n    } else if (othIsNull || othIsSymbol) {\n      setLow = false;\n    } else {\n      setLow = retHighest ? (computed <= value) : (computed < value);\n    }\n    if (setLow) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return nativeMin(high, MAX_ARRAY_INDEX);\n}\n\nexport default baseSortedIndexBy;\n","import baseSortedIndexBy from './_baseSortedIndexBy.js';\nimport identity from './identity.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295,\n    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n/**\n * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n * performs a binary search of `array` to determine the index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @private\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @param {boolean} [retHighest] Specify returning the highest qualified index.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n */\nfunction baseSortedIndex(array, value, retHighest) {\n  var low = 0,\n      high = array == null ? low : array.length;\n\n  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n    while (low < high) {\n      var mid = (low + high) >>> 1,\n          computed = array[mid];\n\n      if (computed !== null && !isSymbol(computed) &&\n          (retHighest ? (computed <= value) : (computed < value))) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return high;\n  }\n  return baseSortedIndexBy(array, value, identity, retHighest);\n}\n\nexport default baseSortedIndex;\n","import baseSortedIndex from './_baseSortedIndex.js';\n\n/**\n * Uses a binary search to determine the lowest index at which `value`\n * should be inserted into `array` in order to maintain its sort order.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The sorted array to inspect.\n * @param {*} value The value to evaluate.\n * @returns {number} Returns the index at which `value` should be inserted\n *  into `array`.\n * @example\n *\n * _.sortedIndex([30, 50], 40);\n * // => 1\n */\nfunction sortedIndex(array, value) {\n  return baseSortedIndex(array, value);\n}\n\nexport default sortedIndex;\n","import sortedIndex from 'lodash/sortedIndex';\n\nimport type {\n  DimensionSettingsState,\n  PositionItem,\n  ViewSettingSizeProp,\n} from '@type';\n\nexport type DimensionPosition = Pick<\n  DimensionSettingsState,\n  'indexes' | 'positionIndexes' | 'originItemSize' | 'positionIndexToItem'\n>;\nexport type DimensionIndexInput = Pick<\n  DimensionSettingsState,\n  'indexes' | 'originItemSize' | 'indexToItem'\n>;\nexport type DimensionSize = Pick<\n  DimensionSettingsState,\n  | 'indexes'\n  | 'positionIndexes'\n  | 'positionIndexToItem'\n  | 'indexToItem'\n  | 'realSize'\n  | 'sizes'\n>;\n/**\n * Pre-calculation\n * Dimension custom sizes for each cell\n * Keeps only changed sizes, skips origin size\n */\nexport function calculateDimensionData(\n  originItemSize: number,\n  newSizes: ViewSettingSizeProp = {},\n) {\n  const positionIndexes: number[] = [];\n  const positionIndexToItem: { [position: number]: PositionItem } = {};\n  const indexToItem: { [index: number]: PositionItem } = {};\n\n  // prepare order sorted new sizes and calculate changed real size\n  const newIndexes = Object.keys(newSizes).map(Number).sort((a, b) => a - b);\n  let previous: PositionItem | undefined;\n  for (let i = 0; i < newIndexes.length; i++) {\n    const itemIndex = newIndexes[i];\n    const newItem: PositionItem = {\n      itemIndex,\n      start: 0,\n      end: 0,\n    };\n    // if previous item was changed too\n    if (previous) {\n      const itemsBetween =\n        (itemIndex - previous.itemIndex - 1) * originItemSize;\n      newItem.start = itemsBetween + previous.end;\n    } else {\n      newItem.start = itemIndex * originItemSize;\n    }\n    newItem.end = newItem.start + newSizes[itemIndex];\n    positionIndexes.push(newItem.start);\n    indexToItem[itemIndex] = positionIndexToItem[i] = newItem;\n    previous = newItem;\n  }\n  return {\n    indexes: newIndexes,\n    positionIndexes: [...positionIndexes],\n    positionIndexToItem: { ...positionIndexToItem },\n    indexToItem,\n  };\n}\n\n/**\n * Calculate item by position\n */\nexport const getItemByPosition = (\n  {\n    indexes,\n    positionIndexes,\n    originItemSize,\n    positionIndexToItem,\n  }: Pick<DimensionPosition, 'indexes' | 'positionIndexes' | 'originItemSize' | 'positionIndexToItem'>,\n  pos: number,\n) => {\n  const item: PositionItem = {\n    itemIndex: 0,\n    start: 0,\n    end: 0,\n  };\n  const currentPlace = indexes.length ? sortedIndex(positionIndexes, pos) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.itemIndex = Math.floor(pos / originItemSize);\n    item.start = item.itemIndex * originItemSize;\n    item.end = item.start + originItemSize;\n    return item;\n  }\n  const positionItem = positionIndexToItem[currentPlace - 1];\n  // if item has specified size\n  if (positionItem.end > pos) {\n    return positionItem;\n  }\n  // special size item was present before\n  const relativePos = pos - positionItem.end;\n  const relativeIndex = Math.floor(relativePos / originItemSize);\n  item.itemIndex = positionItem.itemIndex + 1 + relativeIndex;\n  item.start = positionItem.end + relativeIndex * originItemSize;\n  item.end = item.start + originItemSize;\n  return item;\n};\n\nexport function getItemByIndex(\n  dimension: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n  index: number,\n) {\n  let item: PositionItem = {\n    itemIndex: index,\n    start: 0,\n    end: 0,\n  };\n  // if item has specified size\n  if (dimension.indexToItem[index]) {\n    return dimension.indexToItem[index];\n  }\n\n  const currentPlace = dimension.indexes.length\n    ? sortedIndex(dimension.indexes, index)\n    : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.start = item.itemIndex * dimension.originItemSize;\n    item.end = item.start + dimension.originItemSize;\n    return item;\n  }\n  // special size item was present before\n  const positionItem =\n    dimension.indexToItem[dimension.indexes[currentPlace - 1]];\n  item.start =\n    positionItem.end +\n    (index - positionItem.itemIndex - 1) * dimension.originItemSize;\n  item.end = item.start + dimension.originItemSize;\n  return item;\n}\n"],"version":3}