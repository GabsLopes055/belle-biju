/*!
 * Built by Revolist OU ❤️
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-10d10c55.js');
const dimension_helpers = require('./dimension.helpers-1927ad24.js');
const events = require('./events-af8f6914.js');
const column_service = require('./column.service-831e1c92.js');
const edit_utils = require('./edit.utils-e51411f6.js');
const key_utils = require('./key.utils-96d0bc42.js');
const debounce = require('./debounce-ec7a04b4.js');
const viewport_store = require('./viewport.store-69b45f22.js');
const viewport_helpers = require('./viewport.helpers-e59a544e.js');
const throttle = require('./throttle-bb713c73.js');

const Attribution = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
    }
    render() {
        return (index.h(index.Host, { key: '3d66475a019010c24b6c610ccc047e01c35178f9' }, index.h("a", { key: '45b2270dcfe2e0eeaddf8445e773b15349a6b3df', href: "https://rv-grid.com/guide/attribution", title: "Made with \u2764\uFE0F by Revolist OU Team", class: "value" }, "RevoGrid")));
    }
};

const RevoGridExtra = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.nodes = [];
        this.update = 1;
    }
    /**
     * Refreshes the extra component. Useful if you want to manually
     * force the component to re-render.
     */
    async refresh() {
        this.update *= -1;
    }
    render() {
        var _a;
        return (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.map(node => {
            // Check if node is a function or a stencil component
            // If function wrap it in a stencil component with the refresh function
            if (typeof node === 'function') {
                const config = {};
                const getNodes = () => [node({ refresh: () => { var _a; return (_a = config.refresh) === null || _a === void 0 ? void 0 : _a.call(config); } })];
                return (index.h("revogr-extra", { nodes: getNodes(), ref: (el) => {
                        if (el) {
                            // Update exclusively for current node
                            config.refresh = () => {
                                el.nodes = getNodes();
                            };
                        }
                    } }));
            }
            return node;
        });
    }
};

function collectModelsOfRange(data, store) {
    const models = {};
    for (let i in data) {
        const rowIndex = parseInt(i, 10);
        models[rowIndex] = dimension_helpers.getSourceItem(store, rowIndex);
    }
    return models;
}
function getFocusCellBasedOnEvent(e, data) {
    // If event default is prevented, return
    if (e.defaultPrevented) {
        return null;
    }
    // Get coordinates from event object
    const x = events.getPropertyFromEvent(e, 'clientX');
    const y = events.getPropertyFromEvent(e, 'clientY');
    // If coordinates are not available, return
    if (x === null || y === null) {
        return null;
    }
    // Get current cell based on coordinates and data
    const focusCell = getCurrentCell({ x, y }, data);
    // If current cell is not available, return
    if (isAfterLast(focusCell, data.lastCell)) {
        return null;
    }
    return focusCell;
}
/**
 * Calculate cell based on x, y position
 */
function getCurrentCell({ x, y }, { el, rows, cols }) {
    // Get the bounding rectangle of the element
    const { top, left, height, width } = el.getBoundingClientRect();
    // Calculate the cell position relative to the element
    let cellY = y - top;
    let cellX = x - left;
    // Limit the cell position to the element height
    if (cellY >= height) {
        cellY = height - 1;
    }
    // Limit the cell position to the element width
    if (cellX >= width) {
        cellX = width - 1;
    }
    // Get the row and column items based on the cell position
    const rgRow = dimension_helpers.getItemByPosition(rows, cellY);
    const rgCol = dimension_helpers.getItemByPosition(cols, cellX);
    // Set the row and column index to 0 if they are before the first item
    if (rgCol.itemIndex < 0) {
        rgCol.itemIndex = 0;
    }
    if (rgRow.itemIndex < 0) {
        rgRow.itemIndex = 0;
    }
    return { x: rgCol.itemIndex, y: rgRow.itemIndex };
}
function getCoordinate(range, focus, changes, isMulti = false) {
    const updateCoordinate = (c, pos = 0) => {
        const start = { x: range.x, y: range.y };
        const end = isMulti ? { x: range.x1, y: range.y1 } : start;
        const point = end[c] > focus[c] ? end : start;
        point[c] += pos;
        return { start, end };
    };
    if (changes.x) {
        return updateCoordinate('x', changes['x']);
    }
    if (changes.y) {
        return updateCoordinate('y', changes['y']);
    }
    return null;
}
/**
 * Check if the x coordinate of the cell position is after or equal to the x coordinate of the last cell position
 * or if the y coordinate of the cell position is after or equal to the y coordinate of the last cell position
 */
function isAfterLast({ x, y }, lastCell) {
    return x >= lastCell.x || y >= lastCell.y;
}
/** check if out of range */
function isBeforeFirst({ x, y }) {
    return x < 0 || y < 0;
}
/** Compare cells, only 1 coordinate difference is possible */
// export function getDirectionCoordinate(initial: Cell, last: Cell): Partial<Cell> | null {
//   const c: (keyof Cell)[] = ['x', 'y'];
//   for (let k of c) {
//     if (initial[k] !== last[k]) {
//       return { [k]: 1 };
//     }
//   }
//   return null;
// }
// export function getLargestAxis(initial: Cell, last: Cell): Partial<Cell> | null {
//   const cell: Partial<Cell> = {};
//   const c: (keyof Cell)[] = ['x', 'y'];
//   for (let k of c) {
//     cell[k] = Math.abs(initial[k] - last[k]);
//   }
//   if (cell.x > cell.y) {
//     return { x: 1 };
//   }
//   if (cell.y > cell.x) {
//     return { y: 1 };
//   }
//   return null;
// }
function styleByCellProps(styles) {
    return {
        left: `${styles.left}px`,
        top: `${styles.top}px`,
        width: `${styles.width}px`,
        height: `${styles.height}px`,
    };
}
function getCell({ x, y, x1, y1 }, dimensionRow, dimensionCol) {
    const top = dimension_helpers.getItemByIndex(dimensionRow, y).start;
    const left = dimension_helpers.getItemByIndex(dimensionCol, x).start;
    const bottom = dimension_helpers.getItemByIndex(dimensionRow, y1).end;
    const right = dimension_helpers.getItemByIndex(dimensionCol, x1).end;
    return {
        left,
        right,
        top,
        bottom,
        width: right - left,
        height: bottom - top,
    };
}

const revogrFocusStyleCss = ".revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:\"::\"}.revo-alt-icon{-webkit-mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#4545ff;height:32px;line-height:32px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#009037}.revo-button.red{background-color:#E0662E}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.outline{border:1px solid #dbdbdb;line-height:30px;background:none;color:#000;box-shadow:none}revo-grid[theme^=dark] .revo-button.outline{border:1px solid #404040;color:#d8d8d8}revogr-focus.focused-cell{box-shadow:-1px 0 0 #0d63e8 inset, 1px 0 0 #0d63e8 inset, 0 -1px 0 #0d63e8 inset, 0 1px 0 #0d63e8 inset;position:absolute;pointer-events:none;z-index:9;display:block !important}";
const RevogrFocusStyle0 = revogrFocusStyleCss;

const RevogrFocus$1 = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.beforeFocusRender = index.createEvent(this, "beforefocusrender", 7);
        this.beforeScrollIntoView = index.createEvent(this, "beforescrollintoview", 7);
        this.afterFocus = index.createEvent(this, "afterfocus", 7);
        this.activeFocus = null;
        this.colType = undefined;
        this.rowType = undefined;
        this.selectionStore = undefined;
        this.dimensionRow = undefined;
        this.dimensionCol = undefined;
        this.dataStore = undefined;
        this.colData = undefined;
        this.focusTemplate = null;
    }
    componentDidRender() {
        var _a, _b;
        const currentFocus = this.selectionStore.get('focus');
        if (((_a = this.activeFocus) === null || _a === void 0 ? void 0 : _a.x) === (currentFocus === null || currentFocus === void 0 ? void 0 : currentFocus.x) &&
            ((_b = this.activeFocus) === null || _b === void 0 ? void 0 : _b.y) === (currentFocus === null || currentFocus === void 0 ? void 0 : currentFocus.y)) {
            return;
        }
        this.activeFocus = currentFocus;
        if (currentFocus && this.el) {
            const beforeScrollIn = this.beforeScrollIntoView.emit({ el: this.el });
            if (!beforeScrollIn.defaultPrevented) {
                this.el.scrollIntoView({
                    block: 'nearest',
                    inline: 'nearest',
                });
            }
            const model = dimension_helpers.getSourceItem(this.dataStore, currentFocus.y);
            const column = dimension_helpers.getSourceItem(this.colData, currentFocus.x);
            this.afterFocus.emit({
                model,
                column,
                rowType: this.rowType,
                colType: this.colType,
                rowIndex: currentFocus.y,
                colIndex: currentFocus.x,
            });
        }
    }
    render() {
        var _a;
        const editCell = this.selectionStore.get('edit');
        if (editCell) {
            return;
        }
        const focusCell = this.selectionStore.get('focus');
        if (!focusCell) {
            return;
        }
        const event = this.beforeFocusRender.emit({
            range: Object.assign(Object.assign({}, focusCell), { x1: focusCell.x, y1: focusCell.y }),
            rowType: this.rowType,
            colType: this.colType,
            rowDimension: Object.assign({}, this.dimensionRow.state),
            colDimension: Object.assign({}, this.dimensionCol.state),
        });
        if (event.defaultPrevented) {
            return index.h("slot", null);
        }
        const { detail } = event;
        const cell = getCell(detail.range, event.detail.rowDimension, event.detail.colDimension);
        const styles = styleByCellProps(cell);
        const extra = (_a = this.focusTemplate) === null || _a === void 0 ? void 0 : _a.call(this, index.h, detail);
        const props = {
            class: { [dimension_helpers.FOCUS_CLASS]: true },
            style: styles,
        };
        return (index.h(index.Host, Object.assign({}, props), index.h("slot", null), extra));
    }
    get el() { return index.getElement(this); }
};
RevogrFocus$1.style = RevogrFocusStyle0;

const DIRECTION_CODES = [
    dimension_helpers.codesLetter.TAB,
    dimension_helpers.codesLetter.ARROW_UP,
    dimension_helpers.codesLetter.ARROW_DOWN,
    dimension_helpers.codesLetter.ARROW_LEFT,
    dimension_helpers.codesLetter.ARROW_RIGHT,
];
class KeyboardService {
    constructor(sv) {
        this.sv = sv;
    }
    async keyDown(e, canRange, isEditMode, { range, focus }) {
        // IF EDIT MODE
        if (isEditMode) {
            switch (e.code) {
                case dimension_helpers.codesLetter.ESCAPE:
                    this.sv.cancel();
                    break;
                case dimension_helpers.codesLetter.TAB:
                    this.keyChangeSelection(e, canRange);
                    break;
            }
            return;
        }
        // IF NOT EDIT MODE
        // pressed clear key
        if (range && key_utils.isClear(e.code)) {
            this.sv.clearCell();
            return;
        }
        // below works with focus only
        if (!focus) {
            return;
        }
        // tab key means same as arrow right
        if (key_utils.isTab(e.code)) {
            this.keyChangeSelection(e, canRange);
            return;
        }
        // pressed enter
        if (key_utils.isEnterKeyValue(e.key)) {
            this.sv.change();
            return;
        }
        // copy operation
        if (key_utils.isCopy(e)) {
            return;
        }
        // cut operation
        if (key_utils.isCut(e)) {
            return;
        }
        // paste operation
        if (key_utils.isPaste(e)) {
            this.sv.internalPaste();
            return;
        }
        // select all
        if (key_utils.isAll(e)) {
            if (canRange) {
                this.selectAll(e);
            }
            return;
        }
        // pressed letter key
        if (e.key.length === 1) {
            this.sv.change(e.key);
            return;
        }
        // pressed arrow, change selection position
        if (await this.keyChangeSelection(e, canRange)) {
            return;
        }
    }
    selectAll(e) {
        const range = this.sv.selectionStore.get('range');
        const focus = this.sv.selectionStore.get('focus');
        // if no range or focus - do nothing
        if (!range || !focus) {
            return;
        }
        e.preventDefault();
        this.sv.selectAll();
    }
    async keyChangeSelection(e, canRange) {
        const data = this.changeDirectionKey(e, canRange);
        if (!data) {
            return false;
        }
        // this interval needed for several cases
        // grid could be resized before next click
        // at this case to avoid screen jump we use this interval
        await dimension_helpers.timeout(dimension_helpers.RESIZE_INTERVAL + 30);
        const range = this.sv.selectionStore.get('range');
        const focus = this.sv.selectionStore.get('focus');
        return this.keyPositionChange(data.changes, range, focus, data.isMulti);
    }
    keyPositionChange(changes, range, focus, isMulti = false) {
        if (!range || !focus) {
            return false;
        }
        const data = getCoordinate(range, focus, changes, isMulti);
        if (!data) {
            return false;
        }
        const eData = this.sv.getData();
        if (isMulti) {
            if (isAfterLast(data.end, eData.lastCell) || isBeforeFirst(data.start)) {
                return false;
            }
            const range = column_service.getRange(data.start, data.end);
            return this.sv.range(range);
        }
        return this.sv.focus(data.start, changes, isAfterLast(data.start, eData.lastCell)
            ? 1
            : isBeforeFirst(data.start)
                ? -1
                : 0);
    }
    /** Monitor key direction changes */
    changeDirectionKey(e, canRange) {
        const isMulti = canRange && e.shiftKey;
        if (DIRECTION_CODES.includes(e.code)) {
            e.preventDefault();
        }
        if (e.shiftKey) {
            switch (e.code) {
                case dimension_helpers.codesLetter.TAB:
                    return { changes: { x: -1 }, isMulti: false };
            }
        }
        switch (e.code) {
            case dimension_helpers.codesLetter.ARROW_UP:
                return { changes: { y: -1 }, isMulti };
            case dimension_helpers.codesLetter.ARROW_DOWN:
                return { changes: { y: 1 }, isMulti };
            case dimension_helpers.codesLetter.ARROW_LEFT:
                return { changes: { x: -1 }, isMulti };
            case dimension_helpers.codesLetter.TAB:
            case dimension_helpers.codesLetter.ARROW_RIGHT:
                return { changes: { x: 1 }, isMulti };
        }
    }
}

class AutoFillService {
    constructor(sv) {
        this.sv = sv;
        this.autoFillType = null;
        this.autoFillInitial = null;
        this.autoFillStart = null;
        this.autoFillLast = null;
    }
    /**
     * Render autofill box
     * @param range
     * @param selectionFocus
     */
    renderAutofill(range, selectionFocus) {
        let handlerStyle;
        if (range) {
            handlerStyle = getCell(range, this.sv.dimensionRow.state, this.sv.dimensionCol.state);
        }
        else {
            handlerStyle = getCell(Object.assign(Object.assign({}, selectionFocus), { x1: selectionFocus.x, y1: selectionFocus.y }), this.sv.dimensionRow.state, this.sv.dimensionCol.state);
        }
        return (index.h("div", { class: {
                [dimension_helpers.CELL_HANDLER_CLASS]: true,
                [dimension_helpers.MOBILE_CLASS]: true,
            }, style: {
                left: `${handlerStyle.right}px`,
                top: `${handlerStyle.bottom}px`,
            }, onMouseDown: (e) => this.autoFillHandler(e), onTouchStart: (e) => this.autoFillHandler(e) }));
    }
    autoFillHandler(e, type = "AutoFill" /* AutoFillType.autoFill */) {
        let target = null;
        if (e.target instanceof Element) {
            target = e.target;
        }
        if (!target) {
            return;
        }
        this.selectionStart(target, this.sv.getData(), type);
        e.preventDefault();
    }
    get isAutoFill() {
        return !!this.autoFillType;
    }
    /**
     * Process mouse move events
     */
    selectionMouseMove(e) {
        // initiate mouse move debounce if not present
        if (!this.onMouseMoveAutofill) {
            this.onMouseMoveAutofill = debounce.debounce((e, data) => this.doAutofillMouseMove(e, data), 5);
        }
        if (this.isAutoFill) {
            this.onMouseMoveAutofill(e, this.sv.getData());
        }
    }
    getFocus(focus, range) {
        // there was an issue that it was taking last cell from range but focus was out
        if (!focus && range) {
            focus = { x: range.x, y: range.y };
        }
        return focus || null;
    }
    /**
     * Autofill logic:
     * on mouse move apply based on previous direction (if present)
     */
    doAutofillMouseMove(event, data) {
        // if no initial - not started
        if (!this.autoFillInitial) {
            return;
        }
        const x = events.getPropertyFromEvent(event, 'clientX', dimension_helpers.MOBILE_CLASS);
        const y = events.getPropertyFromEvent(event, 'clientY', dimension_helpers.MOBILE_CLASS);
        // skip touch
        if (x === null || y === null) {
            return;
        }
        const current = getCurrentCell({ x, y }, data);
        // first time or direction equal to start(same as first time)
        if (!this.autoFillLast) {
            if (!this.autoFillLast) {
                this.autoFillLast = this.autoFillStart;
            }
        }
        // check if not the latest, if latest - do nothing
        if (isAfterLast(current, data.lastCell)) {
            return;
        }
        this.autoFillLast = current;
        const isSame = current.x === this.autoFillInitial.x &&
            current.y === this.autoFillInitial.y;
        // if same as initial - clear
        if (isSame) {
            this.sv.setTempRange(null);
        }
        else {
            const area = column_service.getRange(this.autoFillInitial, this.autoFillLast);
            this.sv.setTempRange({
                area,
                type: this.autoFillType,
            });
        }
    }
    /**
     * Range selection started
     * Mode @param type:
     * Can be triggered from MouseDown selection on element
     * Or can be triggered on corner square drag
     */
    selectionStart(target, data, type = "Selection" /* AutoFillType.selection */) {
        /** Get cell by autofill element */
        const { top, left } = target.getBoundingClientRect();
        this.autoFillInitial = this.getFocus(data.focus, data.range);
        this.autoFillType = type;
        this.autoFillStart = getCurrentCell({ x: left, y: top }, data);
    }
    /**
     * Clear current range selection on mouse up and mouse leave events
     */
    clearAutoFillSelection(focus, oldRange) {
        // If autofill was active, apply autofill values
        if (this.autoFillInitial) {
            // Fetch latest focus
            this.autoFillInitial = this.getFocus(focus, oldRange);
            // Apply range data if autofill mode is active
            if (this.autoFillType === "AutoFill" /* AutoFillType.autoFill */) {
                const range = column_service.getRange(this.autoFillInitial, this.autoFillLast);
                // If range is present, apply data
                if (range) {
                    const { defaultPrevented: stopApply, detail: { range: newRange }, } = this.sv.clearRangeDataApply({
                        range,
                    });
                    // If data apply was not prevented, apply new range
                    if (!stopApply && oldRange) {
                        this.applyRangeWithData(newRange, oldRange);
                    }
                    else {
                        // If data apply was prevented, clear temporary range
                        this.sv.setTempRange(null);
                    }
                }
            }
            else {
                // If not autofill mode, apply range only
                this.applyRangeOnly(this.autoFillInitial, this.autoFillLast);
            }
        }
        // Reset autofill state
        this.resetAutoFillState();
    }
    /**
     * Reset autofill state
     */
    resetAutoFillState() {
        this.autoFillType = null;
        this.autoFillInitial = null;
        this.autoFillLast = null;
        this.autoFillStart = null;
    }
    /**
     * Trigger range apply events and handle responses
     */
    onRangeApply(newData, newRange, oldRange) {
        this.sv.rangeDataApply({
            data: newData,
            models: collectModelsOfRange(newData, this.sv.dataStore),
            type: this.sv.dataStore.get('type'),
            oldRange,
            newRange
        });
        this.sv.setRange(newRange);
    }
    /** Apply range and copy data during range application */
    applyRangeWithData(newRange, rangeToCopy) {
        const rangeData = {
            type: this.sv.dataStore.get('type'),
            colType: this.sv.columnService.type,
            newData: {},
            mapping: {},
            newRange,
            oldRange: rangeToCopy,
        };
        const { mapping, changed } = this.sv.columnService.getRangeData(rangeData, this.sv.columnService.columns);
        rangeData.newData = changed;
        rangeData.mapping = mapping;
        let e = this.sv.selectionChanged(rangeData);
        // if default prevented - clear range
        if (e.defaultPrevented) {
            this.sv.setTempRange(null);
            return;
        }
        e = this.sv.rangeCopy(rangeData);
        if (e.defaultPrevented) {
            this.sv.setRange(newRange);
            return;
        }
        this.onRangeApply(rangeData.newData, newRange, rangeToCopy);
    }
    /**
     * Update range selection only,
     * no data change (mouse selection)
     */
    applyRangeOnly(start, end) {
        // no changes to apply
        if (!start || !end) {
            return;
        }
        const newRange = column_service.getRange(start, end);
        this.sv.setRange(newRange);
    }
}

const revogrOverlayStyleCss = ".revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:\"::\"}.revo-alt-icon{-webkit-mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#4545ff;height:32px;line-height:32px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#009037}.revo-button.red{background-color:#E0662E}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.outline{border:1px solid #dbdbdb;line-height:30px;background:none;color:#000;box-shadow:none}revo-grid[theme^=dark] .revo-button.outline{border:1px solid #404040;color:#d8d8d8}revogr-overlay-selection{display:block;position:relative;width:100%}revogr-overlay-selection .autofill-handle{position:absolute;width:14px;height:14px;margin-left:-13px;margin-top:-13px;z-index:10;cursor:crosshair}revogr-overlay-selection .autofill-handle::before{content:\"\";position:absolute;right:0;bottom:0;width:10px;height:10px;background:#0d63e8;border:1px solid white;box-sizing:border-box}revogr-overlay-selection.mobile .autofill-handle{position:absolute;width:30px;height:30px;margin-left:-29px;margin-top:-29px;z-index:10;cursor:crosshair}revogr-overlay-selection.mobile .autofill-handle::before{content:\"\";position:absolute;right:0;bottom:0;width:12px;height:12px;background:#0d63e8;border:1px solid white;box-sizing:border-box}revogr-overlay-selection .selection-border-range{position:absolute;pointer-events:none;z-index:9;box-shadow:-1px 0 0 #0d63e8 inset, 1px 0 0 #0d63e8 inset, 0 -1px 0 #0d63e8 inset, 0 1px 0 #0d63e8 inset}revogr-overlay-selection .selection-border-range .range-handlers{height:100%;background-color:transparent;width:75%;max-width:50px;min-width:20px;left:50%;transform:translateX(-50%);position:absolute}revogr-overlay-selection .selection-border-range .range-handlers>span{pointer-events:auto;height:20px;width:20px;position:absolute;left:50%;transform:translateX(-50%)}revogr-overlay-selection .selection-border-range .range-handlers>span:before,revogr-overlay-selection .selection-border-range .range-handlers>span:after{position:absolute;border-radius:5px;width:15px;height:5px;left:50%;transform:translateX(-50%);background-color:rgba(0, 0, 0, 0.2)}revogr-overlay-selection .selection-border-range .range-handlers>span:first-child{top:-7px}revogr-overlay-selection .selection-border-range .range-handlers>span:first-child:before{content:\"\";top:0}revogr-overlay-selection .selection-border-range .range-handlers>span:last-child{bottom:-7px}revogr-overlay-selection .selection-border-range .range-handlers>span:last-child:after{content:\"\";bottom:0}revogr-overlay-selection revogr-edit{z-index:10}";
const RevogrOverlaySelectionStyle0 = revogrOverlayStyleCss;

const OverlaySelection = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.beforeCopyRegion = index.createEvent(this, "beforecopyregion", 7);
        this.beforeRegionPaste = index.createEvent(this, "beforepasteregion", 7);
        this.cellEditApply = index.createEvent(this, "celleditapply", 7);
        this.beforeFocusCell = index.createEvent(this, "beforecellfocusinit", 7);
        this.beforeNextViewportFocus = index.createEvent(this, "beforenextvpfocus", 7);
        this.setEdit = index.createEvent(this, "setedit", 7);
        this.beforeApplyRange = index.createEvent(this, "beforeapplyrange", 7);
        this.beforeSetRange = index.createEvent(this, "beforesetrange", 7);
        this.setRange = index.createEvent(this, "setrange", 7);
        this.beforeEditRender = index.createEvent(this, "beforeeditrender", 7);
        this.selectAll = index.createEvent(this, "selectall", 7);
        this.cancelEdit = index.createEvent(this, "canceledit", 7);
        this.setTempRange = index.createEvent(this, "settemprange", 7);
        this.beforeSetTempRange = index.createEvent(this, "beforesettemprange", 7);
        this.applyFocus = index.createEvent(this, "applyfocus", 7);
        this.focusCell = index.createEvent(this, "focuscell", 7);
        this.beforeRangeDataApply = index.createEvent(this, "beforerangedataapply", 7);
        this.selectionChange = index.createEvent(this, "selectionchangeinit", 7);
        this.beforeRangeCopyApply = index.createEvent(this, "beforerangecopyapply", 7);
        this.rangeEditApply = index.createEvent(this, "rangeeditapply", 7);
        this.rangeClipboardCopy = index.createEvent(this, "clipboardrangecopy", 7);
        this.rangeClipboardPaste = index.createEvent(this, "clipboardrangepaste", 7);
        this.beforeKeyDown = index.createEvent(this, "beforekeydown", 7);
        this.beforeKeyUp = index.createEvent(this, "beforekeyup", 7);
        this.beforeCellSave = index.createEvent(this, "beforecellsave", 7);
        this.keyboardService = null;
        this.autoFillService = null;
        this.unsubscribeSelectionStore = [];
        this.readonly = undefined;
        this.range = undefined;
        this.canDrag = undefined;
        this.useClipboard = undefined;
        this.selectionStore = undefined;
        this.dimensionRow = undefined;
        this.dimensionCol = undefined;
        this.dataStore = undefined;
        this.colData = undefined;
        this.lastCell = undefined;
        this.editors = undefined;
        this.applyChangesOnClose = false;
        this.additionalData = undefined;
        this.isMobileDevice = undefined;
    }
    // #endregion
    // #region Listeners
    onMouseMove(e) {
        var _a;
        if (this.selectionStore.get('focus')) {
            (_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.selectionMouseMove(e);
        }
    }
    /**
     * Action finished inside the document.
     * Pointer left document, clear any active operation.
     */
    onMouseUp() {
        var _a;
        // Clear autofill selection
        // when pointer left document,
        // clear any active operation.
        (_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.clearAutoFillSelection(this.selectionStore.get('focus'), this.selectionStore.get('range'));
    }
    /**
     * Row drag started.
     * This event is fired when drag action started on cell.
     */
    onCellDrag(e) {
        var _a;
        // Invoke drag start on order editor.
        (_a = this.orderEditor) === null || _a === void 0 ? void 0 : _a.dragStart(e.detail);
    }
    /**
     * Get keyboard down from element.
     * This event is fired when keyboard key is released.
     */
    onKeyUp(e) {
        // Emit before key up event.
        this.beforeKeyUp.emit(Object.assign({ original: e }, this.getData()));
    }
    /**
     * Get keyboard down from element.
     * This event is fired when keyboard key is pressed.
     */
    onKeyDown(e) {
        var _a;
        // Emit before key down event and check if default prevention is set.
        const proxy = this.beforeKeyDown.emit(Object.assign({ original: e }, this.getData()));
        if (e.defaultPrevented || proxy.defaultPrevented) {
            return;
        }
        // Invoke key down on keyboard service.
        (_a = this.keyboardService) === null || _a === void 0 ? void 0 : _a.keyDown(e, this.range, !!this.selectionStore.get('edit'), {
            focus: this.selectionStore.get('focus'),
            range: this.selectionStore.get('range'),
        });
    }
    // #endregion
    /**
     * Selection & Keyboard
     */
    selectionServiceSet(selectionStore) {
        // clear subscriptions
        this.unsubscribeSelectionStore.forEach(v => v());
        this.unsubscribeSelectionStore.length = 0;
        this.unsubscribeSelectionStore.push(selectionStore.onChange('nextFocus', v => v && this.doFocus(v, v)));
        this.keyboardService = new KeyboardService({
            selectionStore,
            range: r => !!r && this.triggerRangeEvent(r),
            focus: (f, changes, focusNextViewport) => {
                if (focusNextViewport) {
                    this.beforeNextViewportFocus.emit(f);
                    return false;
                }
                else {
                    return this.doFocus(f, f, changes);
                }
            },
            change: val => {
                if (this.readonly) {
                    return;
                }
                this.doEdit(val);
            },
            cancel: async () => {
                var _a;
                await ((_a = this.revogrEdit) === null || _a === void 0 ? void 0 : _a.cancelChanges());
                this.closeEdit();
            },
            clearCell: () => !this.readonly && this.clearCell(),
            internalPaste: () => !this.readonly && this.beforeRegionPaste.emit(),
            getData: () => this.getData(),
            selectAll: () => this.selectAll.emit(),
        });
        this.createAutoFillService();
    }
    /** Autofill */
    createAutoFillService() {
        this.autoFillService = new AutoFillService({
            dimensionRow: this.dimensionRow,
            dimensionCol: this.dimensionCol,
            columnService: this.columnService,
            dataStore: this.dataStore,
            clearRangeDataApply: e => this.beforeRangeDataApply.emit(Object.assign(Object.assign(Object.assign({}, e), this.types), { rowDimension: Object.assign({}, this.dimensionRow.state), colDimension: Object.assign({}, this.dimensionCol.state) })),
            setTempRange: e => {
                const tempRangeEvent = this.beforeSetTempRange.emit(Object.assign(Object.assign({ tempRange: e }, this.getData()), this.types));
                if (tempRangeEvent.defaultPrevented) {
                    return null;
                }
                return this.setTempRange.emit(tempRangeEvent.detail.tempRange);
            },
            selectionChanged: e => this.selectionChange.emit(e),
            rangeCopy: e => this.beforeRangeCopyApply.emit(e),
            rangeDataApply: e => this.rangeEditApply.emit(e),
            setRange: e => !!e && this.triggerRangeEvent(e),
            getData: () => this.getData(),
        });
    }
    /** Columns */
    columnServiceSet() {
        var _a;
        (_a = this.columnService) === null || _a === void 0 ? void 0 : _a.destroy();
        this.columnService = new column_service.ColumnService(this.dataStore, this.colData);
        this.createAutoFillService();
    }
    connectedCallback() {
        this.columnServiceSet();
        this.selectionServiceSet(this.selectionStore);
    }
    disconnectedCallback() {
        var _a;
        // clear subscriptions
        this.unsubscribeSelectionStore.forEach(v => v());
        this.unsubscribeSelectionStore.length = 0;
        (_a = this.columnService) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    async componentWillRender() {
        var _a, _b;
        const editCell = this.selectionStore.get('edit');
        if (!editCell) {
            await ((_b = (_a = this.revogrEdit) === null || _a === void 0 ? void 0 : _a.beforeDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a));
        }
    }
    renderRange(range) {
        const cell = getCell(range, this.dimensionRow.state, this.dimensionCol.state);
        const styles = styleByCellProps(cell);
        return [
            index.h("div", { class: dimension_helpers.SELECTION_BORDER_CLASS, style: styles }, this.isMobileDevice && (index.h("div", { class: "range-handlers" }, index.h("span", { class: dimension_helpers.MOBILE_CLASS }), index.h("span", { class: dimension_helpers.MOBILE_CLASS })))),
        ];
    }
    renderEditor() {
        // Check if edit access
        const editCell = this.selectionStore.get('edit');
        // Readonly or Editor closed
        if (this.readonly || !editCell) {
            return null;
        }
        const enteredOrModelValue = editCell.val ||
            column_service.getCellData(this.columnService.rowDataModel(editCell.y, editCell.x).value);
        const editable = Object.assign(Object.assign({}, editCell), this.columnService.getSaveData(editCell.y, editCell.x, enteredOrModelValue));
        const renderEvent = this.beforeEditRender.emit(Object.assign(Object.assign({ range: Object.assign(Object.assign({}, editCell), { x1: editCell.x, y1: editCell.y }) }, this.types), { rowDimension: Object.assign({}, this.dimensionRow.state), colDimension: Object.assign({}, this.dimensionCol.state) }));
        // Render prevented
        if (renderEvent.defaultPrevented) {
            return null;
        }
        const cell = getCell(renderEvent.detail.range, renderEvent.detail.rowDimension, renderEvent.detail.colDimension);
        const styles = styleByCellProps(cell);
        return (index.h("revogr-edit", { style: styles, ref: el => (this.revogrEdit = el), additionalData: this.additionalData, editCell: editable, saveOnClose: this.applyChangesOnClose, column: this.columnService.rowDataModel(editCell.y, editCell.x), editor: this.columnService.getCellEditor(editCell.y, editCell.x, this.editors), onCloseedit: e => this.closeEdit(e), onCelledit: e => {
                const saveEv = this.beforeCellSave.emit(e.detail);
                if (!saveEv.defaultPrevented) {
                    this.cellEdit(saveEv.detail);
                }
                // if not clear navigate to next cell after edit
                if (!saveEv.detail.preventFocus) {
                    this.focusNext();
                }
            } }));
    }
    render() {
        var _a;
        const nodes = [];
        const editCell = this.renderEditor();
        // Editor
        if (editCell) {
            nodes.push(editCell);
        }
        else {
            const range = this.selectionStore.get('range');
            const focus = this.selectionStore.get('focus');
            // Clipboard
            if ((range || focus) && this.useClipboard) {
                nodes.push(index.h("revogr-clipboard", { readonly: this.readonly, onCopyregion: e => this.onCopy(e.detail), onClearregion: () => !this.readonly && this.clearCell(), ref: e => (this.clipboard = e), onPasteregion: e => this.onPaste(e.detail) }));
            }
            // Range
            if (range) {
                nodes.push(...this.renderRange(range));
            }
            // Autofill
            if (focus && !this.readonly && this.range) {
                nodes.push((_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.renderAutofill(range, focus));
            }
            // Order
            if (this.canDrag) {
                nodes.push(index.h("revogr-order-editor", { ref: e => (this.orderEditor = e), dataStore: this.dataStore, dimensionRow: this.dimensionRow, dimensionCol: this.dimensionCol, parent: this.element, rowType: this.types.rowType, onRowdragstartinit: e => this.rowDragStart(e) }));
            }
        }
        return (index.h(index.Host, { key: '16eb46317cda519daf53f0b347700e8c1cdbd144', class: { mobile: this.isMobileDevice }, onDblClick: (e) => this.onElementDblClick(e), onMouseDown: (e) => this.onElementMouseDown(e), onTouchStart: (e) => this.onElementMouseDown(e, true) }, nodes, index.h("slot", { key: '8e71ab9946f8b8251aaee867c6551e1fada92c6d', name: "data" })));
    }
    /**
     * Executes the focus operation on the specified range of cells.
     */
    doFocus(focus, end, changes) {
        // 1. Trigger beforeFocus event
        const { defaultPrevented } = this.beforeFocusCell.emit(this.columnService.getSaveData(focus.y, focus.x));
        if (defaultPrevented) {
            return false;
        }
        const evData = Object.assign(Object.assign({ range: Object.assign(Object.assign({}, focus), { x1: end.x, y1: end.y }), next: changes }, this.types), { rowDimension: Object.assign({}, this.dimensionRow.state), colDimension: Object.assign({}, this.dimensionCol.state) });
        // 2. Trigger apply focus event
        const applyEvent = this.applyFocus.emit(evData);
        if (applyEvent.defaultPrevented) {
            return false;
        }
        const { range } = applyEvent.detail;
        // 3. Trigger focus event
        return !this.focusCell.emit(Object.assign({ focus: {
                x: range.x,
                y: range.y,
            }, end: {
                x: range.x1,
                y: range.y1,
            } }, applyEvent.detail)).defaultPrevented;
    }
    triggerRangeEvent(range) {
        const type = this.types.rowType;
        // 1. Apply range
        const applyEvent = this.beforeApplyRange.emit(Object.assign(Object.assign({ range: Object.assign({}, range) }, this.types), { rowDimension: Object.assign({}, this.dimensionRow.state), colDimension: Object.assign({}, this.dimensionCol.state) }));
        if (applyEvent.defaultPrevented) {
            return false;
        }
        const data = this.columnService.getRangeTransformedToProps(applyEvent.detail.range, this.dataStore);
        // 2. Before set range
        let e = this.beforeSetRange.emit(data);
        if (e.defaultPrevented) {
            return false;
        }
        // 3. Set range
        e = this.setRange.emit(Object.assign(Object.assign({}, applyEvent.detail.range), { type }));
        if (e.defaultPrevented) {
            return false;
        }
        return !e.defaultPrevented;
    }
    /**
     * Open Editor on DblClick
     */
    onElementDblClick(e) {
        // DblClick prevented outside - Editor will not open
        if (e.defaultPrevented) {
            return;
        }
        // Get data from the component
        const data = this.getData();
        const focusCell = getFocusCellBasedOnEvent(e, data);
        if (!focusCell) {
            return;
        }
        this.doEdit();
    }
    /**
     * Handle mouse down event on Host element
     */
    onElementMouseDown(e, touch = false) {
        var _a;
        // Get the target element from the event object
        const targetElement = e.target;
        // Ignore focus if clicked input
        if (edit_utils.isEditInput(targetElement) || e.defaultPrevented) {
            return;
        }
        // Get data from the component
        const data = this.getData();
        const focusCell = getFocusCellBasedOnEvent(e, data);
        if (!focusCell) {
            return;
        }
        // Set focus on the current cell
        this.focus(focusCell, this.range && e.shiftKey);
        // Initiate autofill selection
        if (this.range) {
            targetElement &&
                ((_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.selectionStart(targetElement, this.getData()));
            // Prevent default behavior for mouse events,
            // but only if target element is not a mobile input
            if (!touch) {
                e.preventDefault();
            }
            else if (events.verifyTouchTarget(e.touches[0], dimension_helpers.MOBILE_CLASS)) {
                // Prevent default behavior for touch events
                // if target element is a mobile input
                e.preventDefault();
            }
        }
    }
    /**
     * Start cell editing
     */
    doEdit(val = '') {
        var _a;
        if (this.canEdit()) {
            const focus = this.selectionStore.get('focus');
            if (!focus) {
                return;
            }
            const data = this.columnService.getSaveData(focus.y, focus.x);
            (_a = this.setEdit) === null || _a === void 0 ? void 0 : _a.emit(Object.assign(Object.assign({}, data), { val }));
        }
    }
    /**
     * Close editor event triggered
     * @param details - if it requires focus next
     */
    async closeEdit(e) {
        this.cancelEdit.emit();
        if (e === null || e === void 0 ? void 0 : e.detail) {
            await this.focusNext();
        }
    }
    /**
     * Edit finished.
     * Close Editor and save.
     */
    cellEdit(e) {
        const dataToSave = this.columnService.getSaveData(e.rgRow, e.rgCol, e.val);
        this.cellEditApply.emit(dataToSave);
    }
    getRegion() {
        const focus = this.selectionStore.get('focus');
        let range = this.selectionStore.get('range');
        if (!range) {
            range = column_service.getRange(focus, focus);
        }
        return range;
    }
    onCopy(e) {
        var _a;
        const range = this.getRegion();
        const canCopyEvent = this.beforeCopyRegion.emit(range);
        if (canCopyEvent.defaultPrevented) {
            return false;
        }
        let rangeData;
        if (range) {
            const { data, mapping } = this.columnService.copyRangeArray(range, this.dataStore);
            const event = this.rangeClipboardCopy.emit(Object.assign({ range,
                data,
                mapping }, this.types));
            if (!event.defaultPrevented) {
                rangeData = event.detail.data;
            }
        }
        (_a = this.clipboard) === null || _a === void 0 ? void 0 : _a.doCopy(e, rangeData);
        return true;
    }
    onPaste(data) {
        var _a;
        const focus = this.selectionStore.get('focus');
        const isEditing = this.selectionStore.get('edit') !== null;
        if (!focus || isEditing) {
            return;
        }
        let { changed, range } = this.columnService.getTransformedDataToApply(focus, data);
        const { defaultPrevented: canPaste } = this.rangeClipboardPaste.emit(Object.assign({ data: changed, models: collectModelsOfRange(changed, this.dataStore), range }, this.types));
        if (canPaste) {
            return;
        }
        (_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.onRangeApply(changed, range, range);
    }
    async focusNext() {
        var _a;
        const canFocus = await ((_a = this.keyboardService) === null || _a === void 0 ? void 0 : _a.keyChangeSelection(new KeyboardEvent('keydown', {
            code: dimension_helpers.codesLetter.ARROW_DOWN,
        }), this.range));
        if (!canFocus) {
            this.closeEdit();
        }
    }
    clearCell() {
        var _a;
        const range = this.selectionStore.get('range');
        if (range && !column_service.isRangeSingleCell(range)) {
            const data = this.columnService.getRangeStaticData(range, '');
            (_a = this.autoFillService) === null || _a === void 0 ? void 0 : _a.onRangeApply(data, range, range);
        }
        else if (this.canEdit()) {
            const focused = this.selectionStore.get('focus');
            if (!focused) {
                return;
            }
            const cell = this.columnService.getSaveData(focused.y, focused.x);
            this.cellEdit({
                rgRow: focused.y,
                rgCol: focused.x,
                val: '',
                type: cell.type,
                prop: cell.prop,
            });
        }
    }
    rowDragStart({ detail }) {
        detail.text = column_service.getCellData(this.columnService.rowDataModel(detail.cell.y, detail.cell.x).value);
    }
    /**
     * Verify if edit allowed.
     */
    canEdit() {
        var _a;
        if (this.readonly) {
            return false;
        }
        const focus = this.selectionStore.get('focus');
        return focus && !((_a = this.columnService) === null || _a === void 0 ? void 0 : _a.isReadOnly(focus.y, focus.x));
    }
    get edited() {
        return this.selectionStore.get('edit');
    }
    /**
     * Sets the focus on a cell and optionally edits a range.
     */
    focus(cell, isRangeEdit = false) {
        if (!cell)
            return false;
        const end = cell;
        const start = this.selectionStore.get('focus');
        if (isRangeEdit && start) {
            const range = column_service.getRange(start, end);
            if (range) {
                return this.triggerRangeEvent(range);
            }
        }
        return this.doFocus(cell, end);
    }
    get types() {
        return {
            rowType: this.dataStore.get('type'),
            colType: this.columnService.type,
        };
    }
    /**
     * Collect data
     */
    getData() {
        return {
            el: this.element,
            rows: this.dimensionRow.state,
            cols: this.dimensionCol.state,
            lastCell: this.lastCell,
            focus: this.selectionStore.get('focus'),
            range: this.selectionStore.get('range'),
            edit: this.selectionStore.get('edit'),
        };
    }
    get element() { return index.getElement(this); }
    static get watchers() { return {
        "selectionStore": ["selectionServiceSet"],
        "dimensionRow": ["createAutoFillService"],
        "dimensionCol": ["createAutoFillService"],
        "dataStore": ["columnServiceSet"],
        "colData": ["columnServiceSet"]
    }; }
};
OverlaySelection.style = RevogrOverlaySelectionStyle0;

const RowHeaderRender = s => (__, { rowIndex: i }) => s + i;

const RevogrRowHeaders = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.scrollViewport = index.createEvent(this, "scrollview", 3);
        this.elementToScroll = index.createEvent(this, "ref", 3);
        this.height = undefined;
        this.dataPorts = undefined;
        this.headerProp = undefined;
        this.rowClass = undefined;
        this.resize = undefined;
        this.rowHeaderColumn = undefined;
        this.additionalData = undefined;
        this.jobsBeforeRender = [];
    }
    render() {
        const dataViews = [];
        const viewport = new viewport_store.ViewportStore('colPinStart');
        /** render viewports rows */
        let totalLength = 1;
        // todo: this part could be optimized to avoid to often re-render dataPorts can be cached
        for (let data of this.dataPorts) {
            const itemCount = data.dataStore.get('items').length;
            // initiate row data
            const dataStore = new dimension_helpers.DataStore(data.type, Object.assign({}, data.dataStore.state));
            // initiate column data
            const colData = new dimension_helpers.DataStore('colPinStart');
            const column = Object.assign({ cellTemplate: RowHeaderRender(totalLength) }, this.rowHeaderColumn);
            colData.updateData([column]);
            dataViews.push(index.h("revogr-data", Object.assign({}, data, { colType: "rowHeaders", jobsBeforeRender: this.jobsBeforeRender, rowClass: this.rowClass, dataStore: dataStore.store, colData: colData.store, viewportCol: viewport.store, readonly: true, range: false })));
            totalLength += itemCount;
        }
        const colSize = viewport_store.calculateRowHeaderSize(totalLength, this.rowHeaderColumn);
        viewport.setViewport({
            realCount: 1,
            virtualSize: 0,
            items: [
                {
                    size: colSize,
                    start: 0,
                    end: colSize,
                    itemIndex: 0,
                },
            ],
        });
        const viewportScroll = {
            contentHeight: this.height,
            contentWidth: 0,
            style: { minWidth: `${colSize}px` },
            colType: 'rowHeaders',
            ref: (el) => this.elementToScroll.emit(el),
            onScrollviewport: (e) => this.scrollViewport.emit(e.detail),
        };
        const viewportHeader = Object.assign(Object.assign({}, this.headerProp), { colData: typeof this.rowHeaderColumn === 'object' ? [this.rowHeaderColumn] : [], viewportCol: viewport.store, canResize: false, type: dimension_helpers.ROW_HEADER_TYPE,
            // parent,
            slot: viewport_helpers.HEADER_SLOT });
        return (index.h(index.Host, { class: { [dimension_helpers.ROW_HEADER_TYPE]: true }, key: dimension_helpers.ROW_HEADER_TYPE }, index.h("revogr-viewport-scroll", Object.assign({ key: 'addb87ab3406b5691cecf810119582bda3a4b4a2' }, viewportScroll, { "row-header": true }), index.h("revogr-header", Object.assign({ key: '8621e76b132e7d1507794b515b40f525577413e2' }, viewportHeader)), dataViews)));
    }
};

/**
 * Autohide scroll for MacOS when scroll is visible only for 1 sec
 */
class AutohideScrollPlugin {
    constructor(element) {
        this.element = element;
        this.autohideScrollTimeout = 0;
    }
    /**
     * When scroll size updates set it up for autohide
     */
    setScrollSize(s) {
        if (!s) {
            this.element.setAttribute('autohide', 'true');
        }
        else {
            this.element.removeAttribute('autohide');
        }
    }
    /**
     * On each scroll check if it's time to show
     */
    checkScroll({ scrollSize, contentSize, virtualSize, }) {
        const hasScroll = contentSize > virtualSize;
        const isHidden = !scrollSize && hasScroll;
        if (isHidden) {
            this.element.setAttribute('visible', 'true');
            this.autohideScrollTimeout = this.show(this.element, this.autohideScrollTimeout);
        }
    }
    show(element, timeout) {
        clearTimeout(timeout);
        return Number(setTimeout(() => {
            element === null || element === void 0 ? void 0 : element.removeAttribute('visible');
        }, 1000));
    }
    clear() {
        clearTimeout(this.autohideScrollTimeout);
    }
}

const revogrScrollStyleCss = ".revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:\"::\"}.revo-alt-icon{-webkit-mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#4545ff;height:32px;line-height:32px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#009037}.revo-button.red{background-color:#E0662E}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.outline{border:1px solid #dbdbdb;line-height:30px;background:none;color:#000;box-shadow:none}revo-grid[theme^=dark] .revo-button.outline{border:1px solid #404040;color:#d8d8d8}revogr-scroll-virtual[autohide]{position:absolute;z-index:100 !important}revogr-scroll-virtual[autohide].vertical{top:0;right:0}revogr-scroll-virtual[autohide].vertical[visible]{min-width:20px !important}revogr-scroll-virtual[autohide].horizontal{bottom:0;left:0}revogr-scroll-virtual[autohide].horizontal[visible]{min-height:20px !important}revogr-scroll-virtual.vertical{overflow-y:auto;overflow-x:hidden;height:100%}revogr-scroll-virtual.vertical>div{width:1px}revogr-scroll-virtual.horizontal{overflow-x:auto;overflow-y:hidden;width:100%}revogr-scroll-virtual.horizontal>div{height:1px}";
const RevogrScrollVirtualStyle0 = revogrScrollStyleCss;

const RevogrScrollVirtual = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.scrollVirtual = index.createEvent(this, "scrollvirtual", 7);
        this.scrollSize = 0;
        this.dimension = 'rgRow';
        this.viewportStore = undefined;
        this.dimensionStore = undefined;
    }
    async setScroll(e) {
        var _a;
        if (this.dimension !== e.dimension) {
            return;
        }
        this.localScrollTimer.latestScrollUpdate(e.dimension);
        (_a = this.localScrollService) === null || _a === void 0 ? void 0 : _a.setScroll(e);
        if (e.coordinate) {
            this.autohideScrollPlugin.checkScroll({
                scrollSize: this.scrollSize,
                contentSize: this.dimensionStore.get('realSize'),
                virtualSize: this.viewportStore.get('virtualSize'),
            });
        }
    }
    /**
     * Update if `delta` exists in case we don't know current position or if it's external change
     */
    async changeScroll(e) {
        if (e.delta) {
            switch (e.dimension) {
                case 'rgCol':
                    e.coordinate = this.element.scrollLeft + e.delta;
                    break;
                case 'rgRow':
                    e.coordinate = this.element.scrollTop + e.delta;
                    break;
            }
            this.setScroll(e);
        }
        return e;
    }
    set size(s) {
        this.autohideScrollPlugin.setScrollSize(s);
        if (this.dimension === 'rgRow') {
            this.element.style.minWidth = `${s}px`;
            return;
        }
        this.element.style.minHeight = `${s}px`;
    }
    get size() {
        if (this.dimension === 'rgRow') {
            return this.element.clientHeight;
        }
        return this.element.clientWidth;
    }
    connectedCallback() {
        this.autohideScrollPlugin = new AutohideScrollPlugin(this.element);
        this.localScrollTimer = new throttle.LocalScrollTimer('ontouchstart' in document.documentElement ? 0 : 10);
        this.localScrollService = new throttle.LocalScrollService({
            runScroll: e => this.scrollVirtual.emit(e),
            applyScroll: e => {
                this.localScrollTimer.setCoordinate(e);
                const type = e.dimension === 'rgRow' ? 'scrollTop' : 'scrollLeft';
                // this will trigger on scroll event
                this.element[type] = e.coordinate;
            },
        });
    }
    disconnectedCallback() {
        this.autohideScrollPlugin.clear();
    }
    componentWillLoad() {
        this.scrollSize = dimension_helpers.getScrollbarSize(document);
    }
    componentDidRender() {
        const type = this.dimension === 'rgRow' ? 'scrollHeight' : 'scrollWidth';
        if (this.element[type] > this.size) {
            this.size = this.scrollSize;
        }
        else {
            this.size = 0;
        }
        this.localScrollService.setParams({
            contentSize: this.dimensionStore.get('realSize'),
            clientSize: this.size,
            virtualSize: this.viewportStore.get('clientSize'),
        }, this.dimension);
    }
    onScroll(e) {
        var _a;
        if (!(e.target instanceof Element)) {
            return;
        }
        const target = e.target;
        let type = 'scrollLeft';
        if (this.dimension === 'rgRow') {
            type = 'scrollTop';
        }
        // apply after throttling
        if (this.localScrollTimer.isReady(this.dimension, target[type] || 0)) {
            (_a = this.localScrollService) === null || _a === void 0 ? void 0 : _a.scroll(target[type] || 0, this.dimension);
        }
    }
    render() {
        const sizeType = this.dimension === 'rgRow' ? 'height' : 'width';
        const size = throttle.getContentSize(this.dimensionStore.get('realSize'), this.size, this.viewportStore.get('clientSize') // content viewport size
        );
        return (index.h(index.Host, { key: '2d11902403db45b805bde88b6fc40acff4b6b910', onScroll: (e) => this.onScroll(e) }, index.h("div", { key: '74978e90cbf66e3fb6dcc25bd5882346f1515c39', style: {
                [sizeType]: `${size}px`,
            } })));
    }
    get element() { return index.getElement(this); }
};
RevogrScrollVirtual.style = RevogrScrollVirtualStyle0;

const revogrTempRangeStyleCss = ".revo-drag-icon{width:11px;opacity:0.8}.revo-drag-icon::before{content:\"::\"}.revo-alt-icon{-webkit-mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");mask-image:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg viewBox='0 0 384 383' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cg%3E%3Cpath d='M192.4375,383 C197.424479,383 201.663411,381.254557 205.154297,377.763672 L205.154297,377.763672 L264.25,318.667969 C270.234375,312.683594 271.605794,306.075846 268.364258,298.844727 C265.122721,291.613607 259.51237,287.998047 251.533203,287.998047 L251.533203,287.998047 L213.382812,287.998047 L213.382812,212.445312 L288.935547,212.445312 L288.935547,250.595703 C288.935547,258.57487 292.551107,264.185221 299.782227,267.426758 C307.013346,270.668294 313.621094,269.296875 319.605469,263.3125 L319.605469,263.3125 L378.701172,204.216797 C382.192057,200.725911 383.9375,196.486979 383.9375,191.5 C383.9375,186.513021 382.192057,182.274089 378.701172,178.783203 L378.701172,178.783203 L319.605469,119.6875 C313.621094,114.201823 307.013346,112.955078 299.782227,115.947266 C292.551107,118.939453 288.935547,124.42513 288.935547,132.404297 L288.935547,132.404297 L288.935547,170.554688 L213.382812,170.554688 L213.382812,95.0019531 L251.533203,95.0019531 C259.51237,95.0019531 264.998047,91.3863932 267.990234,84.1552734 C270.982422,76.9241536 269.735677,70.3164062 264.25,64.3320312 L264.25,64.3320312 L205.154297,5.23632812 C201.663411,1.74544271 197.424479,0 192.4375,0 C187.450521,0 183.211589,1.74544271 179.720703,5.23632812 L179.720703,5.23632812 L120.625,64.3320312 C114.640625,70.3164062 113.269206,76.9241536 116.510742,84.1552734 C119.752279,91.3863932 125.36263,95.0019531 133.341797,95.0019531 L133.341797,95.0019531 L171.492188,95.0019531 L171.492188,170.554688 L95.9394531,170.554688 L95.9394531,132.404297 C95.9394531,124.42513 92.3238932,118.814779 85.0927734,115.573242 C77.8616536,112.331706 71.2539062,113.703125 65.2695312,119.6875 L65.2695312,119.6875 L6.17382812,178.783203 C2.68294271,182.274089 0.9375,186.513021 0.9375,191.5 C0.9375,196.486979 2.68294271,200.725911 6.17382812,204.216797 L6.17382812,204.216797 L65.2695312,263.3125 C71.2539062,268.798177 77.8616536,270.044922 85.0927734,267.052734 C92.3238932,264.060547 95.9394531,258.57487 95.9394531,250.595703 L95.9394531,250.595703 L95.9394531,212.445312 L171.492188,212.445312 L171.492188,287.998047 L133.341797,287.998047 C125.36263,287.998047 119.876953,291.613607 116.884766,298.844727 C113.892578,306.075846 115.139323,312.683594 120.625,318.667969 L120.625,318.667969 L179.720703,377.763672 C183.211589,381.254557 187.450521,383 192.4375,383 Z'%3E%3C/path%3E%3C/g%3E%3C/svg%3E\");width:11px;height:11px;background-size:cover;background-repeat:no-repeat}.arrow-down{position:absolute;right:5px;top:0}.arrow-down svg{width:8px;margin-top:5px;margin-left:5px;opacity:0.4}.cell-value-wrapper{margin-right:10px;overflow:hidden;text-overflow:ellipsis}.revo-button{position:relative;overflow:hidden;color:#fff;background-color:#4545ff;height:32px;line-height:32px;padding:0 15px;outline:0;border:0;border-radius:7px;box-sizing:border-box;cursor:pointer}.revo-button.green{background-color:#009037}.revo-button.red{background-color:#E0662E}.revo-button:disabled,.revo-button[disabled]{cursor:not-allowed !important;filter:opacity(0.35) !important}.revo-button.outline{border:1px solid #dbdbdb;line-height:30px;background:none;color:#000;box-shadow:none}revo-grid[theme^=dark] .revo-button.outline{border:1px solid #404040;color:#d8d8d8}.temp-bg-range{display:block !important;position:absolute;pointer-events:none;z-index:9;border:1px solid rgb(255, 94, 0);box-sizing:border-box}.temp-bg-range.Selection{border:1px dashed gray}.temp-bg-range>div{width:1px;height:1px;position:absolute}.temp-bg-range>div.top{top:-1px}.temp-bg-range>div.bottom{bottom:-1px}.temp-bg-range>div.left{left:-1px}.temp-bg-range>div.right{right:-1px}";
const RevogrTempRangeStyle0 = revogrTempRangeStyleCss;

const RevogrFocus = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.onChange = throttle.throttle((e) => this.doChange(e), 300);
        this.selectionStore = undefined;
        this.dimensionRow = undefined;
        this.dimensionCol = undefined;
    }
    doChange(e) {
        e === null || e === void 0 ? void 0 : e.scrollIntoView({
            block: 'nearest',
            inline: 'nearest',
        });
    }
    componentDidRender() {
        if (this.el) {
            this.onChange(this.el);
        }
    }
    render() {
        const data = this.selectionStore.get('tempRange');
        const type = this.selectionStore.get('tempRangeType');
        if (!data) {
            return;
        }
        let directionY = 'bottom';
        let derectionX = 'right';
        const range = this.getRange();
        if (!range) {
            return;
        }
        if (data.y < range.y) {
            directionY = 'top';
        }
        if (data.x < range.x) {
            derectionX = 'left';
        }
        const directionClass = `${derectionX} ${directionY}`;
        const cell = getCell(data, this.dimensionRow.state, this.dimensionCol.state);
        const styles = styleByCellProps(cell);
        const props = {
            class: {
                [dimension_helpers.TMP_SELECTION_BG_CLASS]: true,
                [type || '']: true,
            },
            style: styles,
            hidden: false
        };
        return (index.h(index.Host, Object.assign({}, props), index.h("div", { class: directionClass, ref: (e) => (this.el = e) })));
    }
    getRange() {
        const range = this.selectionStore.get('range');
        if (range) {
            return range;
        }
        const focus = this.selectionStore.get('focus');
        if (!focus) {
            return null;
        }
        return Object.assign(Object.assign({}, focus), { x1: focus.x, y1: focus.y });
    }
};
RevogrFocus.style = RevogrTempRangeStyle0;

exports.revogr_attribution = Attribution;
exports.revogr_extra = RevoGridExtra;
exports.revogr_focus = RevogrFocus$1;
exports.revogr_overlay_selection = OverlaySelection;
exports.revogr_row_headers = RevogrRowHeaders;
exports.revogr_scroll_virtual = RevogrScrollVirtual;
exports.revogr_temp_range = RevogrFocus;

//# sourceMappingURL=revogr-attribution_7.cjs.entry.js.map