{"version":3,"file":"store.types.js","sourceRoot":"","sources":["../../src/utils/store.types.ts"],"names":[],"mappings":"","sourcesContent":["export interface Handlers<T> {\n    dispose: DisposeEventHandler[];\n    get: GetEventHandler<T>[];\n    reset: ResetEventHandler[];\n    set: SetEventHandler<T>[];\n}\nexport type SetEventHandler<StoreType> = (key: keyof StoreType, newValue: any, oldValue: any) => void;\nexport type GetEventHandler<StoreType> = (key: keyof StoreType) => void;\nexport type ResetEventHandler = () => void;\nexport type DisposeEventHandler = () => void;\nexport interface OnHandler<StoreType> {\n    (eventName: 'set', callback: SetEventHandler<StoreType>): () => void;\n    (eventName: 'get', callback: GetEventHandler<StoreType>): () => void;\n    (eventName: 'dispose', callback: DisposeEventHandler): () => void;\n    (eventName: 'reset', callback: ResetEventHandler): () => void;\n}\nexport interface OnChangeHandler<StoreType> {\n    <Key extends keyof StoreType>(propName: Key, cb: (newValue: StoreType[Key]) => void): () => void;\n}\nexport interface Subscription<StoreType> {\n    dispose?(): void;\n    get?<KeyFromStoreType extends keyof StoreType>(key: KeyFromStoreType): void;\n    set?<KeyFromStoreType extends keyof StoreType>(key: KeyFromStoreType, newValue: StoreType[KeyFromStoreType], oldValue: StoreType[KeyFromStoreType]): void;\n    reset?(): void;\n}\nexport interface Getter<T> {\n    <P extends keyof T>(propName: P & string): T[P];\n}\nexport interface Setter<T> {\n    <P extends keyof T>(propName: P & string, value: T[P]): void;\n}\nexport interface ObservableMap<T> {\n    /**\n     * Proxied object that will detect dependencies and call\n     * the subscriptions and computed properties.\n     *\n     * If available, it will detect from which Stencil Component\n     * it was called and rerender it when the property changes.\n     *\n     * Note: Proxy objects are not supported by IE11 (not even with a polyfill)\n     * so you need to use the store.get and store.set methods of the API if you wish to support IE11.\n     *\n     */\n    state: T;\n    /**\n     * Only useful if you need to support IE11.\n     *\n     * @example\n     * const { state, get } = createStore({ hola: 'hello', adios: 'goodbye' });\n     * console.log(state.hola); // If you don't need to support IE11, use this way.\n     * console.log(get('hola')); // If you need to support IE11, use this other way.\n     */\n    get: Getter<T>;\n    /**\n     * Only useful if you need to support IE11.\n     *\n     * @example\n     * const { state, get } = createStore({ hola: 'hello', adios: 'goodbye' });\n     * state.hola = 'ola'; // If you don't need to support IE11, use this way.\n     * set('hola', 'ola')); // If you need to support IE11, use this other way.\n     */\n    set: Setter<T>;\n    /**\n     * Register a event listener, you can listen to `set`, `get` and `reset` events.\n     *\n     * @example\n     * store.on('set', (prop, value) => {\n     *   console.log(`Prop ${prop} changed to: ${value}`);\n     * });\n     */\n    on: OnHandler<T>;\n    /**\n     * Easily listen for value changes of the specified key.\n     */\n    onChange: OnChangeHandler<T>;\n    /**\n     * Resets the state to its original state and\n     * signals a dispose event to all the plugins.\n     *\n     * This method is intended for plugins to reset\n     * all their internal state between tests.\n     */\n    dispose(): void;\n    /**\n     * Resets the state to its original state.\n     */\n    reset(): void;\n    /**\n     * Registers a subscription that will be called whenever the user gets, sets, or\n     * resets a value.\n     */\n    use(...plugins: Subscription<T>[]): () => void;\n    /**\n     * Force a rerender of the specified key, just like the value changed.\n     */\n    forceUpdate(key: keyof T): any;\n}\n"]}