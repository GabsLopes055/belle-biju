{"version":3,"file":"selection.store.connector.js","sourceRoot":"","sources":["../../src/services/selection.store.connector.ts"],"names":[],"mappings":"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","sourcesContent":["import { cropCellToMax, isHiddenStore, nextCell, SelectionStore } from '@store';\nimport type {\n  MultiDimensionType,\n  DimensionCols,\n  DimensionRows,\n  Cell,\n  EditCellStore,\n  RangeArea,\n} from '@type';\n\ntype StoreByDimension = Record<number, SelectionStore>;\ntype FocusedStore = {\n  entity: SelectionStore;\n  cell: Cell;\n  position: Cell;\n};\n\ntype StoresMapping<T> = { [xOrY: number]: Partial<T> };\n\nexport const EMPTY_INDEX = -1;\n\nexport class SelectionStoreConnector {\n  // dirty flag required to cleanup whole store in case visibility of panels changed\n  private dirty = false;\n  readonly stores: { [y: number]: { [x: number]: SelectionStore } } = {};\n\n  readonly columnStores: StoreByDimension = {};\n  readonly rowStores: { [y: number]: SelectionStore } = {};\n\n  /**\n   * Helpers for data conversion\n   */\n  readonly storesByType: Partial<Record<MultiDimensionType, number>> = {};\n  readonly storesXToType: StoresMapping<DimensionCols> = {};\n  readonly storesYToType: StoresMapping<DimensionRows> = {};\n\n  get focusedStore(): FocusedStore | null {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const focused = this.stores[y][x]?.store.get('focus');\n        if (focused) {\n          return {\n            entity: this.stores[y][x],\n            cell: focused,\n            position: {\n              x: parseInt(x, 10),\n              y: parseInt(y, 10),\n            },\n          };\n        }\n      }\n    }\n    return null;\n  }\n\n  get edit(): EditCellStore | null | undefined {\n    return this.focusedStore?.entity.store.get('edit');\n  }\n\n  get focused(): Cell | null | undefined {\n    return this.focusedStore?.entity.store.get('focus');\n  }\n\n  get selectedRange(): RangeArea | null | undefined {\n    return this.focusedStore?.entity.store.get('range');\n  }\n\n  private readonly sections: Element[] = [];\n\n  registerSection(e?: Element) {\n    if (!e) {\n      this.sections.length = 0;\n      // some elements removed, rebuild stores\n      this.dirty = true;\n      return;\n    }\n    if (this.sections.indexOf(e) === -1) {\n      this.sections.push(e);\n    }\n  }\n\n  // check if require to cleanup all stores\n  beforeUpdate() {\n    if (this.dirty) {\n      for (let y in this.stores) {\n        for (let x in this.stores[y]) {\n          this.stores[y][x].dispose();\n        }\n      }\n      this.dirty = false;\n    }\n  }\n\n  registerColumn(x: number, type: DimensionCols): SelectionStore {\n    // if hidden just create store but no operations needed\n    if (isHiddenStore(x)) {\n      return new SelectionStore();\n    }\n    if (this.columnStores[x]) {\n      return this.columnStores[x];\n    }\n    this.columnStores[x] = new SelectionStore();\n    // build cross-linking type to position\n    this.storesByType[type] = x;\n    this.storesXToType[x] = type;\n    return this.columnStores[x];\n  }\n\n  registerRow(y: number, type: DimensionRows): SelectionStore {\n    // if hidden just create store\n    if (isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (this.rowStores[y]) {\n      return this.rowStores[y];\n    }\n    this.rowStores[y] = new SelectionStore();\n    // build cross linking type to position\n    this.storesByType[type] = y;\n    this.storesYToType[y] = type;\n    return this.rowStores[y];\n  }\n\n  /**\n   * Cross store proxy, based on multiple dimensions\n   */\n  register({ x, y }: Cell): SelectionStore {\n    // if hidden just create store\n    if (isHiddenStore(x) || isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (!this.stores[y]) {\n      this.stores[y] = {};\n    }\n    if (this.stores[y][x]) {\n      // Store already registered. Do not register twice\n      return this.stores[y][x];\n    }\n    this.stores[y][x] = new SelectionStore();\n    // proxy update, column store trigger only range area\n    this.stores[y][x]?.onChange('range', c => {\n      this.columnStores[x].setRangeArea(c);\n      this.rowStores[y].setRangeArea(c);\n    });\n    // clean up on remove\n    this.stores[y][x]?.store.on('dispose', () => this.destroy(x, y));\n    return this.stores[y][x];\n  }\n\n  private destroy(x: number, y: number) {\n    this.columnStores[x]?.dispose();\n    this.rowStores[y]?.dispose();\n\n    delete this.rowStores[y];\n    delete this.columnStores[x];\n    // clear x cross-link\n    if (this.storesXToType[x]) {\n      const type = this.storesXToType[x];\n      delete this.storesXToType[x];\n      delete this.storesByType[type];\n    }\n    // clear y cross-link\n    if (this.storesYToType[y]) {\n      const type = this.storesYToType[y];\n      delete this.storesYToType[y];\n      delete this.storesByType[type];\n    }\n    if (this.stores[y]) {\n      delete this.stores[y][x];\n    }\n    // clear empty rows\n    if (!Object.keys(this.stores[y] || {}).length) {\n      delete this.stores[y];\n    }\n  }\n\n  setEditByCell<T extends Cell>(storePos: T, editCell: T) {\n    this.focusByCell(storePos, editCell, editCell);\n    this.setEdit('');\n  }\n\n  /**\n   * Sets the next focus cell before the current one.\n   * \n   * @param focus - The cell to set as the next focus.\n   */\n  beforeNextFocusCell(focus: Cell) {\n    // If there is no focused store, return early.\n    if (!this.focusedStore) {\n      return;\n    }\n\n    // Get the next store based on the current focus and the last cell.\n    const lastCell = this.focusedStore.entity.store.get('lastCell');\n    const next = lastCell && this.getNextStore(focus, this.focusedStore.position, lastCell);\n\n    // Set the next focus cell in the store.\n    next?.store?.setNextFocus({ ...focus, ...next.item });\n  }\n\n  focusByCell<T extends Cell>(storePos: T, start: T, end: T) {\n    const store = this.stores[storePos.y][storePos.x];\n    this.focus(store, { focus: start, end });\n  }\n\n  focus(store: SelectionStore, { focus, end }: { focus: Cell; end: Cell }) {\n    const currentStorePointer = this.getCurrentStorePointer(store);\n    if (!currentStorePointer) {\n      return null;\n    }\n\n    // check for the focus in nearby store/viewport\n    const lastCell = store.store.get('lastCell');\n    const next = lastCell && this.getNextStore(focus, currentStorePointer, lastCell);\n\n    // if next store present - update\n    if (next?.store) {\n      const item = { ...focus, ...next.item };\n      this.focus(next.store, { focus: item, end: item });\n      return null;\n    }\n\n    if (lastCell) {\n      focus = cropCellToMax(focus, lastCell);\n      end = cropCellToMax(end, lastCell);  \n    }\n    store.setFocus(focus, end);\n    return focus;\n  }\n\n  /**\n   * Retrieves the current store pointer based on the active store.\n   * Clears focus from all stores except the active one.\n   */\n  getCurrentStorePointer(store: SelectionStore) {\n    let currentStorePointer: Cell | undefined;\n\n    // Iterate through all stores\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const s = this.stores[y][x];\n\n        // Clear focus from stores other than the active one\n        if (s !== store) {\n          s.clearFocus();\n        } else {\n          // Update the current store pointer with the active store coordinates\n          currentStorePointer = { \n            x: parseInt(x, 10), \n            y: parseInt(y, 10) \n          };\n        }\n      }\n    }\n\n    return currentStorePointer;\n  }\n\n  /**\n   * Retrieves the next store based on the focus cell and current store pointer.\n   * If the next store exists, returns an object with the next store and the item in the new store.\n   * If the next store does not exist, returns null.\n   */\n  getNextStore(\n    focus: Cell,\n    currentStorePointer: Cell,\n    lastCell: Cell,\n  ) {\n    // item in new store\n    const nextItem: Partial<Cell> | null = nextCell(focus, lastCell);\n\n    let nextStore: SelectionStore | undefined;\n    if (nextItem) {\n      Object.entries(nextItem).forEach(([type, nextItemCoord]: [keyof Cell, number]) => {\n        let stores;\n        switch (type) {\n          case 'x':\n            // Get the X stores for the current Y coordinate of the current store pointer\n            stores = this.getXStores(currentStorePointer.y);\n            break;\n          case 'y':\n            // Get the Y stores for the current X coordinate of the current store pointer\n            stores = this.getYStores(currentStorePointer.x);\n            break;\n        }\n\n        // Get the next store based on the item in the new store\n        if (nextItemCoord >= 0) {\n          nextStore = stores[++currentStorePointer[type]];\n        } else {\n          nextStore = stores[--currentStorePointer[type]];\n          const nextLastCell = nextStore?.store.get('lastCell');\n          if (nextLastCell) {\n            nextItem[type] = nextLastCell[type] + nextItemCoord;\n          }\n        }\n    });\n  }\n    return {\n      store: nextStore,\n      item: nextItem,\n    };\n  }\n\n  clearAll() {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        this.stores[y][x]?.clearFocus();\n      }\n    }\n  }\n\n  setEdit(val?: string | boolean) {\n    if (!this.focusedStore) {\n      return;\n    }\n    this.focusedStore.entity.setEdit(val);\n  }\n\n  /**\n   * Select all cells across all stores\n   */\n  selectAll() {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const store = this.stores[y][x];\n        if (!store) {\n          continue;\n        }\n        const lastCell = store.store.get('lastCell');\n        if (lastCell) {\n          store.setRange(\n            { x: 0, y: 0 },\n            { x: lastCell.x - 1, y: lastCell.y - 1 },\n          );\n        }\n      }\n    }\n  }\n\n  private getXStores(y: number) {\n    return this.stores[y];\n  }\n\n  private getYStores(x: number) {\n    const stores: { [p: number]: SelectionStore } = {};\n    for (let i in this.stores) {\n      stores[i] = this.stores[i][x];\n    }\n    return stores;\n  }\n}\n"]}