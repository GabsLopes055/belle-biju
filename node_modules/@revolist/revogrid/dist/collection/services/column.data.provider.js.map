{"version":3,"file":"column.data.provider.js","sourceRoot":"","sources":["../../src/services/column.data.provider.ts"],"names":[],"mappings":"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","sourcesContent":["import reduce from 'lodash/reduce';\nimport {\n  columnTypes,\n  DataStore,\n  getSourceItem,\n  getSourceItemVirtualIndexByProp,\n  Groups,\n  setSourceByPhysicalIndex,\n  setSourceByVirtualIndex,\n} from '@store';\nimport type {\n  ColumnProp,\n  ColumnRegular,\n  DimensionCols,\n} from '@type';\nimport { ColumnCollection, getColumnType } from '../utils/column.utils';\n\nexport type ColumnDataSources = Record<\n  DimensionCols,\n  DataStore<ColumnRegular, DimensionCols>\n>;\n\nexport default class ColumnDataProvider {\n  readonly dataSources: ColumnDataSources;\n  collection: ColumnCollection | null = null;\n\n  get stores() {\n    return this.dataSources;\n  }\n  constructor() {\n    this.dataSources = columnTypes.reduce(\n      (sources: ColumnDataSources, k: DimensionCols) => {\n        sources[k] = new DataStore(k);\n        return sources;\n      },\n      {} as ColumnDataSources,\n    );\n  }\n\n  column(c: number, type: DimensionCols = 'rgCol'): ColumnRegular | undefined {\n    return this.getColumn(c, type);\n  }\n\n  getColumn(\n    virtualIndex: number,\n    type: DimensionCols,\n  ): ColumnRegular | undefined {\n    return getSourceItem(this.dataSources[type].store, virtualIndex);\n  }\n\n  getRawColumns(): Record<DimensionCols, ColumnRegular[]> {\n    return reduce(\n      this.dataSources,\n      (\n        result: Record<DimensionCols, ColumnRegular[]>,\n        item,\n        type: DimensionCols,\n      ) => {\n        result[type] = item.store.get('source');\n        return result;\n      },\n      {\n        rgCol: [],\n        colPinStart: [],\n        colPinEnd: [],\n      },\n    );\n  }\n\n  getColumns(type: DimensionCols | 'all' = 'all'): ColumnRegular[] {\n    const columnsByType = this.getRawColumns();\n    if (type !== 'all') {\n      return columnsByType[type];\n    }\n    return columnTypes.reduce((r: ColumnRegular[], t) => [...r, ...columnsByType[t]], []);\n  }\n\n  getColumnIndexByProp(prop: ColumnProp, type: DimensionCols): number {\n    return getSourceItemVirtualIndexByProp(this.dataSources[type].store, prop);\n  }\n\n  getColumnByProp(prop: ColumnProp) {\n    return this.collection?.columnByProp[prop];\n  }\n\n  refreshByType(type: DimensionCols) {\n    this.dataSources[type].refresh();\n  }\n\n  /**\n   * Main method to set columns\n   */\n  setColumns(data: ColumnCollection): ColumnCollection {\n    columnTypes.forEach(k => {\n      // set columns data\n      this.dataSources[k].updateData(data.columns[k], {\n        // max depth level\n        depth: data.maxLevel,\n\n        // groups\n        groups: data.columnGrouping[k].reduce((res: Groups, g) => {\n          if (!res[g.level]) {\n            res[g.level] = [];\n          }\n          res[g.level].push(g);\n          return res;\n        }, {}),\n      });\n    });\n    this.collection = data;\n    return data;\n  }\n\n  /**\n   * Used in plugins\n   * Modify columns in store\n   */\n  updateColumns(updatedColumns: ColumnRegular[]) {\n    // collect column by type and propert\n    const columnByKey = updatedColumns.reduce(\n      (\n        res: Partial<Record<DimensionCols, Record<ColumnProp, ColumnRegular>>>,\n        c,\n      ) => {\n        const type = getColumnType(c);\n        if (!res[type]) {\n          res[type] = {};\n        }\n        res[type][c.prop] = c;\n        return res;\n      },\n      {},\n    );\n\n    // find indexes in source\n    const colByIndex: Partial<\n      Record<DimensionCols, Record<number, ColumnRegular>>\n    > = {};\n    for (const t in columnByKey) {\n      if (!columnByKey.hasOwnProperty(t)) {\n        continue;\n      }\n      const type = t as DimensionCols;\n      const colsToUpdate = columnByKey[type];\n      const sourceItems = this.dataSources[type].store.get('source');\n      colByIndex[type] = {};\n      for (let i = 0; i < sourceItems.length; i++) {\n        const column = sourceItems[i];\n        const colToUpdateIfExists = colsToUpdate?.[column.prop];\n\n        // update column if exists in source\n        if (colToUpdateIfExists) {\n          colByIndex[type][i] = colToUpdateIfExists;\n        }\n      }\n    }\n    for (const t in colByIndex) {\n      if (!colByIndex.hasOwnProperty(t)) {\n        continue;\n      }\n      const type = t as DimensionCols;\n      setSourceByPhysicalIndex(\n        this.dataSources[type].store,\n        colByIndex[type] || {},\n      );\n    }\n  }\n\n  updateColumn(column: ColumnRegular, index: number) {\n    const type = getColumnType(column);\n    setSourceByVirtualIndex(this.dataSources[type].store, { [index]: column });\n  }\n}\n"]}