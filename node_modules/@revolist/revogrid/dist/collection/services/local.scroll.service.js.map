{"version":3,"file":"local.scroll.service.js","sourceRoot":"","sources":["../../src/services/local.scroll.service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DimensionType, ViewPortScrollEvent } from '@type';\nimport { scaleValue } from '../utils';\n\ninterface Config {\n  skipAnimationFrame?: boolean;\n  // scroll event inited and direction cached\n  // scrollingService.proxyScroll get tiggered\n  // setScroll event called from scrollingService\n  runScroll(e: ViewPortScrollEvent): void;\n  // all operation finished, apply scroll values\n  applyScroll(e: ViewPortScrollEvent): void;\n}\n\ntype Params = {\n  contentSize: number;\n  virtualContentSize?: number;\n  clientSize: number;\n  virtualSize: number;\n  maxSize?: number;\n};\n\nconst initialParams: Params = {\n  contentSize: 0,\n  clientSize: 0,\n  virtualSize: 0,\n  maxSize: 0,\n};\nconst NO_COORDINATE = -1;\n\n/**\n * Based on content size, client size and virtual size\n * return full size\n */\nexport function getContentSize(\n  contentSize: number,\n  clientSize: number,\n  virtualSize = 0,\n): number {\n  if (virtualSize > contentSize) {\n    return 0;\n  }\n  return contentSize + (virtualSize ? clientSize - virtualSize : 0);\n}\n\nexport default class LocalScrollService {\n  private preventArtificialScroll: Record<DimensionType, (() => void) | null> = {\n    rgRow: null,\n    rgCol: null,\n  };\n  // to check if scroll changed\n  private previousScroll: Record<DimensionType, number> = {\n    rgRow: NO_COORDINATE,\n    rgCol: NO_COORDINATE,\n  };\n  private params: Record<DimensionType, Params> = {\n    rgRow: { ...initialParams },\n    rgCol: { ...initialParams },\n  };\n\n  constructor(private cfg: Config) {}\n\n  setParams(params: Params, dimension: DimensionType) {\n    const virtualContentSize = getContentSize(\n      params.contentSize,\n      params.clientSize,\n      params.virtualSize,\n    );\n    this.params[dimension] = {\n      ...params,\n      maxSize: virtualContentSize - params.clientSize,\n      virtualContentSize,\n    };\n  }\n\n  // apply scroll values after scroll done\n  async setScroll(e: ViewPortScrollEvent) {\n    this.cancelScroll(e.dimension);\n\n    // start frame animation\n    const frameAnimation = new Promise<void>((resolve, reject) => {\n      // for example safari desktop has issues with animation frame\n      if (this.cfg.skipAnimationFrame) {\n        return resolve();\n      }\n      const animationId = window.requestAnimationFrame(() => {\n        resolve();\n      });\n      this.preventArtificialScroll[e.dimension] = reject.bind(\n        null,\n        animationId,\n      );\n    });\n\n    try {\n      await frameAnimation;\n      const params = this.getParams(e.dimension);\n      e.coordinate = Math.ceil(e.coordinate);\n      this.previousScroll[e.dimension] = this.wrapCoordinate(\n        e.coordinate,\n        params,\n      );\n      this.preventArtificialScroll[e.dimension] = null;\n      this.cfg.applyScroll({\n        ...e,\n        coordinate: params.virtualSize\n          ? this.convert(e.coordinate, params, false)\n          : e.coordinate,\n      });\n    } catch (id) {\n      window.cancelAnimationFrame(id);\n    }\n  }\n\n  /**\n   * On scroll event started\n   */\n  scroll(\n    coordinate: number,\n    dimension: DimensionType,\n    force = false,\n    delta?: number,\n    outside = false,\n  ) {\n    // cancel all previous scrolls for same dimension\n    this.cancelScroll(dimension);\n\n    // drop if no change\n    if (!force && this.previousScroll[dimension] === coordinate) {\n      this.previousScroll[dimension] = NO_COORDINATE;\n      return;\n    }\n\n    const param = this.getParams(dimension);\n    // let component know about scroll event started\n    this.cfg.runScroll({\n      dimension: dimension,\n      coordinate: param.virtualSize\n        ? this.convert(coordinate, param)\n        : coordinate,\n      delta,\n      outside,\n    });\n  }\n\n  private getParams(dimension: DimensionType): Params {\n    return this.params[dimension];\n  }\n\n  // check if scroll outside of region to avoid looping\n  private wrapCoordinate(c: number, param: Params): number {\n    if (c < 0) {\n      return NO_COORDINATE;\n    }\n\n    if (typeof param.maxSize === 'number' && c > param.maxSize) {\n      return param.maxSize;\n    }\n    return c;\n  }\n\n  // prevent already started scroll, performance optimization\n  private cancelScroll(dimension: DimensionType) {\n    this.preventArtificialScroll[dimension]?.();\n    this.preventArtificialScroll[dimension] = null;\n  }\n\n  /* convert virtual to real and back, scale range */\n  private convert(pos: number, param: Params, toReal = true): number {\n    const minRange = param.clientSize;\n    const from: [number, number] = [0, (param.virtualContentSize ?? minRange) - minRange];\n    const to: [number, number] = [0, param.contentSize - param.virtualSize];\n    if (toReal) {\n      return scaleValue(pos, from, to);\n    }\n    return scaleValue(pos, to, from);\n  }\n}\n"]}