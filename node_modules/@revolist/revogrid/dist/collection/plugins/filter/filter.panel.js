/*!
 * Built by Revolist OU ❤️
 */
// filter.panel.tsx
import { h, Host, } from "@stencil/core";
import debounce from "lodash/debounce";
import { AndOrButton, isFilterBtn, TrashButton } from "./filter.button";
import "../../utils/closest.polifill";
const defaultType = 'none';
const FILTER_LIST_CLASS = 'multi-filter-list';
const FILTER_LIST_CLASS_ACTION = 'multi-filter-list-action';
const FILTER_ID = 'add-filter';
/**
 * Filter panel for editing filters
 */
/**
 * @internal
 */
export class FilterPanel {
    constructor() {
        this.filterCaptionsInternal = {
            title: 'Filter by',
            ok: 'Close',
            save: 'Save',
            // drops the filter
            reset: 'Reset',
            cancel: 'Cancel',
            add: 'Add condition',
            placeholder: 'Enter value...',
            and: 'and',
            or: 'or',
        };
        this.isFilterIdSet = false;
        this.filterId = 0;
        this.currentFilterId = -1;
        this.currentFilterType = defaultType;
        this.filterItems = {};
        this.filterNames = {};
        this.filterEntities = {};
        /**
         * Disables dynamic filtering. A way to apply filters on Save only
         */
        this.disableDynamicFiltering = false;
        /**
         * If true, closes the filter panel when clicking outside
         */
        this.closeOnOutsideClick = true;
        this.debouncedApplyFilter = debounce(() => {
            this.filterChange.emit(this.filterItems);
        }, 400);
    }
    onMouseDown(e) {
        // click on anything then select drops values to default
        if (!this.changes) {
            return;
        }
        const path = e.composedPath();
        const select = document.getElementById(FILTER_ID);
        if (select instanceof HTMLSelectElement) {
            // click on select should be skipped
            if (path.includes(select)) {
                return;
            }
            select.value = defaultType;
        }
        this.currentFilterType = defaultType;
        if (this.changes) {
            this.changes.type = defaultType;
        }
        this.currentFilterId = -1;
        const isOutside = !path.includes(this.element);
        if (e.target instanceof HTMLElement &&
            isOutside &&
            !isFilterBtn(e.target) &&
            this.closeOnOutsideClick) {
            this.changes = undefined;
        }
    }
    async show(newEntity) {
        this.changes = newEntity;
        this.filterItems = (newEntity === null || newEntity === void 0 ? void 0 : newEntity.filterItems) || {};
        if (this.changes) {
            this.changes.type = this.changes.type || defaultType;
        }
    }
    async getChanges() {
        return this.changes;
    }
    componentWillRender() {
        if (!this.isFilterIdSet) {
            this.isFilterIdSet = true;
            const filterItems = Object.keys(this.filterItems);
            for (const prop of filterItems) {
                // we set the proper filterId so there won't be any conflict when removing filters
                this.filterId += this.filterItems[prop].length;
            }
        }
    }
    getFilterItemsList() {
        var _a, _b;
        const prop = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.prop;
        if (typeof prop === 'undefined')
            return '';
        const propFilters = (_b = this.filterItems[prop]) !== null && _b !== void 0 ? _b : [];
        const capts = Object.assign(this.filterCaptionsInternal, this.filterCaptions);
        return (h("div", { key: this.filterId }, propFilters.map((filter, index) => {
            let andOrButton;
            if (filter.hidden) {
                return;
            }
            // hide toggle button if there is only one filter and the last one
            if (index !== this.filterItems[prop].length - 1) {
                andOrButton = (h("div", { onClick: () => this.toggleFilterAndOr(filter.id) }, h(AndOrButton, { text: filter.relation === 'and' ? capts.and : capts.or })));
            }
            return (h("div", { key: filter.id, class: FILTER_LIST_CLASS }, h("div", { class: { 'select-input': true } }, h("select", { class: "select-css select-filter", onChange: e => this.onFilterTypeChange(e, prop, index) }, this.renderSelectOptions(this.filterItems[prop][index].type, true)), h("div", { class: FILTER_LIST_CLASS_ACTION }, andOrButton), h("div", { onClick: () => this.onRemoveFilter(filter.id) }, h(TrashButton, null))), h("div", null, this.renderExtra(prop, index))));
        }), propFilters.filter(f => !f.hidden).length > 0 ? h("div", { class: "add-filter-divider" }) : ''));
    }
    autoCorrect(el) {
        var _a, _b;
        if (!el) {
            return;
        }
        const revoGrid = el.closest('revo-grid');
        if (!revoGrid) {
            return;
        }
        const pos = el.getBoundingClientRect();
        const gridPos = revoGrid.getBoundingClientRect();
        const maxLeft = gridPos.right - pos.width;
        if (pos.left > maxLeft && el.offsetLeft) {
            el.style.left = `${maxLeft - ((_b = (_a = el.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().left) !== null && _b !== void 0 ? _b : 0)}px`;
        }
    }
    onFilterTypeChange(e, prop, index) {
        if (!(e.target instanceof HTMLSelectElement)) {
            return;
        }
        this.filterItems[prop][index].type = e.target.value;
        // this re-renders the input to know if we need extra input
        this.filterId++;
        // adding setTimeout will wait for the next tick DOM update then focus on input
        setTimeout(() => {
            const input = document.getElementById('filter-input-' + this.filterItems[prop][index].id);
            if (input instanceof HTMLInputElement) {
                input.focus();
            }
        }, 0);
        if (!this.disableDynamicFiltering) {
            this.debouncedApplyFilter();
        }
    }
    onAddNewFilter(e) {
        const el = e.target;
        this.currentFilterType = el.value;
        this.addNewFilterToProp();
        // reset value after adding new filter
        const select = document.getElementById('add-filter');
        if (select) {
            select.value = defaultType;
            this.currentFilterType = defaultType;
        }
        if (!this.disableDynamicFiltering) {
            this.debouncedApplyFilter();
        }
    }
    addNewFilterToProp() {
        var _a;
        const prop = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.prop;
        if (!(prop || prop === 0))
            return;
        if (!this.filterItems[prop]) {
            this.filterItems[prop] = [];
        }
        if (this.currentFilterType === 'none')
            return;
        this.filterId++;
        this.currentFilterId = this.filterId;
        this.filterItems[prop].push({
            id: this.currentFilterId,
            type: this.currentFilterType,
            value: '',
            relation: 'and',
        });
        // adding setTimeout will wait for the next tick DOM update then focus on input
        setTimeout(() => {
            const input = document.getElementById('filter-input-' + this.currentFilterId);
            if (input)
                input.focus();
        }, 0);
    }
    onSave() {
        this.filterChange.emit(this.filterItems);
    }
    onCancel() {
        this.changes = undefined;
    }
    onReset() {
        var _a;
        this.assertChanges();
        this.resetChange.emit((_a = this.changes) === null || _a === void 0 ? void 0 : _a.prop);
        // this updates the DOM which is used by getFilterItemsList() key
        this.filterId++;
    }
    onRemoveFilter(id) {
        var _a;
        this.assertChanges();
        // this is for reactivity issues for getFilterItemsList()
        this.filterId++;
        const prop = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.prop;
        const items = this.filterItems[prop !== null && prop !== void 0 ? prop : ''];
        if (!items)
            return;
        const index = items.findIndex(d => d.id === id);
        if (index === -1)
            return;
        items.splice(index, 1);
        // let's remove the prop if no more filters so the filter icon will be removed
        if (items.length === 0)
            delete this.filterItems[prop !== null && prop !== void 0 ? prop : ''];
        if (!this.disableDynamicFiltering) {
            this.debouncedApplyFilter();
        }
    }
    toggleFilterAndOr(id) {
        var _a;
        this.assertChanges();
        // this is for reactivity issues for getFilterItemsList()
        this.filterId++;
        const prop = (_a = this.changes) === null || _a === void 0 ? void 0 : _a.prop;
        const items = this.filterItems[prop !== null && prop !== void 0 ? prop : ''];
        if (!items)
            return;
        const index = items.findIndex(d => d.id === id);
        if (index === -1)
            return;
        items[index].relation = items[index].relation === 'and' ? 'or' : 'and';
        if (!this.disableDynamicFiltering) {
            this.debouncedApplyFilter();
        }
    }
    assertChanges() {
        if (!this.changes) {
            throw new Error('Changes required per edit');
        }
    }
    renderSelectOptions(type, isDefaultTypeRemoved = false) {
        if (!this.changes) {
            return;
        }
        const options = [];
        const prop = this.changes.prop;
        const hidden = new Set();
        Object.entries(this.filterItems).forEach(([_, values]) => {
            values.forEach((filter) => {
                if (filter.hidden) {
                    hidden.add(filter.type);
                }
            });
        });
        if (!isDefaultTypeRemoved) {
            const capts = Object.assign(this.filterCaptionsInternal, this.filterCaptions);
            options.push(h("option", { selected: this.currentFilterType === defaultType, value: defaultType }, prop && this.filterItems[prop] && this.filterItems[prop].length > 0
                ? capts.add
                : this.filterNames[defaultType]));
        }
        for (let gIndex in this.changes.filterTypes) {
            const group = this.changes.filterTypes[gIndex].filter(k => !hidden.has(k));
            if (group.length) {
                options.push(...group.map(k => (h("option", { value: k, selected: type === k }, this.filterNames[k]))));
                options.push(h("option", { disabled: true }));
            }
        }
        return options;
    }
    renderExtra(prop, index) {
        const currentFilter = this.filterItems[prop];
        if (!currentFilter)
            return '';
        const applyFilter = (value) => {
            this.filterItems[prop][index].value = value;
            if (!this.disableDynamicFiltering) {
                this.debouncedApplyFilter();
            }
        };
        const focusNext = () => {
            const select = document.getElementById('add-filter');
            if (select) {
                select.value = defaultType;
                this.currentFilterType = defaultType;
                this.addNewFilterToProp();
                select.focus();
            }
        };
        const capts = Object.assign(this.filterCaptionsInternal, this.filterCaptions);
        const extra = this.filterEntities[currentFilter[index].type].extra;
        if (typeof extra === 'function') {
            return extra(h, {
                value: currentFilter[index].value,
                filter: currentFilter[index],
                prop,
                index,
                placeholder: capts.placeholder,
                onInput: (value) => {
                    applyFilter(value);
                },
                onFocus: () => {
                    focusNext();
                }
            });
        }
        if (extra !== 'input' && extra !== 'datepicker') {
            return '';
        }
        return (h("input", { id: `filter-input-${currentFilter[index].id}`, placeholder: capts.placeholder, type: extra === 'datepicker' ? 'date' : 'text', value: currentFilter[index].value, onInput: (e) => {
                if (e.target instanceof HTMLInputElement) {
                    applyFilter(e.target.value);
                }
            }, onKeyDown: e => {
                if (e.key.toLowerCase() === 'enter') {
                    const select = document.getElementById('add-filter');
                    if (select) {
                        focusNext();
                    }
                    return;
                }
                // keep event local, don't escalate farther to dom
                e.stopPropagation();
            } }));
    }
    render() {
        var _a, _b, _c;
        if (!this.changes) {
            return h(Host, { style: { display: 'none' } });
        }
        const style = {
            display: 'block',
            left: `${this.changes.x}px`,
            top: `${this.changes.y}px`,
        };
        const capts = Object.assign(this.filterCaptionsInternal, this.filterCaptions);
        return (h(Host, { style: style, ref: el => {
                var _a;
                ((_a = this.changes) === null || _a === void 0 ? void 0 : _a.autoCorrect) !== false && this.autoCorrect(el);
            } }, h("slot", { slot: "header" }), ((_b = (_a = this.changes).extraContent) === null || _b === void 0 ? void 0 : _b.call(_a, this.changes)) || '', ((_c = this.changes) === null || _c === void 0 ? void 0 : _c.hideDefaultFilters) !== true && ([
            h("label", null, capts.title),
            h("div", { class: "filter-holder" }, this.getFilterItemsList()),
            h("div", { class: "add-filter" }, h("select", { id: FILTER_ID, class: "select-css", onChange: e => this.onAddNewFilter(e) }, this.renderSelectOptions(this.currentFilterType)))
        ]), h("slot", null), h("div", { class: "filter-actions" }, this.disableDynamicFiltering && [
            h("button", { id: "revo-button-save", "aria-label": "save", class: "revo-button green", onClick: () => this.onSave() }, capts.save),
            h("button", { id: "revo-button-ok", "aria-label": "ok", class: "revo-button green", onClick: () => this.onCancel() }, capts.cancel),
        ], !this.disableDynamicFiltering && [
            h("button", { id: "revo-button-ok", "aria-label": "ok", class: "revo-button green", onClick: () => this.onCancel() }, capts.ok),
            h("button", { id: "revo-button-reset", "aria-label": "reset", class: "revo-button outline", onClick: () => this.onReset() }, capts.reset),
        ]), h("slot", { slot: "footer" })));
    }
    static get is() { return "revogr-filter-panel"; }
    static get originalStyleUrls() {
        return {
            "$": ["filter.style.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["filter.style.css"]
        };
    }
    static get properties() {
        return {
            "filterNames": {
                "type": "unknown",
                "attribute": "filter-names",
                "mutable": false,
                "complexType": {
                    "original": "Record<string, string>",
                    "resolved": "{ [x: string]: string; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "filterEntities": {
                "type": "unknown",
                "attribute": "filter-entities",
                "mutable": false,
                "complexType": {
                    "original": "Record<string, LogicFunction>",
                    "resolved": "{ [x: string]: LogicFunction<any, LogicFunctionExtraParam>; }",
                    "references": {
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        },
                        "LogicFunction": {
                            "location": "import",
                            "path": "./filter.types",
                            "id": "src/plugins/filter/filter.types.ts::LogicFunction"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "filterCaptions": {
                "type": "unknown",
                "attribute": "filter-captions",
                "mutable": false,
                "complexType": {
                    "original": "Partial<FilterCaptions> | undefined",
                    "resolved": "undefined | { title?: string | undefined; save?: string | undefined; reset?: string | undefined; ok?: string | undefined; cancel?: string | undefined; add?: string | undefined; placeholder?: string | undefined; and?: string | undefined; or?: string | undefined; }",
                    "references": {
                        "Partial": {
                            "location": "global",
                            "id": "global::Partial"
                        },
                        "FilterCaptions": {
                            "location": "import",
                            "path": "./filter.types",
                            "id": "src/plugins/filter/filter.types.ts::FilterCaptions"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "getter": false,
                "setter": false
            },
            "disableDynamicFiltering": {
                "type": "boolean",
                "attribute": "disable-dynamic-filtering",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Disables dynamic filtering. A way to apply filters on Save only"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "closeOnOutsideClick": {
                "type": "boolean",
                "attribute": "close-on-outside-click",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If true, closes the filter panel when clicking outside"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "true"
            }
        };
    }
    static get states() {
        return {
            "isFilterIdSet": {},
            "filterId": {},
            "currentFilterId": {},
            "currentFilterType": {},
            "changes": {},
            "filterItems": {}
        };
    }
    static get events() {
        return [{
                "method": "filterChange",
                "name": "filterChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "MultiFilterItem",
                    "resolved": "MultiFilterItem",
                    "references": {
                        "MultiFilterItem": {
                            "location": "import",
                            "path": "./filter.types",
                            "id": "src/plugins/filter/filter.types.ts::MultiFilterItem"
                        }
                    }
                }
            }, {
                "method": "resetChange",
                "name": "resetChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "ColumnProp",
                    "resolved": "number | string",
                    "references": {
                        "ColumnProp": {
                            "location": "import",
                            "path": "@type",
                            "id": "src/types/index.ts::ColumnProp"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "show": {
                "complexType": {
                    "signature": "(newEntity?: ShowData) => Promise<void>",
                    "parameters": [{
                            "name": "newEntity",
                            "type": "ShowData | undefined",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ShowData": {
                            "location": "import",
                            "path": "./filter.types",
                            "id": "src/plugins/filter/filter.types.ts::ShowData"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getChanges": {
                "complexType": {
                    "signature": "() => Promise<ShowData | undefined>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ShowData": {
                            "location": "import",
                            "path": "./filter.types",
                            "id": "src/plugins/filter/filter.types.ts::ShowData"
                        }
                    },
                    "return": "Promise<ShowData | undefined>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "element"; }
    static get listeners() {
        return [{
                "name": "mousedown",
                "method": "onMouseDown",
                "target": "document",
                "capture": false,
                "passive": true
            }];
    }
}
//# sourceMappingURL=filter.panel.js.map
