{"version":3,"file":"grouping.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DataType, ColumnProp, ColumnRegular } from '@type';\nimport {\n  GROUP_DEPTH,\n  GROUP_EXPANDED,\n  PSEUDO_GROUP_COLUMN,\n  PSEUDO_GROUP_ITEM,\n  PSEUDO_GROUP_ITEM_ID,\n  PSEUDO_GROUP_ITEM_VALUE,\n  GROUP_ORIGINAL_INDEX,\n  GROUP_COLUMN_PROP,\n} from './grouping.const';\nimport type { ExpandedOptions, SourceGather } from './grouping.row.types';\n\n\ntype GroupedData = Map<string, GroupedData | DataType[]>;\n\nfunction getGroupValueDefault(item: DataType, prop: string | number) {\n  return item[prop] || null;\n}\n\n// get source based on proxy item collection to preserve rgRow order\nexport function getSource(\n  source: DataType[],\n  items: number[],\n  withoutGrouping = false,\n) {\n  let index = 0;\n  const result: Required<SourceGather> = {\n    source: [],\n    prevExpanded: {},\n    oldNewIndexes: {},\n  };\n  // order important here, expected parent is first, then others\n  items.forEach(i => {\n    const model = source[i];\n    if (!withoutGrouping) {\n      result.source.push(model);\n      return;\n    }\n\n    // grouping filter\n    if (isGrouping(model)) {\n      if (getExpanded(model)) {\n        result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;\n      }\n    } else {\n      result.source.push(model);\n      result.oldNewIndexes[i] = index;\n      index++;\n    }\n  });\n  return result;\n}\n\nexport function getExpanded(model: DataType = {}) {\n  return model[GROUP_EXPANDED];\n}\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param columnProps - ids of groups\n * @param expanded - potentially expanded items if present\n */\nexport function gatherGrouping(\n  array: DataType[],\n  columnProps: ColumnProp[],\n  {\n    prevExpanded,\n    expandedAll,\n    getGroupValue = getGroupValueDefault,\n  }: ExpandedOptions,\n) {\n  const groupedItems: GroupedData = new Map();\n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = columnProps.map(groupId =>\n      getGroupValue(item, groupId),\n    );\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value) as GroupedData;\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      currentGroupLevel.set(lastLevelValue, []);\n    }\n    const lastLevelItems = currentGroupLevel.get(lastLevelValue) as DataType[];\n    lastLevelItems.push({\n      ...item,\n      [GROUP_ORIGINAL_INDEX]: originalIndex,\n    });\n  });\n\n  let itemIndex = -1;\n  const groupingDepth = columnProps.length;\n  // collapse all groups in the beginning\n  const trimmed: Record<number, boolean> = {};\n  // index mapping\n  const oldNewIndexMap: Record<number, number> = {};\n  // check if group header exists\n  const pseudoGroupTest: Record<string, number[]> = {};\n  const sourceWithGroups: DataType[] = [];\n  function flattenGroupMaps(\n    groupedValues: GroupedData,\n    parentIds: string[],\n    isExpanded: boolean,\n  ) {\n    const depth = parentIds.length;\n    groupedValues.forEach((innerGroupedValues, groupId) => {\n      const levelIds = [...parentIds, groupId];\n      const mergedIds = levelIds.join(',');\n      const isGroupExpanded =\n        isExpanded && (!!expandedAll || !!prevExpanded?.[mergedIds]);\n      sourceWithGroups.push({\n        [PSEUDO_GROUP_ITEM]: groupId,\n        [GROUP_DEPTH]: depth,\n        [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n        [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n        [GROUP_EXPANDED]: isGroupExpanded,\n        [GROUP_COLUMN_PROP]: columnProps[depth],\n        [columnProps[depth]]: groupId,\n      });\n      itemIndex += 1;\n      if (!isGroupExpanded && depth) {\n        trimmed[itemIndex] = true;\n      }\n      if (Array.isArray(innerGroupedValues)) {\n        innerGroupedValues.forEach(value => {\n          itemIndex += 1;\n          if (!isGroupExpanded) {\n            trimmed[itemIndex] = true;\n          }\n          oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex;\n          const pseudoGroupTestIds = levelIds.map((_value, index) =>\n            levelIds.slice(0, index + 1).join(','),\n          );\n          pseudoGroupTestIds.forEach(pseudoGroupTestId => {\n            if (!pseudoGroupTest[pseudoGroupTestId]) {\n              pseudoGroupTest[pseudoGroupTestId] = [];\n            }\n            pseudoGroupTest[pseudoGroupTestId].push(itemIndex);\n          });\n        });\n        sourceWithGroups.push(...innerGroupedValues);\n      } else {\n        flattenGroupMaps(innerGroupedValues, levelIds, isGroupExpanded);\n      }\n    });\n  }\n  flattenGroupMaps(groupedItems, [], true);\n\n  return {\n    sourceWithGroups, // updates source mirror\n    depth: groupingDepth, // largest depth for grouping\n    trimmed, // used for expand/collapse grouping values\n    oldNewIndexMap, // used for mapping old values to new\n    childrenByGroup: pseudoGroupTest, // used to get child items in group\n  };\n}\n\nexport function getGroupingName(rgRow?: DataType) {\n  return rgRow && rgRow[PSEUDO_GROUP_ITEM];\n}\n\ntype GroupingItem = {\n  [PSEUDO_GROUP_ITEM]: string;\n  [GROUP_EXPANDED]: boolean;\n  [PSEUDO_GROUP_ITEM_VALUE]: string;\n  [GROUP_DEPTH]: number;\n  [GROUP_COLUMN_PROP]: ColumnProp;\n};\n\nexport function isGrouping(rgRow?: DataType): rgRow is GroupingItem {\n  return typeof rgRow?.[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\n\nexport function isGroupingColumn(column?: ColumnRegular) {\n  return typeof column?.[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\n\nexport function measureEqualDepth<T>(groupA: T[], groupB: T[]) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\n\nexport function getParsedGroup(id: string) {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safeguard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n\n// check if items is child of current clicked group\nexport function isSameGroup(\n  currentGroup: any[],\n  currentModel: DataType,\n  nextModel: DataType,\n) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\n"]}