{"version":3,"file":"grouping.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.service.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DataType, ColumnProp, ColumnRegular } from '@type';\nimport {\n  GROUP_DEPTH,\n  GROUP_EXPANDED,\n  PSEUDO_GROUP_COLUMN,\n  PSEUDO_GROUP_ITEM,\n  PSEUDO_GROUP_ITEM_ID,\n  PSEUDO_GROUP_ITEM_VALUE,\n  GROUP_ORIGINAL_INDEX,\n  GROUP_COLUMN_PROP,\n} from './grouping.const';\nimport type { ExpandedOptions } from './grouping.row.types';\n\ntype GroupedData = Map<string, GroupedData | DataType[]>;\ntype SourceGather = {\n  source: DataType[];\n  prevExpanded: Record<string, boolean>;\n  oldNewIndexes?: Record<number, number>;\n};\n\nfunction getGroupValueDefault(item: DataType, prop: string | number) {\n  return item[prop] || null;\n}\n\n// get source based on proxy item collection to preserve rgRow order\nexport function getSource(\n  source: DataType[],\n  items: number[],\n  withoutGrouping = false,\n) {\n  let index = 0;\n  const result: Required<SourceGather> = {\n    source: [],\n    prevExpanded: {},\n    oldNewIndexes: {},\n  };\n  // order important here, expected parent is first, then others\n  items.forEach(i => {\n    const model = source[i];\n    if (!withoutGrouping) {\n      result.source.push(model);\n      return;\n    }\n\n    // grouping filter\n    if (isGrouping(model)) {\n      if (getExpanded(model)) {\n        result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;\n      }\n    } else {\n      result.source.push(model);\n      result.oldNewIndexes[i] = index;\n      index++;\n    }\n  });\n  return result;\n}\n\nexport function getExpanded(model: DataType = {}) {\n  return model[GROUP_EXPANDED];\n}\n\nfunction flattenGroupMaps({\n  groupedValues,\n  parentIds,\n  isExpanded,\n  itemIndex,\n  expandedAll,\n  prevExpanded,\n  columnProps,\n}: {\n  groupedValues: GroupedData;\n  parentIds: string[];\n  isExpanded: boolean;\n  itemIndex: number;\n  expandedAll: boolean;\n  prevExpanded: Record<string, boolean>;\n  columnProps: ColumnProp[];\n}) {\n  const depth = parentIds.length;\n  const sourceWithGroups: DataType[] = [];\n  // collapse all groups in the beginning\n  let trimmed: Record<number, boolean> = {};\n\n  // index mapping\n  let oldNewIndexMap: Record<number, number> = {};\n\n  groupedValues.forEach((innerGroupedValues, groupId) => {\n    const levelIds = [...parentIds, groupId];\n    const mergedIds = levelIds.join(',');\n    const isGroupExpanded =\n      isExpanded && (!!expandedAll || !!prevExpanded[mergedIds]);\n    sourceWithGroups.push({\n      [PSEUDO_GROUP_ITEM]: groupId,\n      [GROUP_DEPTH]: depth,\n      [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n      [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n      [GROUP_EXPANDED]: isGroupExpanded,\n      [GROUP_COLUMN_PROP]: columnProps[depth],\n      [columnProps[depth]]: groupId,\n    });\n    itemIndex += 1;\n    // If parent group is collapsed, mark all items as hidden\n    if (!isExpanded && depth) {\n      trimmed[itemIndex] = true;\n    }\n    if (Array.isArray(innerGroupedValues)) {\n      // This branch handles leaf nodes (actual data items)\n      innerGroupedValues.forEach(value => {\n        itemIndex += 1;\n        if (!isGroupExpanded) {\n          trimmed[itemIndex] = true; // Mark items as hidden if group is collapsed\n        }\n        oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex; // Keep track of new positions\n      });\n      sourceWithGroups.push(...innerGroupedValues);\n    } else {\n      // This branch handles nested groups (further subgroups)\n      const children = flattenGroupMaps({\n        groupedValues: innerGroupedValues,\n        parentIds: levelIds,\n        isExpanded: isGroupExpanded,\n        itemIndex,\n        expandedAll,\n        prevExpanded,\n        columnProps,\n      }); // Recursively process subgroups\n      sourceWithGroups.push(...children.source);\n      trimmed = { ...children.trimmed, ...trimmed };\n      oldNewIndexMap = { ...children.oldNewIndexMap, ...oldNewIndexMap };\n      itemIndex = children.itemIndex;\n    }\n  });\n  return {\n    source: sourceWithGroups,\n    oldNewIndexMap,\n    trimmed,\n    itemIndex,\n  };\n}\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param columnProps - ids of groups\n * @param expanded - potentially expanded items if present\n */\nexport function gatherGrouping(\n  array: DataType[],\n  columnProps: ColumnProp[],\n  {\n    prevExpanded = {},\n    expandedAll = false,\n    getGroupValue = getGroupValueDefault,\n  }: ExpandedOptions,\n) {\n  const groupedItems: GroupedData = new Map();\n  \n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = columnProps.map(groupId => getGroupValue(item, groupId));\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value) as GroupedData;\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      const groupItems: DataType[] = [];\n      currentGroupLevel.set(lastLevelValue, groupItems);\n    }\n    const lastLevelItems = currentGroupLevel.get(lastLevelValue) as DataType[];\n    lastLevelItems.push({\n      ...item,\n      [GROUP_ORIGINAL_INDEX]: originalIndex,\n    });\n  });\n\n  const groupingDepth = columnProps.length;\n\n  const { source: sourceWithGroups, trimmed, oldNewIndexMap } = flattenGroupMaps({\n    groupedValues: groupedItems,\n    parentIds: [],\n    isExpanded: true,\n    itemIndex: -1,\n    expandedAll,\n    prevExpanded,\n    columnProps\n  });\n\n  return {\n    sourceWithGroups, // updates source mirror\n    depth: groupingDepth, // largest depth for grouping\n    trimmed, // used for expand/collapse grouping values\n    oldNewIndexMap, // used for mapping old values to new\n  };\n}\n\nexport function getGroupingName(rgRow?: DataType) {\n  return rgRow?.[PSEUDO_GROUP_ITEM];\n}\n\ntype GroupingItem = {\n  [PSEUDO_GROUP_ITEM]: string;\n  [GROUP_EXPANDED]: boolean;\n  [PSEUDO_GROUP_ITEM_VALUE]: string;\n  [GROUP_DEPTH]: number;\n  [GROUP_COLUMN_PROP]: ColumnProp;\n};\n\nexport function isGrouping(rgRow?: DataType): rgRow is GroupingItem {\n  return typeof rgRow?.[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\n\nexport function isGroupingColumn(column?: ColumnRegular) {\n  return typeof column?.[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\n\nexport function measureEqualDepth<T>(groupA: T[], groupB: T[]) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\n\nexport function getParsedGroup(id: string) {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safeguard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n\n// check if items is child of current clicked group\nexport function isSameGroup(\n  currentGroup: any[],\n  currentModel: DataType,\n  nextModel: DataType,\n) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\n"]}