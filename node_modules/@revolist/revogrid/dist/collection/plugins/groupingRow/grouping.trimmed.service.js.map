{"version":3,"file":"grouping.trimmed.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.trimmed.service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAA0B,MAAM,QAAQ,CAAC;AAEpE,MAAM,CAAC,MAAM,gBAAgB,GAAG,UAAU,CAAC;AAE3C;;;;;GAKG;AACH,MAAM,UAAU,8BAA8B,CAAC,eAAwB,EAAE,aAAqC,EAAE,cAAuC;IACrJ,MAAM,wBAAwB,GAAY,EAAE,CAAC;IAC7C;;OAEG;IACH,KAAK,IAAI,IAAI,IAAI,eAAe,EAAE,CAAC;QACjC,IAAI,IAAI,KAAK,gBAAgB,EAAE,CAAC;YAC9B,SAAS;QACX,CAAC;QACD,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;QACpC,MAAM,QAAQ,GAAkB,EAAE,CAAC;QAEnC,KAAK,IAAI,YAAY,IAAI,KAAK,EAAE,CAAC;YAC/B;;;eAGG;YACH,IAAI,kBAAkB,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;YACrD,IAAI,cAAc,EAAE,CAAC;gBACnB,kBAAkB,GAAG,cAAc,CAAC,kBAAkB,CAAC,CAAC;YAC1D,CAAC;YAED;;;eAGG;YACH,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC;gBACxB,QAAQ,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC;gBACpC;;mBAEG;gBACH,IAAI,kBAAkB,KAAK,QAAQ,CAAC,YAAY,EAAE,EAAE,CAAC,EAAE,CAAC;oBACtD,wBAAwB,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;gBAC5C,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,wBAAwB,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,gBAAyB,EAAE,kBAA4C,EAAE;IAC5G,MAAM,YAAY,GAAkB,EAAE,CAAC;IACvC,MAAM,UAAU,GAAG,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;IACxD,4BAA4B;IAC5B,KAAK,IAAI,UAAU,IAAI,eAAe,EAAE,CAAC;QACvC,MAAM,WAAW,GAAG,eAAe,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;QACzG,IAAI,CAAC,WAAW,EAAE,CAAC;YACjB,YAAY,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;QAClC,CAAC;IACH,CAAC;IACD,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["import { gatherTrimmedItems, Trimmed, TrimmedEntity } from '@store';\n\nexport const TRIMMED_GROUPING = 'grouping';\n\n/**\n * Prepare trimming updated indexes for grouping\n * @param initiallyTrimed\n * @param firstLevelMap\n * @param secondLevelMap\n */\nexport function processDoubleConversionTrimmed(initiallyTrimed: Trimmed, firstLevelMap: Record<number, number>, secondLevelMap?: Record<number, number>) {\n  const trimemedOptionsToUpgrade: Trimmed = {};\n  /**\n   * go through all groups except grouping\n   */\n  for (let type in initiallyTrimed) {\n    if (type === TRIMMED_GROUPING) {\n      continue;\n    }\n    const items = initiallyTrimed[type];\n    const newItems: TrimmedEntity = {};\n\n    for (let initialIndex in items) {\n      /**\n       * if item exists we find it in collection\n       * we support 2 level of conversions\n       */\n      let newConversionIndex = firstLevelMap[initialIndex];\n      if (secondLevelMap) {\n        newConversionIndex = secondLevelMap[newConversionIndex];\n      }\n\n      /**\n       * if item was trimmed previously\n       * trimming makes sense to apply\n       */\n      if (items[initialIndex]) {\n        newItems[newConversionIndex] = true;\n        /**\n         * If changes present apply changes to new source\n         */\n        if (newConversionIndex !== parseInt(initialIndex, 10)) {\n          trimemedOptionsToUpgrade[type] = newItems;\n        }\n      }\n    }\n  }\n  return trimemedOptionsToUpgrade;\n}\n\nexport function filterOutEmptyGroups(allTrimmedGroups: Trimmed, childrenByGroup: Record<number, number[]> = {}) {\n  const trimmedGroup: TrimmedEntity = {};\n  const allTrimmed = gatherTrimmedItems(allTrimmedGroups);\n  // find is groups are filled\n  for (let groupIndex in childrenByGroup) {\n    const hasChidlren = childrenByGroup[groupIndex].filter(childIndex => !allTrimmed[childIndex]).length > 0;\n    if (!hasChidlren) {\n      trimmedGroup[groupIndex] = true;\n    }\n  }\n  return trimmedGroup;\n}\n"]}