{"version":3,"file":"grouping.row.expand.service.js","sourceRoot":"","sources":["../../../src/plugins/groupingRow/grouping.row.expand.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataType } from '@type';\nimport { PSEUDO_GROUP_ITEM_ID, PSEUDO_GROUP_ITEM_VALUE, GROUP_EXPANDED, GROUP_DEPTH } from './grouping.const';\nimport { isGrouping, getParsedGroup, isSameGroup } from './grouping.service';\n\n// provide collapse data\nexport function doCollapse(pIndex: number, source: DataType[]) {\n  const model = source[pIndex];\n  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];\n  const trimmed: Record<number, boolean> = {};\n  let i = pIndex + 1;\n  const total = source.length;\n  while (i < total) {\n    const currentModel = source[i];\n    if (isGrouping(currentModel)) {\n      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];\n      if (!currentValue.length || !currentValue.startsWith(collapseValue + ',')) {\n        break;\n      }\n      currentModel[GROUP_EXPANDED] = false;\n    }\n    trimmed[i++] = true;\n  }\n  model[GROUP_EXPANDED] = false;\n  return { trimmed };\n}\n\n/**\n *\n * @param pIndex - physical index\n * @param vIndex - virtual index, need to update item collection\n * @param source - data source\n * @param rowItemsIndexes - rgRow indexes\n */\nexport function doExpand(vIndex: number, source: DataType[], rowItemsIndexes: number[]) {\n  const physicalIndex = rowItemsIndexes[vIndex];\n  const model = source[physicalIndex];\n  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);\n  const trimmed: Record<number, boolean> = {};\n\n  // no group found\n  if (!currentGroup) {\n    return { trimmed };\n  }\n\n  const groupItems: number[] = [];\n  model[GROUP_EXPANDED] = true;\n  let i = physicalIndex + 1;\n  const total = source.length;\n  let groupLevelOnly = 0;\n\n  // go through all rows\n  while (i < total) {\n    const currentModel = source[i];\n    const isGroup = isGrouping(currentModel);\n    // group found\n    if (isGroup) {\n      if (!isSameGroup(currentGroup, model, currentModel)) {\n        break;\n      } else if (!groupLevelOnly) {\n        // if get group first it's group only level\n        groupLevelOnly = currentModel[GROUP_DEPTH];\n      }\n    }\n    // level 0 or same depth\n    if (!groupLevelOnly || (isGroup && groupLevelOnly === currentModel[GROUP_DEPTH])) {\n      trimmed[i] = false;\n      groupItems.push(i);\n    }\n    i++;\n  }\n  const result: {\n    trimmed: Record<number, boolean>;\n    items?: number[];\n  } = {\n    trimmed,\n  };\n  if (groupItems.length) {\n    const items = [...rowItemsIndexes];\n    items.splice(vIndex + 1, 0, ...groupItems);\n    result.items = items;\n  }\n  return result;\n}\n"]}