{"version":3,"file":"sorting.func.js","sourceRoot":"","sources":["../../../src/plugins/sorting/sorting.func.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,UAAU,EAAE,MAAM,iCAAiC,CAAC;AAE7D,MAAM,UAAU,gBAAgB,CAC9B,OAAiB,EACjB,MAAkB,EAClB,cAAoC,EAAE;IAEtC,0CAA0C;IAC1C,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC7C,mBAAmB;QACnB,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3C,CAAC;IACD,EAAE;IACF;;;OAGG;IACH,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;QAC3B,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACxB,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACxB,KAAK,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;YACtD,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;gBACtB,IAAI,KAAK,CAAC,aAAa,CAAC,KAAK,IAAI,EAAE,CAAC;oBAClC,OAAO,CAAC,CAAC;gBACX,CAAC;YACH,CAAC;YACD,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;gBACtB,IAAI,KAAK,CAAC,aAAa,CAAC,KAAK,IAAI,EAAE,CAAC;oBAClC,OAAO,CAAC,CAAC;gBACX,CAAC;YACH,CAAC;YACD;;;eAGG;YACH,MAAM,MAAM,GAAG,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAG,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACzC,IAAI,MAAM,EAAE,CAAC;gBACX,OAAO,MAAM,CAAC;YAChB,CAAC;QACH,CAAC;QACD,OAAO,CAAC,CAAC;IACX,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { DataType } from '@type';\nimport type { SortingOrderFunction } from './sorting.types';\nimport { isGrouping } from '../groupingRow/grouping.service';\n\nexport function sortIndexByItems(\n  indexes: number[],\n  source: DataType[],\n  sortingFunc: SortingOrderFunction = {},\n): number[] {\n  // if no sorting - return unsorted indexes\n  if (Object.entries(sortingFunc).length === 0) {\n    // Unsorted indexes\n    return [...Array(indexes.length).keys()];\n  }\n  //\n  /**\n   * go through all indexes and align in new order\n   * performs a multi-level sorting by applying multiple comparison functions to determine the order of the items based on different properties.\n   */\n  return indexes.sort((a, b) => {\n    const itemA = source[a];\n    const itemB = source[b];\n    for (const [prop, cmp] of Object.entries(sortingFunc)) {\n      if (isGrouping(itemA)) {\n        if (itemA['__rvgr-prop'] !== prop) {\n          return 0;\n        }\n      }\n      if (isGrouping(itemB)) {\n        if (itemB['__rvgr-prop'] !== prop) {\n          return 0;\n        }\n      }\n      /**\n       * If the comparison function returns a non-zero value (sorted), it means that the items should be sorted based on the given property. In such a case, the function immediately returns the sorted value, indicating the order in which the items should be arranged.\n       * If none of the comparison functions result in a non-zero value, indicating that the items are equal or should remain in the same order, the function eventually returns 0.\n       */\n      const sorted = cmp?.(prop, itemA, itemB);\n      if (sorted) {\n        return sorted;\n      }\n    }\n    return 0;\n  });\n}\n"]}