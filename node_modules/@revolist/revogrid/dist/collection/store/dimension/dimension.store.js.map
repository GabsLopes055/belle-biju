{"version":3,"file":"dimension.store.js","sourceRoot":"","sources":["../../../src/store/dimension/dimension.store.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Storing pre-calculated\n * Dimension information and sizes\n */\nimport reduce from 'lodash/reduce';\nimport { createStore } from '@stencil/store';\n\nimport { setStore, Observable } from '../../utils';\nimport { calculateDimensionData } from './dimension.helpers';\nimport {\n  DimensionCalc,\n  DimensionSettingsState,\n  ViewSettingSizeProp,\n  MultiDimensionType,\n} from '@type';\nimport { recalculateRealSizePlugin } from './dimension.recalculate.plugin';\nimport { trimmedPlugin } from './dimension.trim.plugin';\n\nexport type DimensionStoreCollection = {\n  [T in MultiDimensionType]: DimensionStore;\n};\n\ntype Item = keyof DimensionSettingsState;\n\nfunction initialBase(): DimensionCalc {\n  return {\n    indexes: [],\n    count: 0,\n\n    // hidden items\n    trimmed: null,\n\n    // virtual item index to size\n    sizes: {},\n    // order in indexes[] to coordinate\n    positionIndexToItem: {},\n    // initial element to coordinate ^\n    indexToItem: {},\n    positionIndexes: [],\n  };\n}\n\nfunction initialState(): DimensionSettingsState {\n  return {\n    ...initialBase(),\n    // size which all items can take\n    realSize: 0,\n\n    // initial item size if it wasn't changed\n    originItemSize: 0,\n  };\n}\n\nexport class DimensionStore {\n  readonly store: Observable<DimensionSettingsState>;\n  constructor(public readonly type: MultiDimensionType) {\n    this.store = createStore(initialState());\n    this.store.use(trimmedPlugin({\n      store: this.store,\n      setSizes: this.setDimensionSize.bind(this),\n    }));\n    this.store.use(recalculateRealSizePlugin({\n      store: this.store,\n      setStore: this.setStore.bind(this),\n    }));\n  }\n\n  getCurrentState(): DimensionSettingsState {\n    const state = initialState();\n    const keys = Object.keys(state);\n    return reduce(\n      keys,\n      (r: DimensionSettingsState, k: Item) => {\n        const data = this.store.get(k);\n        r[k] = data as never;\n        return r;\n      },\n      state,\n    );\n  }\n\n  dispose() {\n    setStore(this.store, initialState());\n  }\n\n  setStore<T extends Record<string, any>>(data: Partial<T>) {\n    setStore(this.store, data);\n  }\n\n  drop() {\n    setStore(this.store, initialBase());\n  }\n\n  /**\n   * Set custom dimension sizes and overwrite old\n   * Generates new indexes based on sizes\n   * @param sizes - sizes to set\n   */\n  setDimensionSize(sizes: ViewSettingSizeProp = {}) {\n    const dimensionData = calculateDimensionData(\n      this.store.get('originItemSize'),\n      sizes,\n    );\n    setStore(this.store, {\n      ...dimensionData,\n      sizes,\n    });\n  }\n\n  updateSizesPositionByIndexes(newItemsOrder: number[], prevItemsOrder: number[] = []) {\n    // Move custom sizes to new order\n    const customSizes = {...this.store.get('sizes')};\n    if (!Object.keys(customSizes).length) {\n      return;\n    }\n    // Step 1: Create a map of original indices, but allow duplicates by storing arrays of indices\n    const originalIndices: Record<number, number[]> = {};\n    prevItemsOrder.forEach((physIndex, virtIndex) => {\n      if (!originalIndices[physIndex]) {\n        originalIndices[physIndex] = [];\n      }\n      originalIndices[physIndex].push(virtIndex); // Store all indices for each value\n    });\n\n    // Step 2: Create new sizes based on new item order\n    const newSizes: Record<number, number> = {};\n\n    newItemsOrder.forEach((physIndex, virtIndex) => {\n      const indices = originalIndices[physIndex]; // Get all original indices for this value\n      \n      if (indices && indices.length > 0) {\n        const originalIndex = indices.shift(); // Get the first available original index\n\n        if (originalIndex !== undefined && originalIndex !== virtIndex && customSizes[originalIndex]) {\n          newSizes[virtIndex] = customSizes[originalIndex];\n          delete customSizes[originalIndex];\n        }\n      }\n    });\n\n    // Step 3: Set new sizes if there are changes\n    if (Object.keys(newSizes).length) {\n      this.setDimensionSize({\n        ...customSizes,\n        ...newSizes,\n      });\n    }\n  }\n}\n"]}