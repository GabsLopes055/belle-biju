{"version":3,"file":"dimension.helpers.js","sourceRoot":"","sources":["../../../src/store/dimension/dimension.helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import sortedIndex from 'lodash/sortedIndex';\n\nimport type {\n  DimensionSettingsState,\n  PositionItem,\n  ViewSettingSizeProp,\n} from '@type';\n\nexport type DimensionPosition = Pick<\n  DimensionSettingsState,\n  'indexes' | 'positionIndexes' | 'originItemSize' | 'positionIndexToItem'\n>;\nexport type DimensionIndexInput = Pick<\n  DimensionSettingsState,\n  'indexes' | 'originItemSize' | 'indexToItem'\n>;\nexport type DimensionSize = Pick<\n  DimensionSettingsState,\n  | 'indexes'\n  | 'positionIndexes'\n  | 'positionIndexToItem'\n  | 'indexToItem'\n  | 'realSize'\n  | 'sizes'\n>;\n/**\n * Pre-calculation\n * Dimension custom sizes for each cell\n * Keeps only changed sizes, skips origin size\n */\nexport function calculateDimensionData(\n  originItemSize: number,\n  newSizes: ViewSettingSizeProp = {},\n) {\n  const positionIndexes: number[] = [];\n  const positionIndexToItem: { [position: number]: PositionItem } = {};\n  const indexToItem: { [index: number]: PositionItem } = {};\n\n  // prepare order sorted new sizes and calculate changed real size\n  const newIndexes = Object.keys(newSizes).map(Number).sort((a, b) => a - b);\n  let previous: PositionItem | undefined;\n  for (let i = 0; i < newIndexes.length; i++) {\n    const itemIndex = newIndexes[i];\n    const newItem: PositionItem = {\n      itemIndex,\n      start: 0,\n      end: 0,\n    };\n    // if previous item was changed too\n    if (previous) {\n      const itemsBetween =\n        (itemIndex - previous.itemIndex - 1) * originItemSize;\n      newItem.start = itemsBetween + previous.end;\n    } else {\n      newItem.start = itemIndex * originItemSize;\n    }\n    newItem.end = newItem.start + newSizes[itemIndex];\n    positionIndexes.push(newItem.start);\n    indexToItem[itemIndex] = positionIndexToItem[i] = newItem;\n    previous = newItem;\n  }\n  return {\n    indexes: newIndexes,\n    positionIndexes: [...positionIndexes],\n    positionIndexToItem: { ...positionIndexToItem },\n    indexToItem,\n  };\n}\n\n/**\n * Calculate item by position\n */\nexport const getItemByPosition = (\n  {\n    indexes,\n    positionIndexes,\n    originItemSize,\n    positionIndexToItem,\n  }: Pick<DimensionPosition, 'indexes' | 'positionIndexes' | 'originItemSize' | 'positionIndexToItem'>,\n  pos: number,\n) => {\n  const item: PositionItem = {\n    itemIndex: 0,\n    start: 0,\n    end: 0,\n  };\n  const currentPlace = indexes.length ? sortedIndex(positionIndexes, pos) : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.itemIndex = Math.floor(pos / originItemSize);\n    item.start = item.itemIndex * originItemSize;\n    item.end = item.start + originItemSize;\n    return item;\n  }\n  const positionItem = positionIndexToItem[currentPlace - 1];\n  // if item has specified size\n  if (positionItem.end > pos) {\n    return positionItem;\n  }\n  // special size item was present before\n  const relativePos = pos - positionItem.end;\n  const relativeIndex = Math.floor(relativePos / originItemSize);\n  item.itemIndex = positionItem.itemIndex + 1 + relativeIndex;\n  item.start = positionItem.end + relativeIndex * originItemSize;\n  item.end = item.start + originItemSize;\n  return item;\n};\n\nexport function getItemByIndex(\n  dimension: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n  index: number,\n) {\n  let item: PositionItem = {\n    itemIndex: index,\n    start: 0,\n    end: 0,\n  };\n  // if item has specified size\n  if (dimension.indexToItem[index]) {\n    return dimension.indexToItem[index];\n  }\n\n  const currentPlace = dimension.indexes.length\n    ? sortedIndex(dimension.indexes, index)\n    : 0;\n  // not found or first index\n  if (!currentPlace) {\n    item.start = item.itemIndex * dimension.originItemSize;\n    item.end = item.start + dimension.originItemSize;\n    return item;\n  }\n  // special size item was present before\n  const positionItem =\n    dimension.indexToItem[dimension.indexes[currentPlace - 1]];\n  item.start =\n    positionItem.end +\n    (index - positionItem.itemIndex - 1) * dimension.originItemSize;\n  item.end = item.start + dimension.originItemSize;\n  return item;\n}\n"]}