{"version":3,"file":"data.proxy.js","sourceRoot":"","sources":["../../../src/store/dataSource/data.proxy.ts"],"names":[],"mappings":"AAKA;;;GAGG;AAEH;;;;GAIG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,KAAwB,EAA0B,EAAE,CAAC,CAAC;IAChF;;;;;;OAMG;IACH,GAAG,CAAC,CAAC,EAAE,MAAM;QACX,IAAI,CAAC,KAAK,YAAY,EAAE,CAAC;YACvB,OAAO;QACT,CAAC;QACD;;;WAGG;QACH,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAS,EAAE,EAAE;YAC1D,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACT,OAAO,CAAC,CAAC;QACX,CAAC,EAAE,IAAI,GAAG,EAAU,CAAC,CAAC;QACtB;;WAEG;QACH,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAW,EAAE,CAAS,EAAE,EAAE;YACxD,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;gBACpB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;YACD,OAAO,CAAC,CAAC;QACX,CAAC,EAAE,EAAE,CAAC,CAAC;QACP,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC/B,CAAC;CACF,CAAC,CAAC","sourcesContent":["import { DSourceState } from '@store';\nimport type { Observable, PluginSubscribe } from '../../utils';\n\ntype State = DSourceState<any, any>;\n\n/**\n * Todo:\n * Refactor proxy plugin: when items changed outside proxy get recalculated\n */\n\n/**\n * Proxy plugin for data source.\n * \n * This plugin is used keep sortint in the data source, even when trimming is applied sorting has to be preserved.\n */\nexport const proxyPlugin = (store: Observable<State>): PluginSubscribe<State> => ({\n  /**\n   * Set the value of a property in the store.\n   * If the key is 'proxyItems' it will filter the items in the data source according to the new value.\n   * The new value should be an array of numbers representing the indexes of the items that should be visible.\n   * The method will return a new array of numbers with the indexes of the items that should be visible.\n   * The method will also update the 'items' property of the store with the new array.\n   */\n  set(k, newVal) {\n    if (k !== 'proxyItems') {\n      return;\n    }\n    /**\n     * Getting existing collection of items (trimmed and filtered)\n     * Mark indexes as visible\n     */\n    const oldItems = store.get('items').reduce((r, v: number) => {\n      r.add(v);\n      return r;\n    }, new Set<number>());\n    /**\n     * Check if new values where present in items, keep filtering and trimming\n     */\n    const newItems = newVal.reduce((r: number[], i: number) => {\n      if (oldItems.has(i)) {\n        r.push(i);\n      }\n      return r;\n    }, []);\n    store.set('items', newItems);\n  },\n});\n"]}