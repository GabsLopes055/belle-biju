{"version":3,"file":"viewport.store.js","sourceRoot":"","sources":["../../../src/store/vp/viewport.store.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DimensionDataViewport,\n  addMissingItems,\n  getFirstItem,\n  getLastItem,\n  getUpdatedItemsByPosition,\n  isActiveRange,\n  setItemSizes,\n  updateMissingAndRange,\n  isActiveRangeOutsideLastItem,\n  ItemsToUpdate,\n} from './viewport.helpers';\nimport { createStore } from '@stencil/store';\nimport { type Observable, setStore } from '../../utils';\nimport type {\n  VirtualPositionItem,\n  ViewportState,\n  MultiDimensionType,\n} from '@type';\n\n/**\n * Viewport store\n * Used for virtualization (process of rendering only visible part of data)\n * Redraws viewport based on position and dimension\n */\nfunction initialState(): ViewportState {\n  return {\n    // virtual item information per rendered item\n    items: [],\n    // virtual dom item order to render\n    start: 0,\n    end: 0,\n\n    // size of virtual viewport in px\n    virtualSize: 0,\n\n    // total number of items\n    realCount: 0,\n\n    // size of viewport in px\n    clientSize: 0,\n  };\n}\n\n/**\n * Viewport store class\n */\nexport class ViewportStore {\n  readonly store: Observable<ViewportState>;\n\n  // last coordinate for store position restore\n  private lastKnownScroll = 0;\n\n  get lastCoordinate() {\n    return this.lastKnownScroll;\n  }\n  set lastCoordinate(value: number) {\n    this.lastKnownScroll = value;\n  }\n  constructor(readonly type: MultiDimensionType) {\n    this.store = createStore(initialState());\n  }\n\n  /**\n   * Render viewport based on coordinate\n   * It's the main method for draw\n   * Use force if you want to re-render viewport\n   */\n  setViewPortCoordinate(\n    position: number,\n    dimension: DimensionDataViewport,\n    force = false,\n  ) {\n    const viewportSize = this.store.get('virtualSize');\n    // no visible data to calculate\n    if (!viewportSize) {\n      return;\n    }\n\n    const frameOffset = 1;\n    const singleOffsetInPx = dimension.originItemSize * frameOffset;\n    // add offset to virtual size from both sides\n    const outsize = singleOffsetInPx * 2;\n    // math virtual size is based on visible area + 2 items outside of visible area\n    const virtualSize = viewportSize + outsize;\n\n    // expected no scroll if real size less than virtual size, position is 0\n    let maxCoordinate = 0;\n    // if there is nodes outside of viewport, max coordinate has to be adjusted\n    if (dimension.realSize > viewportSize) {\n      // max coordinate is real size minus virtual/rendered space\n      maxCoordinate = dimension.realSize - viewportSize - singleOffsetInPx;\n    }\n\n    let pos = position;\n    // limit position to max and min coordinates\n    if (pos < 0) {\n      pos = 0;\n    } else if (pos > maxCoordinate) {\n      pos = maxCoordinate;\n    }\n\n    // store last coordinate for further restore on redraw\n    this.lastCoordinate = pos;\n\n    // actual position is less than first item start based on offset\n    pos -= singleOffsetInPx;\n    pos = pos < 0 ? 0 : pos < maxCoordinate ? pos : maxCoordinate;\n\n    let allItems: ItemsToUpdate;\n    // if force clear all items and start from 0\n    if (force) {\n      allItems = {\n        items: [],\n        start: 0,\n        end: 0,\n      };\n    } else {\n      allItems = this.getItems();\n    }\n\n    const firstItem: VirtualPositionItem | undefined = getFirstItem(allItems);\n    const lastItem: VirtualPositionItem | undefined = getLastItem(allItems);\n\n    let toUpdate: Partial<ViewportState> = {};\n\n    // left position changed\n    // verify if new position is in range of previously rendered first item\n    if (!isActiveRange(pos, dimension.realSize, firstItem, lastItem)) {\n      toUpdate = {\n        ...toUpdate,\n        ...getUpdatedItemsByPosition(\n          pos,\n          allItems,\n          this.store.get('realCount'),\n          virtualSize,\n          dimension,\n        ),\n      };\n      this.setViewport({ ...toUpdate });\n      // verify is render area is outside of last item\n    } else if (\n      isActiveRangeOutsideLastItem(pos, virtualSize, firstItem, lastItem)\n    ) {\n      const items = [...allItems.items];\n      // check is any item missing for fulfill content\n      const missing = addMissingItems(\n        firstItem,\n        this.store.get('realCount'),\n        virtualSize + pos - firstItem.start,\n        allItems,\n        {\n          sizes: dimension.sizes,\n          originItemSize: dimension.originItemSize,\n        },\n      );\n\n      // update missing items\n      if (missing.length) {\n        const range = {\n          start: this.store.get('start'),\n          end: this.store.get('end'),\n        };\n        updateMissingAndRange(items, missing, range);\n        toUpdate = {\n          ...toUpdate,\n          items: [...items],\n          ...range,\n        };\n        this.setViewport({ ...toUpdate });\n      }\n    }\n  }\n\n  /**\n   * Set sizes for existing items\n   */\n  setOriginalSizes(size: number) {\n    const items = this.store.get('items');\n    const count = items.length;\n    // viewport not inited\n    if (!count) {\n      return;\n    }\n\n    setStore(this.store, {\n      items: setItemSizes(\n        items,\n        this.store.get('start'),\n        size,\n        this.lastCoordinate,\n      ),\n    });\n  }\n\n  getItems(): ItemsToUpdate {\n    return {\n      items: this.store.get('items'),\n      start: this.store.get('start'),\n      end: this.store.get('end'),\n    };\n  }\n\n  setViewport(data: Partial<ViewportState>) {\n    // drop items on virtual size change, require a new item set\n    // drop items on real size change, require a new item set\n    if (typeof data.realCount === 'number' || typeof data.virtualSize === 'number') {\n      data = { ...data, items: data.items || [] };\n    }\n    setStore(this.store, data);\n  }\n}\n"]}