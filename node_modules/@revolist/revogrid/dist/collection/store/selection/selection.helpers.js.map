{"version":3,"file":"selection.helpers.js","sourceRoot":"","sources":["../../../src/store/selection/selection.helpers.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,0CAA0C,CAAC;AAGvE,MAAM,UAAU,aAAa,CAAC,GAAW;IACvC,OAAO,GAAG,KAAK,WAAW,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,IAAU,EAAE,QAAc;IACjD,MAAM,QAAQ,GAAkB,EAAE,CAAC;IACnC,IAAI,KAAK,GAAmB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAEvC,sBAAsB;IACtB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;YAChB,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,OAAO,QAAQ,CAAC;QAClB,CAAC;IACH,CAAC;IACD,kBAAkB;IAClB,KAAK,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;YAC3B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpC,OAAO,QAAQ,CAAC;QAClB,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,IAAU,EAAE,QAAc;IACtD,MAAM,WAAW,qBAAc,IAAI,CAAE,CAAC;IACtC,MAAM,eAAe,GAAmB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAEnD,KAAK,MAAM,UAAU,IAAI,eAAe,EAAE,CAAC;QACzC,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;YACzB,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QAC9B,CAAC;aAAM,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;YACpD,WAAW,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QACrD,CAAC;IACH,CAAC;IAED,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,KAAmB,EAAE,GAAiB;IAC7D,OAAO,KAAK,IAAI,GAAG;QACjB,CAAC,CAAC;YACE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YAC3B,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YAC3B,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YAC5B,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;SAC7B;QACH,CAAC,CAAC,IAAI,CAAC;AACX,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,CAAY;IAC5C,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;AACtC,CAAC","sourcesContent":["import { EMPTY_INDEX } from '../../services/selection.store.connector';\nimport { Cell, RangeArea } from '@type';\n\nexport function isHiddenStore(pos: number) {\n  return pos === EMPTY_INDEX;\n}\n\nexport function nextCell(cell: Cell, lastCell: Cell): Partial<Cell> | null {\n  const nextItem: Partial<Cell> = {};\n  let types: (keyof Cell)[] = ['x', 'y'];\n\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      nextItem[t] = cell[t];\n      return nextItem;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      nextItem[t] = cell[t] - lastCell[t];\n      return nextItem;\n    }\n  }\n  return null;\n}\n\nexport function cropCellToMax(cell: Cell, lastCell: Cell): Cell {\n  const croppedCell: Cell = { ...cell };\n  const cellCoordinates: (keyof Cell)[] = ['x', 'y'];\n\n  for (const coordinate of cellCoordinates) {\n    if (cell[coordinate] < 0) {\n      croppedCell[coordinate] = 0;\n    } else if (cell[coordinate] >= lastCell[coordinate]) {\n      croppedCell[coordinate] = lastCell[coordinate] - 1;\n    }\n  }\n\n  return croppedCell;\n}\n\nexport function getRange(start?: Cell | null, end?: Cell | null): RangeArea | null {\n  return start && end\n    ? {\n        x: Math.min(start.x, end.x),\n        y: Math.min(start.y, end.y),\n        x1: Math.max(start.x, end.x),\n        y1: Math.max(start.y, end.y),\n      }\n    : null;\n}\n\nexport function isRangeSingleCell(a: RangeArea): boolean {\n  return a.x === a.x1 && a.y === a.y1;\n}\n"]}