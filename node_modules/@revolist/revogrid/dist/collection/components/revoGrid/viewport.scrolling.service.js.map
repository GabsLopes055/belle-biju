{"version":3,"file":"viewport.scrolling.service.js","sourceRoot":"","sources":["../../../src/components/revoGrid/viewport.scrolling.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { columnTypes } from '@store';\nimport {\n  DimensionColPin,\n  ViewPortScrollEvent,\n  ElementsScroll,\n  ElementScroll,\n} from '@type';\n\nexport default class GridScrollingService {\n  private elements: ElementsScroll = {};\n  constructor(private setViewport: (e: ViewPortScrollEvent) => void) {}\n\n  async proxyScroll(e: ViewPortScrollEvent, key?: DimensionColPin | string) {\n    let newEventPromise: Promise<ViewPortScrollEvent | undefined> | undefined;\n    let event = e;\n    for (let elKey in this.elements) {\n      // skip\n      if (e.dimension === 'rgCol' && elKey === 'headerRow') {\n        continue;\n        // pinned column only\n      } else if (this.isPinnedColumn(key) && e.dimension === 'rgCol') {\n        if (elKey === key || !e.delta) {\n          continue;\n        }\n        for (let el of this.elements[elKey]) {\n          if (el.changeScroll) {\n            newEventPromise = el.changeScroll(e);\n          }\n        }\n      } else {\n        for (let el of this.elements[elKey]) {\n          await el.setScroll?.(e);\n        }\n      }\n    }\n    const newEvent = await newEventPromise;\n    if (newEvent) {\n      event = newEvent;\n    }\n    this.setViewport(event);\n  }\n\n  /**\n   * Silent scroll update for mobile devices when we have negative scroll top\n   */\n  async scrollSilentService(\n    e: ViewPortScrollEvent,\n    key?: DimensionColPin | string,\n  ) {\n    for (let elKey in this.elements) {\n      // skip same element update\n      if (elKey === key) {\n        continue;\n      }\n      if (\n        columnTypes.includes(key as DimensionColPin) &&\n        (elKey === 'headerRow' ||\n          columnTypes.includes(elKey as DimensionColPin))\n      ) {\n        for (let el of this.elements[elKey]) {\n          await el.changeScroll?.(e, true);\n        }\n        continue;\n      }\n    }\n  }\n\n  private isPinnedColumn(\n    key?: DimensionColPin | string,\n  ): key is DimensionColPin {\n    return !!key && ['colPinStart', 'colPinEnd'].indexOf(key) > -1;\n  }\n\n  registerElements(els: ElementsScroll) {\n    this.elements = els;\n  }\n\n  /**\n   * Register new element for farther scroll support\n   * @param el - can be null if holder removed\n   * @param key - element key\n   */\n  registerElement(el: ElementScroll | null | undefined, key: string) {\n    if (!this.elements[key]) {\n      this.elements[key] = [];\n    }\n    // new element added\n    if (el) {\n      this.elements[key].push(el);\n    } else if (this.elements[key]) {\n      // element removed\n      delete this.elements[key];\n    }\n  }\n\n  unregister() {\n    this.elements = {};\n  }\n}\n"]}