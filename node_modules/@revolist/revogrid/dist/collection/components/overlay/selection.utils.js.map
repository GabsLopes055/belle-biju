{"version":3,"file":"selection.utils.js","sourceRoot":"","sources":["../../../src/components/overlay/selection.utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DimensionIndexInput,\n  DSourceState,\n  getItemByIndex,\n  getItemByPosition,\n  getSourceItem,\n} from '@store';\nimport type {\n  DimensionSettingsState,\n  Cell,\n  RangeArea,\n  RangeAreaCss,\n  DataLookup,\n  DimensionRows,\n  DataType,\n  EditCellStore,\n} from '@type';\nimport { getPropertyFromEvent } from '../../utils/events';\nimport { Observable } from '../../utils';\n\nexport type EventData = {\n  el: HTMLElement;\n  rows: DimensionSettingsState;\n  cols: DimensionSettingsState;\n  lastCell: Cell;\n  focus: Cell | null;\n  range: RangeArea | null;\n  edit: EditCellStore | null;\n};\n\nexport function collectModelsOfRange(\n  data: DataLookup,\n  store: Observable<DSourceState<DataType, DimensionRows>>,\n) {\n  const models: Partial<DataLookup> = {};\n  for (let i in data) {\n    const rowIndex = parseInt(i, 10);\n    models[rowIndex] = getSourceItem(store, rowIndex);\n  }\n\n  return models;\n}\n\nexport function getFocusCellBasedOnEvent(\n  e: MouseEvent | TouchEvent,\n  data: EventData,\n): Cell | null {\n  // If event default is prevented, return\n  if (e.defaultPrevented) {\n    return null;\n  }\n\n  // Get coordinates from event object\n  const x = getPropertyFromEvent(e, 'clientX');\n  const y = getPropertyFromEvent(e, 'clientY');\n\n  // If coordinates are not available, return\n  if (x === null || y === null) {\n    return null;\n  }\n\n  // Get current cell based on coordinates and data\n  const focusCell = getCurrentCell({ x, y }, data);\n  // If current cell is not available, return\n  if (isAfterLast(focusCell, data.lastCell)) {\n    return null;\n  }\n\n  return focusCell;\n}\n\n/**\n * Calculate cell based on x, y position\n */\nexport function getCurrentCell(\n  { x, y }: Cell,\n  { el, rows, cols }: Pick<EventData, 'el' | 'rows' | 'cols'>,\n): Cell {\n  // Get the bounding rectangle of the element\n  const { top, left, height, width } = el.getBoundingClientRect();\n\n  // Calculate the cell position relative to the element\n  let cellY = y - top;\n  let cellX = x - left;\n\n  // Limit the cell position to the element height\n  if (cellY >= height) {\n    cellY = height - 1;\n  }\n\n  // Limit the cell position to the element width\n  if (cellX >= width) {\n    cellX = width - 1;\n  }\n\n  // Get the row and column items based on the cell position\n  const rgRow = getItemByPosition(rows, cellY);\n  const rgCol = getItemByPosition(cols, cellX);\n\n  // Set the row and column index to 0 if they are before the first item\n  if (rgCol.itemIndex < 0) {\n    rgCol.itemIndex = 0;\n  }\n\n  if (rgRow.itemIndex < 0) {\n    rgRow.itemIndex = 0;\n  }\n\n  return { x: rgCol.itemIndex, y: rgRow.itemIndex };\n}\n\nexport function getCoordinate(\n  range: RangeArea,\n  focus: Cell,\n  changes: Partial<Cell>,\n  isMulti = false,\n) {\n  const updateCoordinate = (c: keyof Cell, pos = 0) => {\n    const start = { x: range.x, y: range.y };\n    const end = isMulti ? { x: range.x1, y: range.y1 } : start;\n    const point = end[c] > focus[c] ? end : start;\n    point[c] += pos;\n    return { start, end };\n  };\n\n  if (changes.x) {\n    return updateCoordinate('x', changes['x']);\n  }\n  if (changes.y) {\n    return updateCoordinate('y', changes['y']);\n  }\n  return null;\n}\n\n/**\n * Check if the x coordinate of the cell position is after or equal to the x coordinate of the last cell position\n * or if the y coordinate of the cell position is after or equal to the y coordinate of the last cell position\n */\nexport function isAfterLast({ x, y }: Cell, lastCell: Cell) {\n  return x >= lastCell.x || y >= lastCell.y;\n}\n\n/** check if out of range */\nexport function isBeforeFirst({ x, y }: Cell) {\n  return x < 0 || y < 0;\n}\n\n/** Compare cells, only 1 coordinate difference is possible */\n// export function getDirectionCoordinate(initial: Cell, last: Cell): Partial<Cell> | null {\n//   const c: (keyof Cell)[] = ['x', 'y'];\n//   for (let k of c) {\n//     if (initial[k] !== last[k]) {\n//       return { [k]: 1 };\n//     }\n//   }\n//   return null;\n// }\n\n// export function getLargestAxis(initial: Cell, last: Cell): Partial<Cell> | null {\n//   const cell: Partial<Cell> = {};\n//   const c: (keyof Cell)[] = ['x', 'y'];\n//   for (let k of c) {\n//     cell[k] = Math.abs(initial[k] - last[k]);\n//   }\n//   if (cell.x > cell.y) {\n//     return { x: 1 };\n//   }\n//   if (cell.y > cell.x) {\n//     return { y: 1 };\n//   }\n//   return null;\n// }\n\nexport function styleByCellProps(styles: { [key: string]: number }): RangeAreaCss {\n  return {\n    left: `${styles.left}px`,\n    top: `${styles.top}px`,\n    width: `${styles.width}px`,\n    height: `${styles.height}px`,\n  };\n}\n\nexport function getCell(\n  { x, y, x1, y1 }: RangeArea,\n  dimensionRow: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n  dimensionCol: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n) {\n  const top = getItemByIndex(dimensionRow, y).start;\n  const left = getItemByIndex(dimensionCol, x).start;\n  const bottom = getItemByIndex(dimensionRow, y1).end;\n  const right = getItemByIndex(dimensionCol, x1).end;\n\n  return {\n    left,\n    right,\n    top,\n    bottom,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n"]}