import type { DataType, ColumnProp, ColumnRegular } from "../../types/index";
import { GROUP_DEPTH, GROUP_EXPANDED, PSEUDO_GROUP_ITEM, PSEUDO_GROUP_ITEM_VALUE, GROUP_COLUMN_PROP } from './grouping.const';
import type { ExpandedOptions, SourceGather } from './grouping.row.types';
export declare function getSource(source: DataType[], items: number[], withoutGrouping?: boolean): Required<SourceGather>;
export declare function getExpanded(model?: DataType): any;
/**
 * Gather data for grouping
 * @param array - flat data array
 * @param columnProps - ids of groups
 * @param expanded - potentially expanded items if present
 */
export declare function gatherGrouping(array: DataType[], columnProps: ColumnProp[], { prevExpanded, expandedAll, getGroupValue, }: ExpandedOptions): {
    sourceWithGroups: DataType[];
    depth: number;
    trimmed: Record<number, boolean>;
    oldNewIndexMap: Record<number, number>;
    childrenByGroup: Record<string, number[]>;
};
export declare function getGroupingName(rgRow?: DataType): any;
type GroupingItem = {
    [PSEUDO_GROUP_ITEM]: string;
    [GROUP_EXPANDED]: boolean;
    [PSEUDO_GROUP_ITEM_VALUE]: string;
    [GROUP_DEPTH]: number;
    [GROUP_COLUMN_PROP]: ColumnProp;
};
export declare function isGrouping(rgRow?: DataType): rgRow is GroupingItem;
export declare function isGroupingColumn(column?: ColumnRegular): boolean;
export declare function measureEqualDepth<T>(groupA: T[], groupB: T[]): number;
export declare function getParsedGroup(id: string): any[] | null;
export declare function isSameGroup(currentGroup: any[], currentModel: DataType, nextModel: DataType): boolean;
export {};
