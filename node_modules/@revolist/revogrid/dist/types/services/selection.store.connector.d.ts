import { SelectionStore } from "../store/index";
import type { MultiDimensionType, DimensionCols, DimensionRows, Cell, EditCellStore, RangeArea } from "../types/index";
type StoreByDimension = Record<number, SelectionStore>;
type FocusedStore = {
    entity: SelectionStore;
    cell: Cell;
    position: Cell;
};
type StoresMapping<T> = {
    [xOrY: number]: Partial<T>;
};
export declare const EMPTY_INDEX = -1;
export declare class SelectionStoreConnector {
    private dirty;
    readonly stores: {
        [y: number]: {
            [x: number]: SelectionStore;
        };
    };
    readonly columnStores: StoreByDimension;
    readonly rowStores: {
        [y: number]: SelectionStore;
    };
    /**
     * Helpers for data conversion
     */
    readonly storesByType: Partial<Record<MultiDimensionType, number>>;
    readonly storesXToType: StoresMapping<DimensionCols>;
    readonly storesYToType: StoresMapping<DimensionRows>;
    get focusedStore(): FocusedStore | null;
    get edit(): EditCellStore | null | undefined;
    get focused(): Cell | null | undefined;
    get selectedRange(): RangeArea | null | undefined;
    private readonly sections;
    registerSection(e?: Element): void;
    beforeUpdate(): void;
    registerColumn(x: number, type: DimensionCols): SelectionStore;
    registerRow(y: number, type: DimensionRows): SelectionStore;
    /**
     * Cross store proxy, based on multiple dimensions
     */
    register({ x, y }: Cell): SelectionStore;
    private destroy;
    setEditByCell<T extends Cell>(storePos: T, editCell: T): void;
    /**
     * Sets the next focus cell before the current one.
     *
     * @param focus - The cell to set as the next focus.
     */
    beforeNextFocusCell(focus: Cell): void;
    focusByCell<T extends Cell>(storePos: T, start: T, end: T): void;
    focus(store: SelectionStore, { focus, end }: {
        focus: Cell;
        end: Cell;
    }): Cell | null;
    /**
     * Retrieves the current store pointer based on the active store.
     * Clears focus from all stores except the active one.
     */
    getCurrentStorePointer(store: SelectionStore): Cell | undefined;
    /**
     * Retrieves the next store based on the focus cell and current store pointer.
     * If the next store exists, returns an object with the next store and the item in the new store.
     * If the next store does not exist, returns null.
     */
    getNextStore(focus: Cell, currentStorePointer: Cell, lastCell: Cell): {
        store: SelectionStore | undefined;
        item: Partial<Cell> | null;
    };
    clearAll(): void;
    setEdit(val?: string | boolean): void;
    /**
     * Select all cells across all stores
     */
    selectAll(): void;
    private getXStores;
    private getYStores;
}
export {};
