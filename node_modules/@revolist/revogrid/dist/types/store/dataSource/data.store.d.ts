import { Trimmed } from './trimmed.plugin';
import { Observable } from '../../utils';
import type { GroupLabelTemplateFunc } from '../../plugins/groupingRow/grouping.row.types';
import type { DimensionRows, DimensionCols, ColumnProperties, ColumnGrouping, ColumnRegular, DataType, DataSourceState, ColumnProp } from "../../types/index";
export interface Group extends ColumnProperties {
    name: string;
    children: (ColumnGrouping | ColumnRegular)[];
    indexes: number[];
}
export type Groups = Record<number, Group[]>;
export type GDataType = DataType | ColumnRegular;
export type GDimension = DimensionRows | DimensionCols;
export type DSourceState<T1 extends GDataType, T2 extends GDimension> = DataSourceState<T1, T2> & {
    groupingCustomRenderer?: GroupLabelTemplateFunc | null;
};
/**
 * Data store
 * Manage the state of a data source and provide methods for updating, adding, and refreshing the data.
 */
export declare class DataStore<T extends GDataType, ST extends GDimension> {
    private readonly dataStore;
    get store(): Observable<DSourceState<T, ST>>;
    constructor(type: ST, storeData?: DSourceState<T, ST>);
    /**
     * full data source update
     * @param source - data column/rgRow source
     * @param grouping - grouping information if present
     */
    updateData(source: T[], grouping?: {
        depth: number;
        groups?: Groups;
        customRenderer?: GroupLabelTemplateFunc;
    }, silent?: boolean): void;
    addTrimmed(some: Partial<Trimmed>): void;
    setSourceData(items: Record<number, any>, mutate?: boolean): void;
    setData(input: Partial<DSourceState<T, ST>>): void;
    refresh(): void;
}
/**
 * get physical index by virtual
 * @param store - store to process
 */
export declare function getPhysical(store: Observable<DSourceState<any, any>>, virtualIndex: number): number;
/**
 * get all visible items
 * @param store - store to process
 */
export declare function getVisibleSourceItem(store: Observable<DSourceState<any, any>>): any[];
/**
 * get mapped item from source
 * @param store - store to process
 * @param virtualIndex - virtual index to process
 */
export declare const getSourceItem: <T1 extends GDataType, T2 extends GDimension>(store: Observable<DSourceState<T1, T2>>, virtualIndex: number) => T1;
/**
 * Get physical index from virtual index
 */
export declare const getSourcePhysicalIndex: <T1 extends GDataType, T2 extends GDimension>(store: Observable<DSourceState<T1, T2>>, virtualIndex: number) => number;
/**
 * Apply silently item/model/row value to data source
 * @param store  - data source with changes
 * @param modelByIndex - collection of rows/values with virtual indexes to setup/replace in store/data source
 * @param mutate - if true, store will be mutated and whole viewport will be re-rendered
 */
export declare function setSourceByVirtualIndex<T extends GDataType>(store: Observable<DSourceState<T, any>>, modelByIndex: Record<number, T | undefined>, mutate?: boolean): void;
/**
 * set item to source
 * @param store  - store to process
 * @param modelByIndex - collection of rows with physical indexes to setup
 * @param mutate - if true, store will be mutated and whole viewport will be re-rendered
 */
export declare function setSourceByPhysicalIndex<T extends GDataType>(store: Observable<DSourceState<T, any>>, modelByIndex: Record<number, T>, mutate?: boolean): void;
export declare function setItems<T extends GDataType>(store: Observable<DSourceState<T, any>>, items: number[]): void;
export declare function getSourceItemVirtualIndexByProp(store: Observable<DSourceState<any, any>>, prop: ColumnProp): number;
