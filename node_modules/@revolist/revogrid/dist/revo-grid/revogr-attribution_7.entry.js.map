{"version":3,"names":["Attribution","render","h","Host","key","href","title","class","RevoGridExtra","refresh","this","update","_a","nodes","map","node","config","getNodes","call","ref","el","collectModelsOfRange","data","store","models","i","rowIndex","parseInt","getSourceItem","getFocusCellBasedOnEvent","e","defaultPrevented","x","getPropertyFromEvent","y","focusCell","getCurrentCell","isAfterLast","lastCell","rows","cols","top","left","height","width","getBoundingClientRect","cellY","cellX","rgRow","getItemByPosition","rgCol","itemIndex","getCoordinate","range","focus","changes","isMulti","updateCoordinate","c","pos","start","end","x1","y1","point","isBeforeFirst","styleByCellProps","styles","getCell","dimensionRow","dimensionCol","getItemByIndex","bottom","right","revogrFocusStyleCss","RevogrFocusStyle0","RevogrFocus","activeFocus","componentDidRender","currentFocus","selectionStore","get","_b","beforeScrollIn","beforeScrollIntoView","emit","scrollIntoView","block","inline","model","dataStore","column","colData","afterFocus","rowType","colType","colIndex","editCell","event","beforeFocusRender","Object","assign","rowDimension","state","colDimension","detail","cell","extra","focusTemplate","props","FOCUS_CLASS","style","DIRECTION_CODES","codesLetter","TAB","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","KeyboardService","constructor","sv","keyDown","canRange","isEditMode","code","ESCAPE","cancel","keyChangeSelection","isClear","clearCell","isTab","isEnterKeyValue","change","isCopy","isCut","isPaste","internalPaste","isAll","selectAll","length","preventDefault","changeDirectionKey","timeout","RESIZE_INTERVAL","keyPositionChange","eData","getData","getRange","shiftKey","includes","AutoFillService","autoFillType","autoFillInitial","autoFillStart","autoFillLast","renderAutofill","selectionFocus","handlerStyle","CELL_HANDLER_CLASS","MOBILE_CLASS","onMouseDown","autoFillHandler","onTouchStart","type","target","Element","selectionStart","isAutoFill","selectionMouseMove","onMouseMoveAutofill","debounce","doAutofillMouseMove","getFocus","current","isSame","setTempRange","area","clearAutoFillSelection","oldRange","stopApply","newRange","clearRangeDataApply","applyRangeWithData","applyRangeOnly","resetAutoFillState","onRangeApply","newData","rangeDataApply","setRange","rangeToCopy","rangeData","columnService","mapping","changed","getRangeData","columns","selectionChanged","rangeCopy","revogrOverlayStyleCss","RevogrOverlaySelectionStyle0","OverlaySelection","keyboardService","autoFillService","unsubscribeSelectionStore","onMouseMove","onMouseUp","onCellDrag","orderEditor","dragStart","onKeyUp","beforeKeyUp","original","onKeyDown","proxy","beforeKeyDown","selectionServiceSet","forEach","v","push","onChange","doFocus","r","triggerRangeEvent","f","focusNextViewport","beforeNextViewportFocus","val","readonly","doEdit","async","revogrEdit","cancelChanges","closeEdit","beforeRegionPaste","createAutoFillService","beforeRangeDataApply","types","tempRangeEvent","beforeSetTempRange","tempRange","selectionChange","beforeRangeCopyApply","rangeEditApply","columnServiceSet","destroy","ColumnService","connectedCallback","disconnectedCallback","componentWillRender","beforeDisconnect","renderRange","SELECTION_BORDER_CLASS","isMobileDevice","renderEditor","enteredOrModelValue","getCellData","rowDataModel","value","editable","getSaveData","renderEvent","beforeEditRender","additionalData","saveOnClose","applyChangesOnClose","editor","getCellEditor","editors","onCloseedit","onCelledit","saveEv","beforeCellSave","cellEdit","preventFocus","focusNext","useClipboard","onCopyregion","onCopy","onClearregion","clipboard","onPasteregion","onPaste","canDrag","parent","element","onRowdragstartinit","rowDragStart","mobile","onDblClick","onElementDblClick","onElementMouseDown","name","beforeFocusCell","evData","next","applyEvent","applyFocus","beforeApplyRange","getRangeTransformedToProps","beforeSetRange","touch","targetElement","isEditInput","verifyTouchTarget","touches","canEdit","setEdit","cancelEdit","dataToSave","cellEditApply","getRegion","canCopyEvent","beforeCopyRegion","copyRangeArray","rangeClipboardCopy","doCopy","isEditing","getTransformedDataToApply","canPaste","rangeClipboardPaste","canFocus","KeyboardEvent","isRangeSingleCell","getRangeStaticData","focused","prop","text","isReadOnly","edited","isRangeEdit","edit","RowHeaderRender","s","__","RevogrRowHeaders","dataViews","viewport","ViewportStore","totalLength","dataPorts","itemCount","DataStore","cellTemplate","rowHeaderColumn","updateData","jobsBeforeRender","rowClass","viewportCol","colSize","calculateRowHeaderSize","setViewport","realCount","virtualSize","items","size","viewportScroll","contentHeight","contentWidth","minWidth","elementToScroll","onScrollviewport","scrollViewport","viewportHeader","headerProp","canResize","ROW_HEADER_TYPE","slot","HEADER_SLOT","AutohideScrollPlugin","autohideScrollTimeout","setScrollSize","setAttribute","removeAttribute","checkScroll","scrollSize","contentSize","hasScroll","isHidden","show","clearTimeout","Number","setTimeout","clear","revogrScrollStyleCss","RevogrScrollVirtualStyle0","RevogrScrollVirtual","setScroll","dimension","localScrollTimer","latestScrollUpdate","localScrollService","coordinate","autohideScrollPlugin","dimensionStore","viewportStore","changeScroll","delta","scrollLeft","scrollTop","minHeight","clientHeight","clientWidth","LocalScrollTimer","document","documentElement","LocalScrollService","runScroll","scrollVirtual","applyScroll","setCoordinate","componentWillLoad","getScrollbarSize","setParams","clientSize","onScroll","isReady","scroll","sizeType","getContentSize","revogrTempRangeStyleCss","RevogrTempRangeStyle0","throttle","doChange","directionY","derectionX","directionClass","TMP_SELECTION_BG_CLASS","hidden"],"sources":["src/components/attribution/revogr-attribution.tsx","src/components/extra/revogr-extra.tsx","src/components/overlay/selection.utils.ts","src/components/selectionFocus/revogr-focus-style.scss?tag=revogr-focus","src/components/selectionFocus/revogr-focus.tsx","src/components/overlay/keyboard.service.ts","src/components/overlay/autofill.service.tsx","src/components/overlay/revogr-overlay-style.scss?tag=revogr-overlay-selection","src/components/overlay/revogr-overlay-selection.tsx","src/components/rowHeaders/row-header-render.tsx","src/components/rowHeaders/revogr-row-headers.tsx","src/components/scrollable/autohide-scroll.plugin.ts","src/components/scrollable/revogr-scroll-style.scss?tag=revogr-scroll-virtual","src/components/scrollable/revogr-scroll-virtual.tsx","src/components/selectionTempRange/revogr-temp-range-style.scss?tag=revogr-temp-range","src/components/selectionTempRange/revogr-temp-range.tsx"],"sourcesContent":["import { Component, Host, h } from '@stencil/core';\n/**\n * If you’re thinking about removing the attribution, we’d like to share a few thoughts first:\n * If you’re using RevoGrid in your organization and it’s helping you make money, we depend on your support to keep improving and maintaining RevoGrid under an MIT License.\n * Before you remove the attribution, please consider how you can support RevoGrid to help keep it running smoothly.\n * Using RevoGrid for a personal project? Awesome! Feel free to remove the attribution. We appreciate your support.\n */\n/**\n * @internal\n */\n@Component({\n  tag: 'revogr-attribution',\n})\nexport class Attribution {\n  render() {\n    return (\n      <Host>\n        <a\n          href=\"https://rv-grid.com/guide/attribution\"\n          title=\"Made with ❤️ by Revolist OU Team\"\n          class=\"value\"\n        >\n          RevoGrid\n        </a>\n      </Host>\n    );\n  }\n}\n","import { h, Component, Method, Prop, State, VNode } from '@stencil/core';\nimport type { ExtraNodeFuncConfig } from '@type';\n\n/**\n * Contains extra elements for stencil components.\n * Performs rendering and updates for external components.\n * \n * @example\n * In Plugins if you want to add extra elements to grid and use stenciljs vnodes reactivity:\n * function paginationPanel(this: PaginationPlugin, config: { refresh: () => void }) {\n *    // use `config.refresh()` for component to re-render\n *    return h('div')\n * }\n * \n * revogrid.registerVNode = [\n *    ...existingNodes,\n *     paginationPanel.bind(this)\n * ];\n\n\n/**\n * @internal\n */\n@Component({\n  tag: 'revogr-extra',\n})\nexport class RevoGridExtra {\n  /**\n   * Nodes to render\n   */\n  @Prop() nodes: (\n    | VNode\n    | ((c: ExtraNodeFuncConfig) => VNode)\n  )[] = [];\n  /**\n   * Force component to re-render\n   */\n  @State() update = 1;\n\n  /**\n   * Refreshes the extra component. Useful if you want to manually\n   * force the component to re-render.\n   */\n  @Method() async refresh() {\n    this.update *= -1;\n  }\n\n  render() {\n    return this.nodes?.map(node => {\n      // Check if node is a function or a stencil component\n      // If function wrap it in a stencil component with the refresh function\n      if (typeof node === 'function') {\n        const config: Partial<ExtraNodeFuncConfig> = {};\n        const getNodes = () => [node({ refresh: () => config.refresh?.() })];\n\n        return (\n          <revogr-extra\n            nodes={getNodes()}\n            ref={(el?: HTMLRevogrExtraElement) => {\n              if (el) {\n                // Update exclusively for current node\n                config.refresh = () => {\n                  el.nodes = getNodes();\n                };\n              }\n            }}\n          />\n        );\n      }\n      return node;\n    });\n  }\n}\n","import {\n  DimensionIndexInput,\n  DSourceState,\n  getItemByIndex,\n  getItemByPosition,\n  getSourceItem,\n} from '@store';\nimport type {\n  DimensionSettingsState,\n  Cell,\n  RangeArea,\n  RangeAreaCss,\n  DataLookup,\n  DimensionRows,\n  DataType,\n  EditCellStore,\n} from '@type';\nimport { getPropertyFromEvent } from '../../utils/events';\nimport { Observable } from '../../utils';\n\nexport type EventData = {\n  el: HTMLElement;\n  rows: DimensionSettingsState;\n  cols: DimensionSettingsState;\n  lastCell: Cell;\n  focus: Cell | null;\n  range: RangeArea | null;\n  edit: EditCellStore | null;\n};\n\nexport function collectModelsOfRange(\n  data: DataLookup,\n  store: Observable<DSourceState<DataType, DimensionRows>>,\n) {\n  const models: Partial<DataLookup> = {};\n  for (let i in data) {\n    const rowIndex = parseInt(i, 10);\n    models[rowIndex] = getSourceItem(store, rowIndex);\n  }\n\n  return models;\n}\n\nexport function getFocusCellBasedOnEvent(\n  e: MouseEvent | TouchEvent,\n  data: EventData,\n): Cell | null {\n  // If event default is prevented, return\n  if (e.defaultPrevented) {\n    return null;\n  }\n\n  // Get coordinates from event object\n  const x = getPropertyFromEvent(e, 'clientX');\n  const y = getPropertyFromEvent(e, 'clientY');\n\n  // If coordinates are not available, return\n  if (x === null || y === null) {\n    return null;\n  }\n\n  // Get current cell based on coordinates and data\n  const focusCell = getCurrentCell({ x, y }, data);\n  // If current cell is not available, return\n  if (isAfterLast(focusCell, data.lastCell)) {\n    return null;\n  }\n\n  return focusCell;\n}\n\n/**\n * Calculate cell based on x, y position\n */\nexport function getCurrentCell(\n  { x, y }: Cell,\n  { el, rows, cols }: Pick<EventData, 'el' | 'rows' | 'cols'>,\n): Cell {\n  // Get the bounding rectangle of the element\n  const { top, left, height, width } = el.getBoundingClientRect();\n\n  // Calculate the cell position relative to the element\n  let cellY = y - top;\n  let cellX = x - left;\n\n  // Limit the cell position to the element height\n  if (cellY >= height) {\n    cellY = height - 1;\n  }\n\n  // Limit the cell position to the element width\n  if (cellX >= width) {\n    cellX = width - 1;\n  }\n\n  // Get the row and column items based on the cell position\n  const rgRow = getItemByPosition(rows, cellY);\n  const rgCol = getItemByPosition(cols, cellX);\n\n  // Set the row and column index to 0 if they are before the first item\n  if (rgCol.itemIndex < 0) {\n    rgCol.itemIndex = 0;\n  }\n\n  if (rgRow.itemIndex < 0) {\n    rgRow.itemIndex = 0;\n  }\n\n  return { x: rgCol.itemIndex, y: rgRow.itemIndex };\n}\n\nexport function getCoordinate(\n  range: RangeArea,\n  focus: Cell,\n  changes: Partial<Cell>,\n  isMulti = false,\n) {\n  const updateCoordinate = (c: keyof Cell, pos = 0) => {\n    const start = { x: range.x, y: range.y };\n    const end = isMulti ? { x: range.x1, y: range.y1 } : start;\n    const point = end[c] > focus[c] ? end : start;\n    point[c] += pos;\n    return { start, end };\n  };\n\n  if (changes.x) {\n    return updateCoordinate('x', changes['x']);\n  }\n  if (changes.y) {\n    return updateCoordinate('y', changes['y']);\n  }\n  return null;\n}\n\n/**\n * Check if the x coordinate of the cell position is after or equal to the x coordinate of the last cell position\n * or if the y coordinate of the cell position is after or equal to the y coordinate of the last cell position\n */\nexport function isAfterLast({ x, y }: Cell, lastCell: Cell) {\n  return x >= lastCell.x || y >= lastCell.y;\n}\n\n/** check if out of range */\nexport function isBeforeFirst({ x, y }: Cell) {\n  return x < 0 || y < 0;\n}\n\n/** Compare cells, only 1 coordinate difference is possible */\n// export function getDirectionCoordinate(initial: Cell, last: Cell): Partial<Cell> | null {\n//   const c: (keyof Cell)[] = ['x', 'y'];\n//   for (let k of c) {\n//     if (initial[k] !== last[k]) {\n//       return { [k]: 1 };\n//     }\n//   }\n//   return null;\n// }\n\n// export function getLargestAxis(initial: Cell, last: Cell): Partial<Cell> | null {\n//   const cell: Partial<Cell> = {};\n//   const c: (keyof Cell)[] = ['x', 'y'];\n//   for (let k of c) {\n//     cell[k] = Math.abs(initial[k] - last[k]);\n//   }\n//   if (cell.x > cell.y) {\n//     return { x: 1 };\n//   }\n//   if (cell.y > cell.x) {\n//     return { y: 1 };\n//   }\n//   return null;\n// }\n\nexport function styleByCellProps(styles: { [key: string]: number }): RangeAreaCss {\n  return {\n    left: `${styles.left}px`,\n    top: `${styles.top}px`,\n    width: `${styles.width}px`,\n    height: `${styles.height}px`,\n  };\n}\n\nexport function getCell(\n  { x, y, x1, y1 }: RangeArea,\n  dimensionRow: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n  dimensionCol: Pick<\n    DimensionIndexInput,\n    'indexToItem' | 'indexes' | 'originItemSize'\n  >,\n) {\n  const top = getItemByIndex(dimensionRow, y).start;\n  const left = getItemByIndex(dimensionCol, x).start;\n  const bottom = getItemByIndex(dimensionRow, y1).end;\n  const right = getItemByIndex(dimensionCol, x1).end;\n\n  return {\n    left,\n    right,\n    top,\n    bottom,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n","revogr-focus.focused-cell {\n  @include selection(1px);\n\n  position: absolute;\n  pointer-events: none;\n  z-index: 9;\n  display: block !important;\n}\n","import {\n  Component,\n  Prop,\n  h,\n  Host,\n  Event,\n  Element,\n  EventEmitter,\n} from '@stencil/core';\nimport { FOCUS_CLASS } from '../../utils/consts';\nimport { getCell, styleByCellProps } from '../overlay/selection.utils';\nimport { DSourceState, getSourceItem } from '@store';\nimport type {\n  Cell,\n  SelectionStoreState,\n  ColumnRegular,\n  DataType,\n  DimensionSettingsState,\n  FocusRenderEvent,\n  FocusTemplateFunc,\n  DimensionCols,\n  DimensionRows,\n  FocusAfterRenderEvent,\n} from '@type';\nimport type { Observable } from '../../utils';\n\n/**\n * Focus component. Shows focus layer around the cell that is currently in focus.\n * @slot focus-${view.type}-${data.type}. @example focus-rgCol-rgRow\n */\n@Component({\n  tag: 'revogr-focus',\n  styleUrl: 'revogr-focus-style.scss',\n})\nexport class RevogrFocus {\n  /**\n   * Column type\n   */\n  @Prop() colType!: DimensionCols;\n  /**\n   * Row type\n   */\n  @Prop() rowType!: DimensionRows;\n\n  /** Dynamic stores */\n  /** Selection, range, focus for selection */\n  @Prop() selectionStore!: Observable<SelectionStoreState>;\n  /** Dimension settings Y */\n  @Prop() dimensionRow!: Observable<DimensionSettingsState>;\n  /** Dimension settings X */\n  @Prop() dimensionCol!: Observable<DimensionSettingsState>;\n  /**\n   * Data rows source\n   */\n  @Prop() dataStore!: Observable<DSourceState<DataType, DimensionRows>>;\n  /**\n   * Column source\n   */\n  @Prop() colData!: Observable<DSourceState<ColumnRegular, DimensionCols>>;\n\n  /**\n   * Focus template custom function. Can be used to render custom focus layer.\n   */\n  @Prop() focusTemplate: FocusTemplateFunc | null = null;\n\n  /**\n   * Before focus render event.\n   * Can be prevented by event.preventDefault().\n   * If preventDefault used slot will be rendered.\n   */\n  @Event({ eventName: 'beforefocusrender' })\n  beforeFocusRender: EventEmitter<FocusRenderEvent>;\n\n  /**\n   * Before focus changed verify if it's in view and scroll viewport into this view\n   * Can be prevented by event.preventDefault()\n   */\n  @Event({ eventName: 'beforescrollintoview' })\n  beforeScrollIntoView: EventEmitter<{ el: HTMLElement }>;\n  /**\n   * Used to setup properties after focus was rendered\n   */\n  @Event({ eventName: 'afterfocus' })\n  afterFocus: EventEmitter<FocusAfterRenderEvent>;\n\n  @Element() el: HTMLElement;\n  private activeFocus: Cell | null = null;\n\n  componentDidRender() {\n    const currentFocus = this.selectionStore.get('focus');\n    if (\n      this.activeFocus?.x === currentFocus?.x &&\n      this.activeFocus?.y === currentFocus?.y\n    ) {\n      return;\n    }\n    this.activeFocus = currentFocus;\n    if (currentFocus && this.el) {\n      const beforeScrollIn = this.beforeScrollIntoView.emit({ el: this.el });\n      if (!beforeScrollIn.defaultPrevented) {\n        this.el.scrollIntoView({\n          block: 'nearest',\n          inline: 'nearest',\n        });\n      }\n      const model = getSourceItem(this.dataStore, currentFocus.y);\n      const column = getSourceItem(this.colData, currentFocus.x);\n      this.afterFocus.emit({\n        model,\n        column,\n        rowType: this.rowType,\n        colType: this.colType,\n        rowIndex: currentFocus.y,\n        colIndex: currentFocus.x,\n      });\n    }\n  }\n\n  render() {\n    const editCell = this.selectionStore.get('edit');\n    if (editCell) {\n      return;\n    }\n    const focusCell = this.selectionStore.get('focus');\n    if (!focusCell) {\n      return;\n    }\n    const event = this.beforeFocusRender.emit({\n      range: {\n        ...focusCell,\n        x1: focusCell.x,\n        y1: focusCell.y,\n      },\n      rowType: this.rowType,\n      colType: this.colType,\n      rowDimension: { ...this.dimensionRow.state },\n      colDimension: { ...this.dimensionCol.state },\n    });\n    if (event.defaultPrevented) {\n      return <slot />;\n    }\n    const { detail } = event;\n\n    const cell = getCell(\n      detail.range,\n      event.detail.rowDimension,\n      event.detail.colDimension,\n    );\n    const styles = styleByCellProps(cell);\n    const extra = this.focusTemplate?.(h, detail);\n    const props = {\n      class: { [FOCUS_CLASS]: true },\n      style: styles,\n    };\n    return (\n      <Host {...props}>\n        <slot />\n        {extra}\n      </Host>\n    );\n  }\n}\n","import { getRange } from '@store';\nimport {\n  codesLetter,\n  isAll,\n  isClear,\n  isCopy,\n  isCut,\n  isEnterKeyValue,\n  isPaste,\n  isTab,\n  timeout,\n  RESIZE_INTERVAL,\n  type Observable,\n} from '../../utils';\nimport {\n  EventData,\n  getCoordinate,\n  isAfterLast,\n  isBeforeFirst,\n} from './selection.utils';\nimport { Cell, Nullable, RangeArea, SelectionStoreState } from '@type';\n\ntype Config = {\n  selectionStore: Observable<SelectionStoreState>;\n\n  // Apply changes from edit.\n  change(val?: any): void;\n  // Cancels edit. Escape changes.\n  cancel(): void;\n\n  clearCell(): void;\n  focus(\n    focus: Cell,\n    changes: Partial<Cell>,\n    focusNextViewport?: number,\n  ): boolean;\n\n  getData(): any;\n  internalPaste(): void;\n  range(range: RangeArea | null): boolean;\n  selectAll(): void;\n};\n\nconst DIRECTION_CODES: string[] = [\n  codesLetter.TAB,\n  codesLetter.ARROW_UP,\n  codesLetter.ARROW_DOWN,\n  codesLetter.ARROW_LEFT,\n  codesLetter.ARROW_RIGHT,\n];\nexport class KeyboardService {\n  constructor(private sv: Config) {}\n\n  async keyDown(\n    e: KeyboardEvent,\n    canRange: boolean,\n    isEditMode: boolean,\n    { range, focus }: Nullable<Pick<EventData, 'range' | 'focus'>>,\n  ) {\n    // IF EDIT MODE\n    if (isEditMode) {\n      switch (e.code) {\n        case codesLetter.ESCAPE:\n          this.sv.cancel();\n          break;\n        case codesLetter.TAB:\n          this.keyChangeSelection(e, canRange);\n          break;\n      }\n      return;\n    }\n\n    // IF NOT EDIT MODE\n\n    // pressed clear key\n    if (range && isClear(e.code)) {\n      this.sv.clearCell();\n      return;\n    }\n\n    // below works with focus only\n    if (!focus) {\n      return;\n    }\n\n    // tab key means same as arrow right\n    if (isTab(e.code)) {\n      this.keyChangeSelection(e, canRange);\n      return;\n    }\n\n    // pressed enter\n    if (isEnterKeyValue(e.key)) {\n      this.sv.change();\n      return;\n    }\n\n    // copy operation\n    if (isCopy(e)) {\n      return;\n    }\n\n    // cut operation\n    if (isCut(e)) {\n      return;\n    }\n\n    // paste operation\n    if (isPaste(e)) {\n      this.sv.internalPaste();\n      return;\n    }\n\n    // select all\n    if (isAll(e)) {\n      if (canRange) {\n        this.selectAll(e);\n      }\n      return;\n    }\n\n    // pressed letter key\n    if (e.key.length === 1) {\n      this.sv.change(e.key);\n      return;\n    }\n\n    // pressed arrow, change selection position\n    if (await this.keyChangeSelection(e, canRange)) {\n      return;\n    }\n  }\n\n  private selectAll(e: KeyboardEvent) {\n    const range = this.sv.selectionStore.get('range');\n    const focus = this.sv.selectionStore.get('focus');\n    // if no range or focus - do nothing\n    if (!range || !focus) {\n      return;\n    }\n    e.preventDefault();\n    this.sv.selectAll();\n  }\n\n  async keyChangeSelection(e: KeyboardEvent, canRange: boolean) {\n    const data = this.changeDirectionKey(e, canRange);\n    if (!data) {\n      return false;\n    }\n\n    // this interval needed for several cases\n    // grid could be resized before next click\n    // at this case to avoid screen jump we use this interval\n    await timeout(RESIZE_INTERVAL + 30);\n\n    const range = this.sv.selectionStore.get('range');\n    const focus = this.sv.selectionStore.get('focus');\n    return this.keyPositionChange(data.changes, range, focus, data.isMulti);\n  }\n\n  keyPositionChange(\n    changes: Partial<Cell>,\n    range: RangeArea | null,\n    focus: Cell | null,\n    isMulti = false,\n  ) {\n    if (!range || !focus) {\n      return false;\n    }\n    const data = getCoordinate(range, focus, changes, isMulti);\n    if (!data) {\n      return false;\n    }\n    const eData: EventData = this.sv.getData();\n    if (isMulti) {\n      if (isAfterLast(data.end, eData.lastCell) || isBeforeFirst(data.start)) {\n        return false;\n      }\n      const range = getRange(data.start, data.end);\n      return this.sv.range(range);\n    }\n    return this.sv.focus(\n      data.start,\n      changes,\n      isAfterLast(data.start, eData.lastCell)\n        ? 1\n        : isBeforeFirst(data.start)\n          ? -1\n          : 0,\n    );\n  }\n\n  /** Monitor key direction changes */\n  changeDirectionKey(\n    e: KeyboardEvent,\n    canRange: boolean,\n  ): { changes: Partial<Cell>; isMulti?: boolean } | void {\n    const isMulti = canRange && e.shiftKey;\n    if (DIRECTION_CODES.includes(e.code)) {\n      e.preventDefault();\n    }\n\n    if (e.shiftKey) {\n      switch (e.code) {\n        case codesLetter.TAB:\n          return { changes: { x: -1 }, isMulti: false };\n      }\n    }\n\n    switch (e.code) {\n      case codesLetter.ARROW_UP:\n        return { changes: { y: -1 }, isMulti };\n      case codesLetter.ARROW_DOWN:\n        return { changes: { y: 1 }, isMulti };\n      case codesLetter.ARROW_LEFT:\n        return { changes: { x: -1 }, isMulti };\n      case codesLetter.TAB:\n      case codesLetter.ARROW_RIGHT:\n        return { changes: { x: 1 }, isMulti };\n    }\n  }\n}\n","import debounce from 'lodash/debounce';\nimport { DebouncedFunc } from 'lodash';\n\nimport { h } from '@stencil/core';\nimport { CELL_HANDLER_CLASS, MOBILE_CLASS } from '../../utils/consts';\nimport {\n  collectModelsOfRange,\n  EventData,\n  getCell,\n  getCurrentCell,\n  isAfterLast,\n} from './selection.utils';\nimport { DSourceState, getRange } from '@store';\nimport ColumnService from '../data/column.service';\nimport { getPropertyFromEvent } from '../../utils/events';\nimport {\n  DataLookup,\n  DataType,\n  DimensionSettingsState,\n  TempRange,\n  ChangedRange,\n  BeforeRangeSaveDataDetails,\n  RangeArea,\n  Cell,\n  DimensionRows, Nullable,\n} from '@type';\nimport { Observable } from '../../utils';\n\ntype Config = {\n  dimensionRow: Observable<DimensionSettingsState>;\n  dimensionCol: Observable<DimensionSettingsState>;\n  columnService: ColumnService;\n  dataStore: Observable<DSourceState<DataType, DimensionRows>>;\n\n  setTempRange(e: Nullable<TempRange> | null): Event | null;\n  selectionChanged(e: ChangedRange): Event;\n  rangeCopy(e: ChangedRange): Event;\n  rangeDataApply(e: BeforeRangeSaveDataDetails): CustomEvent;\n  setRange(e: RangeArea | null): boolean;\n  clearRangeDataApply(e: { range: RangeArea }): CustomEvent<{\n    range: RangeArea;\n  }>;\n\n  getData(): any;\n};\n\nconst enum AutoFillType {\n  selection = 'Selection',\n  autoFill = 'AutoFill',\n}\n\nexport class AutoFillService {\n  private autoFillType: AutoFillType | null = null;\n  private autoFillInitial: Cell | null = null;\n  private autoFillStart: Cell | null = null;\n  private autoFillLast: Cell | null = null;\n\n  private onMouseMoveAutofill: DebouncedFunc<\n    (e: MouseEvent | TouchEvent, data: EventData) => void\n  >;\n\n  constructor(private sv: Config) {}\n\n  /**\n   * Render autofill box\n   * @param range\n   * @param selectionFocus\n   */\n  renderAutofill(range: RangeArea | null, selectionFocus: Cell) {\n    let handlerStyle;\n    if (range) {\n      handlerStyle = getCell(\n        range,\n        this.sv.dimensionRow.state,\n        this.sv.dimensionCol.state,\n      );\n    } else {\n      handlerStyle = getCell(\n        {\n          ...selectionFocus,\n          x1: selectionFocus.x,\n          y1: selectionFocus.y,\n        },\n        this.sv.dimensionRow.state,\n        this.sv.dimensionCol.state,\n      );\n    }\n    return (\n      <div\n        class={{\n          [CELL_HANDLER_CLASS]: true,\n          [MOBILE_CLASS]: true,\n        }}\n        style={{\n          left: `${handlerStyle.right}px`,\n          top: `${handlerStyle.bottom}px`,\n        }}\n        onMouseDown={(e: MouseEvent) => this.autoFillHandler(e)}\n        onTouchStart={(e: TouchEvent) => this.autoFillHandler(e)}\n      />\n    );\n  }\n\n  private autoFillHandler(\n    e: MouseEvent | TouchEvent,\n    type = AutoFillType.autoFill,\n  ) {\n    let target: Element | null = null;\n    if (e.target instanceof Element) {\n      target = e.target;\n    }\n    if (!target) {\n      return;\n    }\n    this.selectionStart(target, this.sv.getData(), type);\n    e.preventDefault();\n  }\n\n  get isAutoFill() {\n    return !!this.autoFillType;\n  }\n\n  /**\n   * Process mouse move events\n   */\n  selectionMouseMove(e: MouseEvent | TouchEvent) {\n    // initiate mouse move debounce if not present\n    if (!this.onMouseMoveAutofill) {\n      this.onMouseMoveAutofill = debounce(\n        (e: MouseEvent | TouchEvent, data: EventData) =>\n          this.doAutofillMouseMove(e, data),\n        5,\n      );\n    }\n    if (this.isAutoFill) {\n      this.onMouseMoveAutofill(e, this.sv.getData());\n    }\n  }\n\n  private getFocus(focus: Cell | null, range: RangeArea | null) {\n    // there was an issue that it was taking last cell from range but focus was out\n    if (!focus && range) {\n      focus = { x: range.x, y: range.y };\n    }\n    return focus || null;\n  }\n\n  /**\n   * Autofill logic:\n   * on mouse move apply based on previous direction (if present)\n   */\n  private doAutofillMouseMove(event: MouseEvent | TouchEvent, data: EventData) {\n    // if no initial - not started\n    if (!this.autoFillInitial) {\n      return;\n    }\n    const x = getPropertyFromEvent(event, 'clientX', MOBILE_CLASS);\n    const y = getPropertyFromEvent(event, 'clientY', MOBILE_CLASS);\n    // skip touch\n    if (x === null || y === null) {\n      return;\n    }\n    const current = getCurrentCell({ x, y }, data);\n\n    // first time or direction equal to start(same as first time)\n    if (!this.autoFillLast) {\n      if (!this.autoFillLast) {\n        this.autoFillLast = this.autoFillStart;\n      }\n    }\n\n    // check if not the latest, if latest - do nothing\n    if (isAfterLast(current, data.lastCell)) {\n      return;\n    }\n    this.autoFillLast = current;\n\n    const isSame =\n      current.x === this.autoFillInitial.x &&\n      current.y === this.autoFillInitial.y;\n\n    // if same as initial - clear\n    if (isSame) {\n      this.sv.setTempRange(null);\n    } else {\n      const area = getRange(this.autoFillInitial, this.autoFillLast);\n      this.sv.setTempRange({\n        area,\n        type: this.autoFillType,\n      });\n    }\n  }\n\n  /**\n   * Range selection started\n   * Mode @param type:\n   * Can be triggered from MouseDown selection on element\n   * Or can be triggered on corner square drag\n   */\n  selectionStart(\n    target: Element,\n    data: EventData,\n    type = AutoFillType.selection,\n  ) {\n    /** Get cell by autofill element */\n    const { top, left } = target.getBoundingClientRect();\n    this.autoFillInitial = this.getFocus(data.focus, data.range);\n    this.autoFillType = type;\n    this.autoFillStart = getCurrentCell({ x: left, y: top }, data);\n  }\n\n  /**\n   * Clear current range selection on mouse up and mouse leave events\n   */\n  clearAutoFillSelection(focus: Cell | null, oldRange: RangeArea | null) {\n    // If autofill was active, apply autofill values\n    if (this.autoFillInitial) {\n      // Fetch latest focus\n      this.autoFillInitial = this.getFocus(focus, oldRange);\n\n      // Apply range data if autofill mode is active\n      if (this.autoFillType === AutoFillType.autoFill) {\n        const range = getRange(this.autoFillInitial, this.autoFillLast);\n\n        // If range is present, apply data\n        if (range) {\n          const {\n            defaultPrevented: stopApply,\n            detail: { range: newRange },\n          } = this.sv.clearRangeDataApply({\n            range,\n          });\n\n          // If data apply was not prevented, apply new range\n          if (!stopApply && oldRange) {\n            this.applyRangeWithData(newRange, oldRange);\n          } else {\n            // If data apply was prevented, clear temporary range\n            this.sv.setTempRange(null);\n          }\n        }\n      } else {\n        // If not autofill mode, apply range only\n        this.applyRangeOnly(this.autoFillInitial, this.autoFillLast);\n      }\n    }\n\n    // Reset autofill state\n    this.resetAutoFillState();\n  }\n\n  /**\n   * Reset autofill state\n   */\n  private resetAutoFillState() {\n    this.autoFillType = null;\n    this.autoFillInitial = null;\n    this.autoFillLast = null;\n    this.autoFillStart = null;\n  }\n\n  /**\n   * Trigger range apply events and handle responses\n   */\n  onRangeApply(newData: DataLookup, newRange: RangeArea | null, oldRange: RangeArea | null) {\n    this.sv.rangeDataApply({\n      data: newData,\n      models: collectModelsOfRange(newData, this.sv.dataStore),\n      type: this.sv.dataStore.get('type'),\n      oldRange,\n      newRange\n    });\n\n    this.sv.setRange(newRange);\n  }\n\n  /** Apply range and copy data during range application */\n  private applyRangeWithData(newRange: RangeArea, rangeToCopy: RangeArea) {\n    const rangeData: ChangedRange = {\n      type: this.sv.dataStore.get('type'),\n      colType: this.sv.columnService.type,\n      newData: {},\n      mapping: {},\n      newRange,\n      oldRange: rangeToCopy,\n    };\n    const { mapping, changed } = this.sv.columnService.getRangeData(\n      rangeData,\n      this.sv.columnService.columns,\n    );\n    rangeData.newData = changed;\n    rangeData.mapping = mapping;\n    let e = this.sv.selectionChanged(rangeData);\n\n    // if default prevented - clear range\n    if (e.defaultPrevented) {\n      this.sv.setTempRange(null);\n      return;\n    }\n\n    e = this.sv.rangeCopy(rangeData);\n    if (e.defaultPrevented) {\n      this.sv.setRange(newRange);\n      return;\n    }\n    this.onRangeApply(rangeData.newData, newRange, rangeToCopy);\n  }\n\n  /**\n   * Update range selection only,\n   * no data change (mouse selection)\n   */\n  private applyRangeOnly(start?: Cell | null, end?: Cell | null) {\n    // no changes to apply\n    if (!start || !end) {\n      return;\n    }\n\n    const newRange = getRange(start, end);\n    this.sv.setRange(newRange);\n  }\n}\n","@mixin autofill-handle($handler-size: 14px, $icon-size: 10px) {\n  .autofill-handle {\n    position: absolute;\n    width: $handler-size;\n    height: $handler-size;\n    margin-left: -$handler-size + 1;\n    margin-top: -$handler-size + 1;\n    z-index: 10;\n    cursor: crosshair;\n\n    &::before {\n      content: '';\n      position: absolute;\n      right: 0;\n      bottom: 0;\n      width: $icon-size;\n      height: $icon-size;\n      background: $selection-border;\n      border: 1px solid white;\n      box-sizing: border-box;\n    }\n  }\n}\n\nrevogr-overlay-selection {\n  display: block;\n  position: relative;\n  width: 100%;\n\n\n  @include autofill-handle;\n\n  &.mobile {\n    @include autofill-handle(30px, 12px);\n  }\n\n  .selection-border-range {\n    position: absolute;\n    pointer-events: none;\n    z-index: 9;\n\n    .range-handlers {\n      height: 100%;\n      background-color: transparent;\n      width: calc(50% + (50% / 2));\n      max-width: 50px;\n      min-width: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      position: absolute;\n\n      $btn-size: 20px;\n      $handler-w: 15px;\n      $handler-h: 5px;\n      \n      > span {\n        pointer-events: auto;\n        height: $btn-size;\n        width: $btn-size;\n        position: absolute;\n        left: 50%;\n        transform: translateX(-50%);\n\n\n        &:before, &:after {\n          position: absolute;\n          border-radius: 5px;\n          width: $handler-w;\n          height: $handler-h;\n          left: 50%;\n          transform: translateX(-50%);\n          background-color: rgba(black, 20%);\n        }\n        &:first-child {\n          top: -($handler-h + 2px);\n          &:before{\n            content: '';\n            top: 0;\n          }\n        }\n        &:last-child {\n          bottom: -($handler-h + 2px);\n          &:after{\n            content: '';\n            bottom: 0;\n          }\n        }\n      }\n    }\n    @include selection();\n  }\n\n  revogr-edit {\n    z-index: 10;\n  }\n}\n","import {\n  Component,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Listen,\n  Prop,\n  type VNode,\n  Element,\n  Watch,\n} from '@stencil/core';\nimport ColumnService from '../data/column.service';\nimport { codesLetter } from '../../utils/key.codes';\nimport { MOBILE_CLASS, SELECTION_BORDER_CLASS } from '../../utils/consts';\nimport { type DSourceState, getRange, isRangeSingleCell } from '@store';\nimport {\n  collectModelsOfRange,\n  EventData,\n  getCell,\n  getFocusCellBasedOnEvent,\n  styleByCellProps,\n} from './selection.utils';\nimport { isEditInput } from '../editors/edit.utils';\nimport { KeyboardService } from './keyboard.service';\nimport { AutoFillService } from './autofill.service';\nimport { verifyTouchTarget } from '../../utils/events';\nimport { getCellData, type Observable } from '../../utils';\n\nimport type {\n  SelectionStoreState,\n  DimensionSettingsState,\n  DataType,\n  DimensionRows,\n  ColumnRegular,\n  DimensionCols,\n  DragStartEvent,\n  Cell,\n  MultiDimensionType,\n  Nullable,\n  RangeClipboardCopyEventProps,\n  RangeClipboardPasteEvent,\n  FocusRenderEvent,\n  ApplyFocusEvent,\n  AllDimensionType,\n  DataFormat,\n  Editors,\n  BeforeSaveDataDetails,\n  BeforeEdit,\n  RangeArea,\n  TempRange,\n  ChangedRange,\n  BeforeRangeSaveDataDetails,\n  SaveDataDetails,\n} from '@type';\n\n/**\n * Component for overlaying the grid with the selection.\n */\n@Component({\n  tag: 'revogr-overlay-selection',\n  styleUrl: 'revogr-overlay-style.scss',\n})\nexport class OverlaySelection {\n  // #region Properties\n  /**\n   * Readonly mode.\n   */\n  @Prop() readonly: boolean;\n  /**\n   * Range selection allowed.\n   */\n  @Prop() range: boolean;\n  /**\n   * Enable revogr-order-editor component (read more in revogr-order-editor component).\n   * Allows D&D.\n   */\n  @Prop() canDrag: boolean;\n\n  /**\n   * Enable revogr-clipboard component (read more in revogr-clipboard component).\n   * Allows copy/paste.\n   */\n  @Prop() useClipboard: boolean;\n\n  /** Stores */\n  /** Selection, range, focus. */\n  @Prop() selectionStore!: Observable<SelectionStoreState>;\n  /** Dimension settings Y. */\n  @Prop() dimensionRow: Observable<DimensionSettingsState>;\n  /** Dimension settings X. */\n  @Prop() dimensionCol!: Observable<DimensionSettingsState>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Static stores, not expected to change during component lifetime\n  //\n  // --------------------------------------------------------------------------\n\n  /**\n   * Row data store.\n   */\n  @Prop() dataStore!: Observable<DSourceState<DataType, DimensionRows>>;\n\n  /**\n   * Column data store.\n   */\n  @Prop() colData!: Observable<DSourceState<ColumnRegular, DimensionCols>>;\n  /**\n   * Last real coordinates positions + 1.\n   */\n  @Prop() lastCell: Cell;\n  /**\n   * Custom editors register.\n   */\n  @Prop() editors: Editors;\n  /**\n   * If true applys changes when cell closes if not Escape.\n   */\n  @Prop() applyChangesOnClose = false;\n  /**\n   * Additional data to pass to renderer.\n   */\n  @Prop() additionalData: any;\n\n  /**\n   * Is mobile view mode.\n   */\n  @Prop() isMobileDevice: boolean;\n\n  // #endregion\n\n  // #region Events\n  /**\n   * Before clipboard copy happened. Validate data before copy.\n   * To prevent the default behavior of editing data and use your own implementation, call `e.preventDefault()`.\n   */\n  @Event({ eventName: 'beforecopyregion', cancelable: true })\n  beforeCopyRegion: EventEmitter;\n  /**\n   * Before region paste happened.\n   */\n  @Event({ eventName: 'beforepasteregion', cancelable: true })\n  beforeRegionPaste: EventEmitter;\n\n  /**\n   * Cell edit apply to the data source.\n   * Triggers datasource edit on the root level.\n   */\n  @Event({ eventName: 'celleditapply', cancelable: true })\n  cellEditApply: EventEmitter<BeforeSaveDataDetails>;\n\n  /**\n   * Before cell focus.\n   */\n  @Event({ eventName: 'beforecellfocusinit', cancelable: true })\n  beforeFocusCell: EventEmitter<BeforeSaveDataDetails>;\n\n  /**\n   * Fired when change of viewport happens.\n   * Usually when we switch between pinned regions.\n   */\n  @Event({ eventName: 'beforenextvpfocus', cancelable: true })\n  beforeNextViewportFocus: EventEmitter<Cell>;\n\n  /**\n   * Set edit cell.\n   */\n  @Event({ eventName: 'setedit' }) setEdit: EventEmitter<BeforeEdit>;\n\n  /**\n   * Before range applied.\n   * First step in triggerRangeEvent.\n   */\n  @Event({ eventName: 'beforeapplyrange' })\n  beforeApplyRange: EventEmitter<FocusRenderEvent>;\n  /**\n   * Before range selection applied.\n   * Second step in triggerRangeEvent.\n   */\n  @Event({ eventName: 'beforesetrange' }) beforeSetRange: EventEmitter;\n\n  /**\n   * Set range.\n   * Third step in triggerRangeEvent.\n   */\n  @Event({ eventName: 'setrange' }) setRange: EventEmitter<\n    RangeArea & { type: MultiDimensionType }\n  >;\n\n  /**\n   * Before editor render.\n   */\n  @Event({ eventName: 'beforeeditrender' })\n  beforeEditRender: EventEmitter<FocusRenderEvent>;\n\n\n  /** Select all cells from keyboard. */\n  @Event({ eventName: 'selectall' }) selectAll: EventEmitter;\n  /**\n   * Cancel edit. Used for editors support when editor close requested.\n   */\n  @Event({ eventName: 'canceledit' }) cancelEdit: EventEmitter;\n\n  /**\n   * Set temp range area during autofill.\n   */\n  @Event({ eventName: 'settemprange' })\n  setTempRange: EventEmitter<Nullable<TempRange> | null>;\n\n  /**\n   * Before set temp range area during autofill.\n   */\n  @Event({ eventName: 'beforesettemprange' })\n  beforeSetTempRange: EventEmitter<\n    { tempRange: Nullable<TempRange> | null } & EventData & AllDimensionType\n  >;\n\n  /**\n   * Before cell get focused.\n   * To prevent the default behavior of applying the edit data, you can call `e.preventDefault()`.\n   */\n  @Event({ eventName: 'applyfocus' })\n  applyFocus: EventEmitter<FocusRenderEvent>;\n\n  /**\n   * Cell get focused.\n   * To prevent the default behavior of applying the edit data, you can call `e.preventDefault()`.\n   */\n  @Event({ eventName: 'focuscell' }) focusCell: EventEmitter<ApplyFocusEvent & FocusRenderEvent>;\n  /** Range data apply. */\n  @Event({ eventName: 'beforerangedataapply' })\n  beforeRangeDataApply: EventEmitter<FocusRenderEvent>;\n  /** Autofill data in range. First step in applyRangeWithData */\n  @Event({ eventName: 'selectionchangeinit', cancelable: true })\n  selectionChange: EventEmitter<ChangedRange>;\n  /** Before range copy. */\n  @Event({ eventName: 'beforerangecopyapply', cancelable: true, bubbles: true })\n  beforeRangeCopyApply: EventEmitter<ChangedRange>;\n\n  /** Range data apply.\n   * Triggers datasource edit on the root level.\n   */\n  @Event({ eventName: 'rangeeditapply', cancelable: true })\n  rangeEditApply: EventEmitter<BeforeRangeSaveDataDetails>;\n  /** Range copy. */\n  @Event({ eventName: 'clipboardrangecopy', cancelable: true })\n  /**\n   * Range copy event.\n   * This event is triggered when data is ready to be copied to the clipboard.\n   * If you want to prevent the default behavior of copying data, you can call `e.preventDefault()`.\n   * If you want to modify the data that will be copied to the clipboard, modify the `data` property of the event object.\n   */\n  rangeClipboardCopy: EventEmitter<RangeClipboardCopyEventProps>;\n\n  /**\n   * Range paste event.\n   */\n  @Event({ eventName: 'clipboardrangepaste', cancelable: true })\n  rangeClipboardPaste: EventEmitter<RangeClipboardPasteEvent>;\n\n  /**\n   * Before key up event proxy, used to prevent key up trigger.\n   * If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic.\n   * Call preventDefault().\n   */\n  @Event({ eventName: 'beforekeydown' })\n  beforeKeyDown: EventEmitter<{ original: KeyboardEvent } & EventData>;\n  /**\n   * Before key down event proxy, used to prevent key down trigger.\n   * If you have some custom behaviour event, use this event to check if it wasn't processed by internal logic.\n   * Call preventDefault().\n   */\n  @Event({ eventName: 'beforekeyup' }) beforeKeyUp: EventEmitter<\n    { original: KeyboardEvent } & EventData\n  >;\n  /**\n   * Runs before cell save.\n   * Can be used to override or cancel original save.\n   */\n  @Event({ eventName: 'beforecellsave', cancelable: true })\n  beforeCellSave: EventEmitter;\n\n  // #endregion\n\n  // #region Private Properties\n  @Element() element: HTMLElement;\n  private clipboard?: HTMLRevogrClipboardElement;\n\n  protected columnService: ColumnService;\n  private keyboardService: KeyboardService | null = null;\n  private autoFillService: AutoFillService | null = null;\n  private orderEditor?: HTMLRevogrOrderEditorElement;\n  private revogrEdit?: HTMLRevogrEditElement;\n  private unsubscribeSelectionStore: { (): void }[] = [];\n  // #endregion\n\n  // #region Listeners\n  @Listen('touchmove', { target: 'document' })\n  @Listen('mousemove', { target: 'document' })\n  onMouseMove(e: MouseEvent | TouchEvent) {\n    if (this.selectionStore.get('focus')) {\n      this.autoFillService?.selectionMouseMove(e);\n    }\n  }\n\n  /**\n   * Action finished inside the document.\n   * Pointer left document, clear any active operation.\n   */\n  @Listen('touchend', { target: 'document' })\n  @Listen('mouseup', { target: 'document' })\n  @Listen('mouseleave', { target: 'document' })\n  onMouseUp() {\n    // Clear autofill selection\n    // when pointer left document,\n    // clear any active operation.\n    this.autoFillService?.clearAutoFillSelection(\n      this.selectionStore.get('focus'),\n      this.selectionStore.get('range'),\n    );\n  }\n\n  /**\n   * Row drag started.\n   * This event is fired when drag action started on cell.\n   */\n  @Listen('dragstartcell') onCellDrag(e: CustomEvent<DragStartEvent>) {\n    // Invoke drag start on order editor.\n    this.orderEditor?.dragStart(e.detail);\n  }\n\n  /**\n   * Get keyboard down from element.\n   * This event is fired when keyboard key is released.\n   */\n  @Listen('keyup', { target: 'document' }) onKeyUp(e: KeyboardEvent) {\n    // Emit before key up event.\n    this.beforeKeyUp.emit({ original: e, ...this.getData() });\n  }\n\n  /**\n   * Get keyboard down from element.\n   * This event is fired when keyboard key is pressed.\n   */\n  @Listen('keydown', { target: 'document' }) onKeyDown(e: KeyboardEvent) {\n    // Emit before key down event and check if default prevention is set.\n    const proxy = this.beforeKeyDown.emit({ original: e, ...this.getData() });\n    if (e.defaultPrevented || proxy.defaultPrevented) {\n      return;\n    }\n    // Invoke key down on keyboard service.\n    this.keyboardService?.keyDown(\n      e,\n      this.range,\n      !!this.selectionStore.get('edit'),\n      {\n        focus: this.selectionStore.get('focus'),\n        range: this.selectionStore.get('range'),\n      },\n    );\n  }\n  // #endregion\n\n  /**\n   * Selection & Keyboard\n   */\n  @Watch('selectionStore') selectionServiceSet(\n    selectionStore: Observable<SelectionStoreState>,\n  ) {\n    // clear subscriptions\n    this.unsubscribeSelectionStore.forEach(v => v());\n    this.unsubscribeSelectionStore.length = 0;\n    this.unsubscribeSelectionStore.push(\n      selectionStore.onChange('nextFocus', v => v && this.doFocus(v, v)),\n    );\n\n    this.keyboardService = new KeyboardService({\n      selectionStore,\n      range: r => !!r && this.triggerRangeEvent(r),\n      focus: (f, changes, focusNextViewport) => {\n        if (focusNextViewport) {\n          this.beforeNextViewportFocus.emit(f);\n          return false;\n        } else {\n          return this.doFocus(f, f, changes);\n        }\n      },\n      change: val => {\n        if (this.readonly) {\n          return;\n        }\n        this.doEdit(val);\n      },\n      cancel: async () => {\n        await this.revogrEdit?.cancelChanges();\n        this.closeEdit();\n      },\n      clearCell: () => !this.readonly && this.clearCell(),\n      internalPaste: () => !this.readonly && this.beforeRegionPaste.emit(),\n      getData: () => this.getData(),\n      selectAll: () => this.selectAll.emit(),\n    });\n    this.createAutoFillService();\n  }\n  /** Autofill */\n  @Watch('dimensionRow')\n  @Watch('dimensionCol')\n  createAutoFillService() {\n    this.autoFillService = new AutoFillService({\n      dimensionRow: this.dimensionRow,\n      dimensionCol: this.dimensionCol,\n      columnService: this.columnService,\n      dataStore: this.dataStore,\n\n      clearRangeDataApply: e =>\n        this.beforeRangeDataApply.emit({\n          ...e,\n          ...this.types,\n          rowDimension: { ...this.dimensionRow.state },\n          colDimension: { ...this.dimensionCol.state },\n        }),\n      setTempRange: e => {\n        const tempRangeEvent = this.beforeSetTempRange.emit({\n          tempRange: e,\n          ...this.getData(),\n          ...this.types,\n        });\n        if (tempRangeEvent.defaultPrevented) {\n          return null;\n        }\n        return this.setTempRange.emit(tempRangeEvent.detail.tempRange);\n      },\n      selectionChanged: e => this.selectionChange.emit(e),\n\n      rangeCopy: e => this.beforeRangeCopyApply.emit(e),\n      rangeDataApply: e => this.rangeEditApply.emit(e),\n\n      setRange: e => !!e && this.triggerRangeEvent(e),\n      getData: () => this.getData(),\n    });\n  }\n\n  /** Columns */\n  @Watch('dataStore')\n  @Watch('colData')\n  columnServiceSet() {\n    this.columnService?.destroy();\n    this.columnService = new ColumnService(this.dataStore, this.colData);\n    this.createAutoFillService();\n  }\n\n  connectedCallback() {\n    this.columnServiceSet();\n    this.selectionServiceSet(this.selectionStore);\n  }\n\n  disconnectedCallback() {\n    // clear subscriptions\n    this.unsubscribeSelectionStore.forEach(v => v());\n    this.unsubscribeSelectionStore.length = 0;\n    this.columnService?.destroy();\n  }\n\n  async componentWillRender() {\n    const editCell = this.selectionStore.get('edit');\n    if (!editCell) {\n      await this.revogrEdit?.beforeDisconnect?.();\n    }\n  }\n\n  private renderRange(range: RangeArea) {\n    const cell = getCell(\n      range,\n      this.dimensionRow.state,\n      this.dimensionCol.state,\n    );\n    const styles = styleByCellProps(cell);\n    return [\n      <div class={SELECTION_BORDER_CLASS} style={styles}>\n        {this.isMobileDevice && (\n          <div class=\"range-handlers\">\n            <span class={MOBILE_CLASS}></span>\n            <span class={MOBILE_CLASS}></span>\n          </div>\n        )}\n      </div>,\n    ];\n  }\n\n  private renderEditor() {\n    // Check if edit access\n    const editCell = this.selectionStore.get('edit');\n    // Readonly or Editor closed\n    if (this.readonly || !editCell) {\n      return null;\n    }\n    const enteredOrModelValue =\n      editCell.val ||\n        getCellData(\n          this.columnService.rowDataModel(editCell.y, editCell.x).value\n        );\n    const editable = {\n      ...editCell,\n      ...this.columnService.getSaveData(\n        editCell.y,\n        editCell.x,\n        enteredOrModelValue,\n      ),\n    };\n    const renderEvent = this.beforeEditRender.emit({\n      range: {\n        ...editCell,\n        x1: editCell.x,\n        y1: editCell.y,\n      },\n      ...this.types,\n      rowDimension: { ...this.dimensionRow.state },\n      colDimension: { ...this.dimensionCol.state },\n    });\n\n    // Render prevented\n    if (renderEvent.defaultPrevented) {\n      return null;\n    }\n\n    const cell = getCell(\n      renderEvent.detail.range,\n      renderEvent.detail.rowDimension,\n      renderEvent.detail.colDimension,\n    );\n    const styles = styleByCellProps(cell);\n    return (\n      <revogr-edit\n        style={styles}\n        ref={el => (this.revogrEdit = el)}\n        additionalData={this.additionalData}\n        editCell={editable}\n        saveOnClose={this.applyChangesOnClose}\n        column={this.columnService.rowDataModel(editCell.y, editCell.x)}\n        editor={this.columnService.getCellEditor(\n          editCell.y,\n          editCell.x,\n          this.editors,\n        )}\n        onCloseedit={e => this.closeEdit(e)}\n        onCelledit={e => {\n          const saveEv = this.beforeCellSave.emit(e.detail);\n          if (!saveEv.defaultPrevented) {\n            this.cellEdit(saveEv.detail);\n          }\n\n          // if not clear navigate to next cell after edit\n          if (!saveEv.detail.preventFocus) {\n            this.focusNext();\n          }\n        }}\n      />\n    );\n  }\n\n  render() {\n    const nodes: VNode[] = [];\n    const editCell = this.renderEditor();\n\n    // Editor\n    if (editCell) {\n      nodes.push(editCell);\n    } else {\n      const range = this.selectionStore.get('range');\n      const focus = this.selectionStore.get('focus');\n\n      // Clipboard\n      if ((range || focus) && this.useClipboard) {\n        nodes.push(\n          <revogr-clipboard\n            readonly={this.readonly}\n            onCopyregion={e => this.onCopy(e.detail)}\n            onClearregion={() => !this.readonly && this.clearCell()}\n            ref={e => (this.clipboard = e)}\n            onPasteregion={e => this.onPaste(e.detail)}\n          />,\n        );\n      }\n\n      // Range\n      if (range) {\n        nodes.push(...this.renderRange(range));\n      }\n      // Autofill\n      if (focus && !this.readonly && this.range) {\n        nodes.push(this.autoFillService?.renderAutofill(range, focus));\n      }\n\n      // Order\n      if (this.canDrag) {\n        nodes.push(\n          <revogr-order-editor\n            ref={e => (this.orderEditor = e)}\n            dataStore={this.dataStore}\n            dimensionRow={this.dimensionRow}\n            dimensionCol={this.dimensionCol}\n            parent={this.element}\n            rowType={this.types.rowType}\n            onRowdragstartinit={e => this.rowDragStart(e)}\n          />,\n        );\n      }\n    }\n    return (\n      <Host\n        class={{ mobile: this.isMobileDevice }}\n        onDblClick={(e: MouseEvent) => this.onElementDblClick(e)}\n        onMouseDown={(e: MouseEvent) => this.onElementMouseDown(e)}\n        onTouchStart={(e: TouchEvent) => this.onElementMouseDown(e, true)}\n      >\n        {nodes}\n        <slot name=\"data\" />\n      </Host>\n    );\n  }\n\n  /**\n   * Executes the focus operation on the specified range of cells.\n   */\n  private doFocus(focus: Cell, end: Cell, changes?: Partial<Cell>) {\n    // 1. Trigger beforeFocus event\n    const { defaultPrevented } = this.beforeFocusCell.emit(\n      this.columnService.getSaveData(focus.y, focus.x),\n    );\n    if (defaultPrevented) {\n      return false;\n    }\n    const evData: FocusRenderEvent = {\n      range: {\n        ...focus,\n        x1: end.x,\n        y1: end.y,\n      },\n      next: changes,\n      ...this.types,\n      rowDimension: { ...this.dimensionRow.state },\n      colDimension: { ...this.dimensionCol.state },\n    };\n\n    // 2. Trigger apply focus event\n    const applyEvent = this.applyFocus.emit(evData);\n    if (applyEvent.defaultPrevented) {\n      return false;\n    }\n    const { range } = applyEvent.detail;\n\n    // 3. Trigger focus event\n    return !this.focusCell.emit({\n      focus: {\n        x: range.x,\n        y: range.y,\n      },\n      end: {\n        x: range.x1,\n        y: range.y1,\n      },\n      ...applyEvent.detail,\n    }).defaultPrevented;\n  }\n\n  private triggerRangeEvent(range: RangeArea) {\n    const type = this.types.rowType;\n    // 1. Apply range\n    const applyEvent = this.beforeApplyRange.emit({\n      range: { ...range },\n      ...this.types,\n      rowDimension: { ...this.dimensionRow.state },\n      colDimension: { ...this.dimensionCol.state },\n    });\n    if (applyEvent.defaultPrevented) {\n      return false;\n    }\n    const data = this.columnService.getRangeTransformedToProps(\n      applyEvent.detail.range,\n      this.dataStore,\n    );\n    // 2. Before set range\n    let e = this.beforeSetRange.emit(data);\n    if (e.defaultPrevented) {\n      return false;\n    }\n    // 3. Set range\n    e = this.setRange.emit({ ...applyEvent.detail.range, type });\n    if (e.defaultPrevented) {\n      return false;\n    }\n    return !e.defaultPrevented;\n  }\n\n  /**\n   * Open Editor on DblClick\n   */\n  private onElementDblClick(e: MouseEvent) {\n    // DblClick prevented outside - Editor will not open\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    // Get data from the component\n    const data = this.getData();\n    const focusCell = getFocusCellBasedOnEvent(e, data);\n    if (!focusCell) {\n      return;\n    }\n    this.doEdit();\n  }\n\n  /**\n   * Handle mouse down event on Host element\n   */\n  private onElementMouseDown(e: MouseEvent | TouchEvent, touch = false) {\n    // Get the target element from the event object\n    const targetElement = e.target as HTMLElement | undefined;\n    // Ignore focus if clicked input\n    if (isEditInput(targetElement) || e.defaultPrevented) {\n      return;\n    }\n\n    // Get data from the component\n    const data = this.getData();\n    const focusCell = getFocusCellBasedOnEvent(e, data);\n    if (!focusCell) {\n      return;\n    }\n\n    // Set focus on the current cell\n    this.focus(focusCell, this.range && e.shiftKey);\n\n    // Initiate autofill selection\n    if (this.range) {\n      targetElement &&\n        this.autoFillService?.selectionStart(targetElement, this.getData());\n\n      // Prevent default behavior for mouse events,\n      // but only if target element is not a mobile input\n      if (!touch) {\n        e.preventDefault();\n      } else if (\n        verifyTouchTarget((e as TouchEvent).touches[0], MOBILE_CLASS)\n      ) {\n        // Prevent default behavior for touch events\n        // if target element is a mobile input\n        e.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Start cell editing\n   */\n  protected doEdit(val = '') {\n    if (this.canEdit()) {\n      const focus = this.selectionStore.get('focus');\n      if (!focus) {\n        return;\n      }\n      const data = this.columnService.getSaveData(focus.y, focus.x);\n      this.setEdit?.emit({\n        ...data,\n        val,\n      });\n    }\n  }\n\n  /**\n   * Close editor event triggered\n   * @param details - if it requires focus next\n   */\n  private async closeEdit(e?: CustomEvent<boolean | undefined>) {\n    this.cancelEdit.emit();\n    if (e?.detail) {\n      await this.focusNext();\n    }\n  }\n\n  /**\n   * Edit finished.\n   * Close Editor and save.\n   */\n  protected cellEdit(e: SaveDataDetails) {\n    const dataToSave = this.columnService.getSaveData(e.rgRow, e.rgCol, e.val);\n    this.cellEditApply.emit(dataToSave);\n  }\n\n  private getRegion() {\n    const focus = this.selectionStore.get('focus');\n    let range = this.selectionStore.get('range');\n    if (!range) {\n      range = getRange(focus, focus);\n    }\n    return range;\n  }\n  private onCopy(e: DataTransfer) {\n    const range = this.getRegion();\n    const canCopyEvent = this.beforeCopyRegion.emit(range);\n    if (canCopyEvent.defaultPrevented) {\n      return false;\n    }\n    let rangeData: DataFormat[][] | undefined;\n\n    if (range) {\n      const { data, mapping } = this.columnService.copyRangeArray(\n        range,\n        this.dataStore,\n      );\n      const event = this.rangeClipboardCopy.emit({\n        range,\n        data,\n        mapping,\n        ...this.types,\n      });\n      if (!event.defaultPrevented) {\n        rangeData = event.detail.data;\n      }\n    }\n\n    this.clipboard?.doCopy(e, rangeData);\n    return true;\n  }\n\n  private onPaste(data: string[][]) {\n    const focus = this.selectionStore.get('focus');\n    const isEditing = this.selectionStore.get('edit') !== null;\n    if (!focus || isEditing) {\n      return;\n    }\n    let { changed, range } = this.columnService.getTransformedDataToApply(\n      focus,\n      data,\n    );\n    const { defaultPrevented: canPaste } = this.rangeClipboardPaste.emit({\n      data: changed,\n      models: collectModelsOfRange(changed, this.dataStore),\n      range,\n      ...this.types,\n    });\n\n    if (canPaste) {\n      return;\n    }\n    this.autoFillService?.onRangeApply(changed, range, range);\n  }\n\n  private async focusNext() {\n    const canFocus = await this.keyboardService?.keyChangeSelection(\n      new KeyboardEvent('keydown', {\n        code: codesLetter.ARROW_DOWN,\n      }),\n      this.range,\n    );\n    if (!canFocus) {\n      this.closeEdit();\n    }\n  }\n\n  protected clearCell() {\n    const range = this.selectionStore.get('range');\n    if (range && !isRangeSingleCell(range)) {\n      const data = this.columnService.getRangeStaticData(range, '');\n      this.autoFillService?.onRangeApply(data, range, range);\n    } else if (this.canEdit()) {\n      const focused = this.selectionStore.get('focus');\n      if (!focused) {\n        return;\n      }\n      const cell = this.columnService.getSaveData(focused.y, focused.x);\n      this.cellEdit({\n        rgRow: focused.y,\n        rgCol: focused.x,\n        val: '',\n        type: cell.type,\n        prop: cell.prop,\n      });\n    }\n  }\n\n  private rowDragStart({ detail }: CustomEvent<{ cell: Cell; text: string }>) {\n    detail.text = getCellData(\n      this.columnService.rowDataModel(detail.cell.y, detail.cell.x).value\n    );\n  }\n\n  /**\n   * Verify if edit allowed.\n   */\n  protected canEdit() {\n    if (this.readonly) {\n      return false;\n    }\n    const focus = this.selectionStore.get('focus');\n    return focus && !this.columnService?.isReadOnly(focus.y, focus.x);\n  }\n\n  get edited() {\n    return this.selectionStore.get('edit');\n  }\n\n  /**\n   * Sets the focus on a cell and optionally edits a range.\n   */\n  focus(cell?: Cell, isRangeEdit = false) {\n    if (!cell) return false;\n\n    const end = cell;\n    const start = this.selectionStore.get('focus');\n\n    if (isRangeEdit && start) {\n      const range = getRange(start, end);\n      if (range) {\n        return this.triggerRangeEvent(range);\n      }\n    }\n\n    return this.doFocus(cell, end);\n  }\n\n  get types(): AllDimensionType {\n    return {\n      rowType: this.dataStore.get('type'),\n      colType: this.columnService.type,\n    };\n  }\n\n  /**\n   * Collect data\n   */\n  protected getData(): EventData {\n    return {\n      el: this.element,\n      rows: this.dimensionRow.state,\n      cols: this.dimensionCol.state,\n      lastCell: this.lastCell,\n      focus: this.selectionStore.get('focus'),\n      range: this.selectionStore.get('range'),\n      edit: this.selectionStore.get('edit'),\n    };\n  }\n}\n","import type { VNode } from '@stencil/core';\nimport type { HyperFunc } from '@type';\n\ntype HeaderRender = {\n  (start: number): (h: HyperFunc<VNode>, e: { rowIndex: number }) => number;\n};\nexport const RowHeaderRender: HeaderRender = s => (__, { rowIndex: i }) => s + i;\n","import { h, Host, Component, Prop, Event, EventEmitter } from '@stencil/core';\nimport { JSXBase } from '@stencil/core/internal';\n\nimport { ViewportStore, DataStore } from '@store';\n\nimport { ROW_HEADER_TYPE } from '../../utils/consts';\nimport { RowHeaderRender } from './row-header-render';\nimport { calculateRowHeaderSize } from '../../utils/row-header-utils';\nimport { HEADER_SLOT } from '../revoGrid/viewport.helpers';\nimport {\n  RowHeaders,\n  ViewPortScrollEvent,\n  DataType,\n  ColumnRegular,\n  ViewportData,\n  ElementScroll,\n  DimensionRows,\n  DimensionCols,\n} from '@type';\nimport { type JSX } from '../../components';\n\n/**\n * Row headers component\n * Visible on the left side of the table\n */\n\n@Component({ tag: 'revogr-row-headers' })\nexport class RevogrRowHeaders {\n  // #region Properties\n  /**\n   * Header height to setup row headers\n   */\n  @Prop() height: number;\n\n  /**\n   * Viewport data\n   */\n  @Prop() dataPorts: ViewportData[];\n  /**\n   * Header props\n   */\n  @Prop() headerProp: Record<string, any>;\n\n  /**\n   * Row class\n   */\n  @Prop() rowClass: string;\n\n  /**\n   * Enable resize\n   */\n  @Prop() resize: boolean;\n  /**\n   * Row header column\n   */\n  @Prop() rowHeaderColumn: RowHeaders;\n  /**\n   * Additional data to pass to renderer\n   */\n  @Prop() additionalData: any;\n  /**\n   * Prevent rendering until job is done.\n   * Can be used for initial rendering performance improvement.\n   * When several plugins require initial rendering this will prevent double initial rendering.\n   */\n  @Prop() jobsBeforeRender: Promise<any>[] = [];\n  // #endregion\n\n  /**\n   * Scroll viewport\n   */\n  @Event({ eventName: 'scrollview', bubbles: false })\n  scrollViewport: EventEmitter<ViewPortScrollEvent>;\n  /**\n   * Register element to scroll\n   */\n  @Event({ eventName: 'ref', bubbles: false })\n  elementToScroll: EventEmitter<ElementScroll>;\n\n  render() {\n    const dataViews: HTMLElement[] = [];\n    const viewport = new ViewportStore('colPinStart');\n\n    /** render viewports rows */\n    let totalLength = 1;\n    // todo: this part could be optimized to avoid to often re-render dataPorts can be cached\n    for (let data of this.dataPorts) {\n      const itemCount = data.dataStore.get('items').length;\n\n      // initiate row data\n      const dataStore = new DataStore<DataType, DimensionRows>(data.type, {\n        ...data.dataStore.state,\n      });\n\n      // initiate column data\n      const colData = new DataStore<ColumnRegular, DimensionCols>(\n        'colPinStart',\n      );\n      const column: ColumnRegular = {\n        cellTemplate: RowHeaderRender(totalLength),\n        ...this.rowHeaderColumn,\n      };\n      colData.updateData([column]);\n      dataViews.push(\n        <revogr-data\n          {...data}\n          colType=\"rowHeaders\"\n          jobsBeforeRender={this.jobsBeforeRender}\n          rowClass={this.rowClass}\n          dataStore={dataStore.store}\n          colData={colData.store}\n          viewportCol={viewport.store}\n          readonly={true}\n          range={false}\n        />,\n      );\n      totalLength += itemCount;\n    }\n\n    const colSize = calculateRowHeaderSize(totalLength, this.rowHeaderColumn);\n    viewport.setViewport({\n      realCount: 1,\n      virtualSize: 0,\n      items: [\n        {\n          size: colSize,\n          start: 0,\n          end: colSize,\n          itemIndex: 0,\n        },\n      ],\n    });\n\n    const viewportScroll: JSX.RevogrViewportScroll &\n      JSXBase.HTMLAttributes<HTMLRevogrViewportScrollElement> = {\n      contentHeight: this.height,\n      contentWidth: 0,\n      style: { minWidth: `${colSize}px` },\n      colType: 'rowHeaders',\n      ref: (el) => this.elementToScroll.emit(el),\n      onScrollviewport: (e: CustomEvent) => this.scrollViewport.emit(e.detail),\n    };\n    const viewportHeader: JSX.RevogrHeader & { slot: string } = {\n      ...this.headerProp,\n      colData:\n        typeof this.rowHeaderColumn === 'object' ? [this.rowHeaderColumn] : [],\n      viewportCol: viewport.store,\n      canResize: false,\n      type: ROW_HEADER_TYPE,\n      // parent,\n      slot: HEADER_SLOT,\n    };\n    return (\n      <Host class={{ [ROW_HEADER_TYPE]: true }} key={ROW_HEADER_TYPE}>\n        <revogr-viewport-scroll {...viewportScroll} row-header={true}>\n          <revogr-header {...viewportHeader} />\n          {dataViews}\n        </revogr-viewport-scroll>\n      </Host>\n    );\n  }\n}\n","\n\n/**\n * Autohide scroll for MacOS when scroll is visible only for 1 sec\n */\nexport class AutohideScrollPlugin {\n  private autohideScrollTimeout = 0;\n  constructor(private element: HTMLElement) {\n  }\n\n  /**\n   * When scroll size updates set it up for autohide\n   */\n  setScrollSize(s: number) {\n    if (!s) {\n      this.element.setAttribute('autohide', 'true');\n    } else {\n      this.element.removeAttribute('autohide');\n    }\n  }\n\n  /**\n   * On each scroll check if it's time to show\n   */\n  checkScroll({\n    scrollSize,\n    contentSize,\n    virtualSize,\n  }: {\n    scrollSize: number;\n    contentSize: number;\n    virtualSize: number;\n  }) {\n    const hasScroll = contentSize > virtualSize;\n    const isHidden = !scrollSize && hasScroll;\n    if (isHidden) {\n      this.element.setAttribute('visible', 'true');\n      this.autohideScrollTimeout = this.show(\n        this.element,\n        this.autohideScrollTimeout,\n      );\n    }\n  }\n\n  private show(element?: HTMLElement, timeout?: number): number {\n    clearTimeout(timeout);\n    return Number(\n      setTimeout(() => {\n        element?.removeAttribute('visible');\n      }, 1000),\n    );\n  }\n  clear() {\n    clearTimeout(this.autohideScrollTimeout);\n  }\n}\n","revogr-scroll-virtual {\n  $min-size: 20px;\n\n  // show scroll only for 1 sec\n  &[autohide] {\n    position: absolute;\n    z-index: 100 !important;\n\n    &.vertical {\n      top: 0;\n      right: 0;\n\n      &[visible] {\n        min-width: $min-size !important;\n      }\n    }\n\n    &.horizontal {\n      bottom: 0;\n      left: 0;\n\n      &[visible] {\n        min-height: $min-size !important;\n      }\n    }\n  }\n\n  &.vertical {\n    overflow-y: auto;\n    overflow-x: hidden;\n    height: 100%;\n\n    > div {\n      width: 1px;\n    }\n  }\n\n  &.horizontal {\n    overflow-x: auto;\n    overflow-y: hidden;\n    width: 100%;\n\n    > div {\n      height: 1px;\n    }\n  }\n}\n","import {\n  Component,\n  Element as StencilElement,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Method,\n  Prop,\n} from '@stencil/core';\nimport LocalScrollService, { getContentSize } from '../../services/local.scroll.service';\nimport type {\n  DimensionType,\n  ViewportState,\n  DimensionSettingsState,\n  ViewPortScrollEvent,\n} from '@type';\nimport { AutohideScrollPlugin } from './autohide-scroll.plugin';\nimport { LocalScrollTimer } from '../../services/local.scroll.timer';\nimport { type Observable, getScrollbarSize } from '../../utils';\n\n/**\n * Virtual scroll component\n */\n@Component({\n  tag: 'revogr-scroll-virtual',\n  styleUrl: 'revogr-scroll-style.scss',\n})\nexport class RevogrScrollVirtual {\n  /**\n   * Scroll dimension (`X` - `rgCol` or `Y` - `rgRow`)\n   */\n  @Prop() dimension: DimensionType = 'rgRow';\n\n  /**\n   * Viewport\n   */\n  @Prop() viewportStore!: Observable<ViewportState>;\n  /**\n   * Dimensions\n   */\n  @Prop() dimensionStore!: Observable<DimensionSettingsState>;\n\n  /**\n   * Scroll event\n   */\n  @Event({ eventName: 'scrollvirtual' })\n  scrollVirtual: EventEmitter<ViewPortScrollEvent>;\n\n  @StencilElement() element: HTMLElement;\n  private autohideScrollPlugin: AutohideScrollPlugin;\n  private scrollSize = 0;\n  private localScrollService: LocalScrollService;\n  private localScrollTimer: LocalScrollTimer;\n\n  @Method()\n  async setScroll(e: ViewPortScrollEvent): Promise<void> {\n    if (this.dimension !== e.dimension) {\n      return;\n    }\n    this.localScrollTimer.latestScrollUpdate(e.dimension);\n    this.localScrollService?.setScroll(e);\n    if (e.coordinate) {\n      this.autohideScrollPlugin.checkScroll({\n        scrollSize: this.scrollSize,\n        contentSize: this.dimensionStore.get('realSize'),\n        virtualSize: this.viewportStore.get('virtualSize'),\n      });\n    }\n  }\n\n  /**\n   * Update if `delta` exists in case we don't know current position or if it's external change\n   */\n  @Method()\n  async changeScroll(e: ViewPortScrollEvent): Promise<ViewPortScrollEvent> {\n    if (e.delta) {\n      switch (e.dimension) {\n        case 'rgCol':\n          e.coordinate = this.element.scrollLeft + e.delta;\n          break;\n        case 'rgRow':\n          e.coordinate = this.element.scrollTop + e.delta;\n          break;\n      }\n      this.setScroll(e);\n    }\n    return e;\n  }\n\n  set size(s: number) {\n    this.autohideScrollPlugin.setScrollSize(s);\n    if (this.dimension === 'rgRow') {\n      this.element.style.minWidth = `${s}px`;\n      return;\n    }\n    this.element.style.minHeight = `${s}px`;\n  }\n\n  get size(): number {\n    if (this.dimension === 'rgRow') {\n      return this.element.clientHeight;\n    }\n    return this.element.clientWidth;\n  }\n\n  connectedCallback() {\n    this.autohideScrollPlugin = new AutohideScrollPlugin(this.element);\n    this.localScrollTimer = new LocalScrollTimer('ontouchstart' in document.documentElement ? 0 : 10);\n    this.localScrollService = new LocalScrollService({\n      runScroll: e => this.scrollVirtual.emit(e),\n      applyScroll: e => {\n        this.localScrollTimer.setCoordinate(e);\n        const type = e.dimension === 'rgRow' ? 'scrollTop' : 'scrollLeft';\n        // this will trigger on scroll event\n        this.element[type] = e.coordinate;\n      },\n    });\n  }\n\n  disconnectedCallback() {\n    this.autohideScrollPlugin.clear();\n  }\n\n  componentWillLoad() {\n    this.scrollSize = getScrollbarSize(document);\n  }\n\n  componentDidRender() {\n    const type = this.dimension === 'rgRow' ? 'scrollHeight' : 'scrollWidth';\n    if (this.element[type] > this.size) {\n      this.size = this.scrollSize;\n    } else {\n      this.size = 0;\n    }\n    this.localScrollService.setParams(\n      {\n        contentSize: this.dimensionStore.get('realSize'),\n        clientSize: this.size,\n        virtualSize: this.viewportStore.get('clientSize'),\n      },\n      this.dimension,\n    );\n  }\n\n  onScroll(e: MouseEvent) {\n    if (!(e.target instanceof Element)) {\n      return;\n    }\n    const target = e.target;\n    let type: 'scrollLeft' | 'scrollTop' = 'scrollLeft';\n    if (this.dimension === 'rgRow') {\n      type = 'scrollTop';\n    }\n    // apply after throttling\n    if (this.localScrollTimer.isReady(this.dimension, target[type] || 0)) {\n      this.localScrollService?.scroll(target[type] || 0, this.dimension);\n    }\n  }\n\n  render() {\n    const sizeType = this.dimension === 'rgRow' ? 'height' : 'width';\n    const size = getContentSize(\n      this.dimensionStore.get('realSize'),\n      this.size,\n      this.viewportStore.get('clientSize') // content viewport size\n    );\n    return (\n      <Host onScroll={(e: MouseEvent) => this.onScroll(e)}>\n        <div\n          style={{\n            [sizeType]: `${size}px`,\n          }}\n        />\n      </Host>\n    );\n  }\n}\n",".temp-bg-range {\n  display: block !important;\n  position: absolute;\n  pointer-events: none;\n  z-index: 9;\n  border: 1px solid rgb(255, 94, 0);\n  box-sizing: border-box;\n\n  &.Selection {\n    border: 1px dashed gray;\n  }\n\n  > div {\n    width: 1px;\n    height: 1px;\n    position: absolute;\n\n    &.top {\n      top: -1px;\n    }\n\n    &.bottom {\n      bottom: -1px;\n    }\n\n    &.left {\n      left: -1px;\n    }\n\n    &.right {\n      right: -1px;\n    }\n  }\n}\n","import { Component, Prop, h, Host } from '@stencil/core';\nimport throttle from 'lodash/throttle';\nimport { TMP_SELECTION_BG_CLASS } from '../../utils/consts';\nimport { getCell, styleByCellProps } from '../overlay/selection.utils';\nimport { DimensionSettingsState, SelectionStoreState, RangeArea } from '@type';\nimport type { Observable } from '../../utils';\n\n/**\n * Temporary range selection component. Shows temporary range selection.\n */\n@Component({\n  tag: 'revogr-temp-range',\n  styleUrl: 'revogr-temp-range-style.scss',\n})\nexport class RevogrFocus {\n  /**\n   * Dynamic stores\n   */\n\n  /**\n   * Selection store, shows current selection and focus\n   */\n  @Prop() selectionStore: Observable<SelectionStoreState>;\n\n  /**\n   * Dimension row store\n   */\n  @Prop() dimensionRow: Observable<DimensionSettingsState>;\n  /**\n   * Dimension column store\n   */\n  @Prop() dimensionCol: Observable<DimensionSettingsState>;\n\n  el?: HTMLElement;\n  private readonly onChange = throttle((e: HTMLElement) => this.doChange(e), 300);\n\n  private doChange(e: HTMLElement) {\n    e?.scrollIntoView({\n      block: 'nearest',\n      inline: 'nearest',\n    });\n  }\n\n  componentDidRender() {\n    if (this.el) {\n      this.onChange(this.el);\n    }\n  }\n\n  render() {\n    const data = this.selectionStore.get('tempRange');\n    const type = this.selectionStore.get('tempRangeType');\n    if (!data) {\n      return;\n    }\n    let directionY = 'bottom';\n    let derectionX = 'right';\n    const range = this.getRange();\n    if (!range) {\n      return;\n    }\n    if (data.y < range.y) {\n      directionY = 'top';\n    }\n    if (data.x < range.x) {\n      derectionX = 'left';\n    }\n    const directionClass = `${derectionX} ${directionY}`;\n    const cell = getCell(data,\n      this.dimensionRow.state,\n      this.dimensionCol.state\n    );\n    const styles = styleByCellProps(cell);\n    const props = {\n      class: {\n        [TMP_SELECTION_BG_CLASS]: true,\n        [type || '']: true,\n      },\n      style: styles,\n      hidden: false\n    };\n    return (\n      <Host {...props}>\n        <div class={directionClass} ref={(e) => (this.el = e)} />\n      </Host>\n    );\n  }\n\n  private getRange(): RangeArea | null {\n    const range = this.selectionStore.get('range');\n    if (range) {\n      return range;\n    }\n    const focus = this.selectionStore.get('focus');\n    if (!focus) {\n      return null;\n    }\n    return {\n      ...focus,\n      x1: focus.x,\n      y1: focus.y,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]}