{"version":3,"names":["recalculateRealSizePlugin","storeService","set","k","realSize","count","store","get","i","setStore","trimmedPlugin","trimmingObject","trimmedPreviousSizes","key","val","trim","removeMultipleAndShift","setSizes","items","toRemove","newItems","sortedIndexes","Object","keys","map","Number","sort","a","b","lastIndex","length","shift","undefined","initialBase","indexes","trimmed","sizes","positionIndexToItem","indexToItem","positionIndexes","initialState","assign","originItemSize","DimensionStore","constructor","type","this","createStore","use","setDimensionSize","bind","getCurrentState","state","reduce","r","data","dispose","drop","dimensionData","calculateDimensionData","updateSizesPositionByIndexes","newItemsOrder","prevItemsOrder","customSizes","originalIndices","forEach","physIndex","virtIndex","push","newSizes","indices","originalIndex","rowTypes","columnTypes","isRowType","indexOf","BasePlugin","revogrid","providers","h","subscriptions","addEventListener","eventName","callback","watch","prop","immediate","nativeValueDesc","getOwnPropertyDescriptor","prototype","defineProperty","keepDefault","_a","call","value","removeEventListener","emit","detail","event","CustomEvent","cancelable","dispatchEvent","clearSubscriptions","destroy","arrayEach","array","iteratee","index","castFunction","identity","collection","func","isArray","baseEach","LETTER_BLOCK_SIZE","ColumnAutoSizeMode","AutoSizeColumnPlugin","config","super","autoSizeColumns","dataResolve","dataReject","letterBlockSize","preciseSize","precsizeCalculationArea","initiatePresizeElement","appendChild","aftersourceset","source","setSource","afteredit","afterEditAll","beforecolumnsset","columns","columnSet","headerDblClick","getColumnType","column","size","getColumnSize","dimension","setCustomSizes","mode","autoSizeOnTextOverlap","autoSizeAll","autoSize","clearPromise","request","Promise","resolve","reject","e","each","_v","rgCol","prev","rgRow","Math","max","getLength","name","len","padding","str","toString","innerText","scrollWidth","isRangeEdit","props","p","_b","stores","s","perStore","_row","item","getSourceItem","t","cols","allColumns","parseInt","styleForFontTest","position","fontSize","height","width","whiteSpace","top","overflowX","el","document","createElement","style","classList","add","remove","StretchColumn","stretchedColumn","scrollSize","getScrollbarSize","beforecolumnapplied","applyStretch","setScroll","hasScroll","initialSize","apply","dropChanges","activateChanges","sizeDifference","clientWidth","_","rowHeaders","itemsLength","header","rowHeaderSize","calculateRowHeaderSize","last","colSize","isStretchPlugin","plugin","baseClamp","number","lower","upper","MAX_ARRAY_LENGTH","toLength","toInteger","baseFill","start","end","fill","isIterateeCall","INITIAL","mime","fileKind","bom","columnDelimiter","rowDelimiter","encoding","CARRIAGE_RETURN","String","fromCharCode","LINE_FEED","DOUBLE_QT","NO_BREAK_SPACE","escapeRegex","RegExp","ExportCsv","options","doExport","headers","result","prepareHeader","isGrouping","parseCell","getGroupingName","join","columnHeaders","newColumnHeaders","v","force","escape","JSON","stringify","toEscape","some","replace","ExportTypes","ExportFilePlugin","exportString","csv","beforeexport","formatter","exportBlob","getBlob","exportFile","URL","window","webkitURL","filename","blob","url","createObjectURL","display","setAttribute","MouseEvent","removeChild","timeout","revokeObjectURL","Blob","getData","defaultPrevented","getSource","colSource","colPromises","getColPerSource","then","all","getColumnStore","virtualIndexes","depth","groups","colNames","colProps","visibleItems","virtualIndex","rows","getGroupHeaders","template","Array","d","levelGroups","group","minIndex","findGroupStartIndex","ids","min","id","current","promisesData","dataPart","promise","getVisibleSource","Error","eq","extra","filterVal","toLocaleLowerCase","notEq","gtThan","conditionValue","parseFloat","gtThanEq","gt","lt","lsEq","notSet","beginsWith","contains","toLowerCase","notContains","filterCoreFunctionsIndexedByType","none","empty","notEmpty","begins","eqN","neqN","gte","lte","filterTypes","string","filterNames","FILTER_TRIMMED_TYPE","FILTER_CONFIG_CHANGED_EVENT","FILTE_PANEL","FilterPlugin","filterCollection","multiFilterItems","filterByType","filterNameIndexByType","filterFunctionsIndexedByType","filterProp","FILTER_PROP","initConfig","existingNodes","registerVNode","filter","n","$tag$","filterEntities","filterCaptions","localization","captions","onFilterChange","onResetChange","onFilterReset","disableDynamicFiltering","ref","pop","extraContent","async","filterCollectionProps","relation","runFiltering","headerclick","clearFiltering","beforeshow","customFilters","customFilterType","cFilter","columnFilterType","cfgInlcude","include","filters","newTypes","f","filtersWithFilterFunctionPresent","entries","fromEntries","originalEvent","target","isFilterBtn","preventDefault","gridPos","getBoundingClientRect","buttonPos","x","y","autoCorrect","getColumnFilter","filterItems","extraHyperContent","show","filterType","isValidType","multiType","doFiltering","columnsToUpdate","columnByProp","hasFilter","itemsToTrim","getRowFilter","itemsToFilter","isAddedEvent","addTrimmed","updateColumns","filterProps","firstFilterItem","getColumns","propKeys","rowIndex","shouldTrimRow","propFilters","model","propFilterSatisfiedCount","lastFilterResults","filterIndex","filterData","filterFunc","getCellDataParsed","isFinalAndFilter","allAndConditionsSatisfied","nextFilter","pendingResults","includes","doCollapse","pIndex","collapseValue","PSEUDO_GROUP_ITEM_VALUE","total","currentModel","currentValue","startsWith","GROUP_EXPANDED","doExpand","vIndex","rowItemsIndexes","physicalIndex","currentGroup","getParsedGroup","PSEUDO_GROUP_ITEM_ID","groupItems","groupLevelOnly","isGroup","isSameGroup","GROUP_DEPTH","splice","TRIMMED_GROUPING","processDoubleConversionTrimmed","initiallyTrimed","firstLevelMap","secondLevelMap","trimemedOptionsToUpgrade","initialIndex","newConversionIndex","stringTag","isString","isObjectLike","baseGetTag","asciiSize","baseProperty","asciiSize$1","rsAstralRange","rsComboMarksRange","reComboHalfMarksRange","rsComboSymbolsRange","rsComboRange","rsVarRange","rsZWJ","reHasUnicode","hasUnicode","test","rsAstral","rsCombo","rsFitz","rsModifier","rsNonAstral","rsRegional","rsSurrPair","reOptMod","rsOptVar","rsOptJoin","rsSeq","rsSymbol","reUnicode","unicodeSize","stringSize","mapTag","setTag","isArrayLike","tag","getTag","baseKeys","sortIndexByItems","sortingFunc","itemA","itemB","cmp","sorted","SortingPlugin","runSorting","order","comparison","ignoreViewportUpdate","sortingPromise","postponeSort","debounce","setConfig","cfg","col","getComparer","sorting","startSorting","beforeEvent","getColumnByProp","sortable","_d","_c","shiftKey","jobsBeforeRender","cellCmp","cellCompare","defaultCellCompare","descCellCompare","additive","getNextOrder","newCol","updateColumnSorting","beforeApplyEvent","types","proxyItems","from","updateSizesPositionByNewDataIndexes","setData","prevItems","aRaw","getCellRaw","bRaw","av","bv","currentOrder","GroupingRowPlugin","getStore","GROUPING_ROW_TYPE","onFocus","onExpand","newTrimmed","getPhysical","isExpanded","getExpanded","setItems","clearFocus","setColumnGrouping","PSEUDO_GROUP_COLUMN","setColumns","onDrag","to","isDown","beforeTrimmedApply","isSortingRunning","sortingPlugin","plugins","getByClass","subscribe","onDataSet","trimmedType","doSourceUpdate","prevExpanded","oldNewIndexes","expanded","sourceWithGroups","oldNewIndexMap","childrenByGroup","gatherGrouping","customRenderer","groupLabelTemplate","disableVirtualY","updateTrimmed","preservedExpanded","preserveGroupingOnUpdate","grouping","setGrouping","clearGrouping","refreshByType","deleted","c","isGroupingColumn","trimmedGroup","_childrenByGroup","COLUMN_DRAG_CLASS","ColumnOrderHandler","offset","renderAutoscroll","parent","autoscrollEl","autoscroll","pos","dataContainerSize","direction","helperOffset","maxScroll","transform","scrollIntoView","block","inline","dataEl","gridRect","scrollEl","gridEl","dir","scrollContainerRect","stop","element","hidden","showHandler","render","COLUMN_CLICK","ON_COLUMN_CLICK","MOVE","DRAG_END","BEFORE_DRAG_END","DRAG_START","ColumnMovePlugin","moveFunc","doMove","staticDragData","dragData","localSubscriptions","orderUi","onMouseOut","onMouseUp","move","dragStart","dispatch","clearOrder","mouseleave","mouseup","mousemove","closest","isColGrouping","getDimension","pin","elRect","startItem","getItemByPosition","getLeftRelative","left","startPos","abs","scrollOffset","itemIndex","relativePos","newPosition","stopDrag","startPosition","newItem","toMove","clearLocalSubscriptions","absoluteX"],"sources":["src/store/dimension/dimension.recalculate.plugin.ts","src/store/dimension/dimension.trim.plugin.ts","src/store/dimension/dimension.store.ts","src/store/index.ts","src/plugins/base.plugin.ts","node_modules/lodash/_arrayEach.js","node_modules/lodash/_castFunction.js","node_modules/lodash/forEach.js","src/plugins/column.auto-size.plugin.ts","src/plugins/column.stretch.plugin.ts","node_modules/lodash/_baseClamp.js","node_modules/lodash/toLength.js","node_modules/lodash/_baseFill.js","node_modules/lodash/fill.js","src/plugins/export/csv.ts","src/plugins/export/export.plugin.ts","src/plugins/filter/conditions/equal.ts","src/plugins/filter/conditions/number/greaterThan.ts","src/plugins/filter/conditions/number/greaterThanOrEqual.ts","src/plugins/filter/conditions/number/lessThan.ts","src/plugins/filter/conditions/number/lessThanOrEqual.ts","src/plugins/filter/conditions/set.ts","src/plugins/filter/conditions/string/beginswith.ts","src/plugins/filter/conditions/string/contains.ts","src/plugins/filter/filter.indexed.ts","src/plugins/filter/filter.plugin.tsx","src/plugins/groupingRow/grouping.row.expand.service.ts","src/plugins/groupingRow/grouping.trimmed.service.ts","node_modules/lodash/isString.js","node_modules/lodash/_asciiSize.js","node_modules/lodash/_hasUnicode.js","node_modules/lodash/_unicodeSize.js","node_modules/lodash/_stringSize.js","node_modules/lodash/size.js","src/plugins/sorting/sorting.func.ts","src/plugins/sorting/sorting.plugin.ts","src/plugins/groupingRow/grouping.row.plugin.ts","src/plugins/moveColumn/order-column.handler.tsx","src/plugins/moveColumn/column.drag.plugin.ts"],"sourcesContent":["import { DimensionSettingsState } from '@type';\nimport type { Observable, PluginSubscribe } from '../../utils';\n\n/**\n * Plugin which recalculates realSize on changes of sizes, originItemSize and count\n */\nexport const recalculateRealSizePlugin = (storeService: {\n  store: Observable<DimensionSettingsState>;\n  setStore: (k: Partial<DimensionSettingsState>) => void;\n}): PluginSubscribe<DimensionSettingsState> => {\n  /**\n   * Recalculates realSize if size, origin size or count changes\n   */\n  return {\n    /**\n     * Reacts on changes of count, sizes and originItemSize\n     */\n    set(k) {\n      switch (k) {\n        case 'count':\n        case 'sizes':\n        case 'originItemSize': {\n          // recalculate realSize\n          let realSize = 0;\n          const count = storeService.store.get('count');\n          for (let i = 0; i < count; i++) {\n            realSize +=\n              storeService.store.get('sizes')[i] ||\n              storeService.store.get('originItemSize');\n          }\n          storeService.setStore({ realSize });\n          break;\n        }\n      }\n    },\n  };\n};\n","import { DimensionSettingsState } from '@type';\nimport type { Observable, PluginSubscribe } from '../../utils';\n/**\n * Plugin for trimming\n *\n * 1.a. Retrieves the previous sizes value. Saves the resulting trimmed data as a new sizes value.\n * 1.b. Stores a reference to the trimmed data to prevent further changes.\n * 2. Removes multiple and shifts the data based on the trimmed value.\n */\nexport const trimmedPlugin = (storeService: {\n  store: Observable<DimensionSettingsState>;\n  setSizes: (k: DimensionSettingsState['sizes']) => void;\n}): PluginSubscribe<DimensionSettingsState> => {\n  let trimmingObject: DimensionSettingsState['sizes'] | null = null;\n  let trimmedPreviousSizes: DimensionSettingsState['sizes'] | null = null;\n\n  return {\n    set(key, val) {\n      switch (key) {\n        case 'sizes': {\n          // prevent changes after trimming\n          if (trimmingObject && trimmingObject === val) {\n            trimmingObject = null;\n            return;\n          }\n          trimmedPreviousSizes = null;\n          break;\n        }\n        case 'trimmed': {\n          const trim = val as DimensionSettingsState['trimmed'];\n          if (!trimmedPreviousSizes) {\n            trimmedPreviousSizes = storeService.store.get('sizes');\n          }\n\n          trimmingObject = removeMultipleAndShift(\n            trimmedPreviousSizes,\n            trim || {},\n          );\n          // save a reference to the trimmed object to prevent changes after trimming\n          storeService.setSizes(trimmingObject);\n          break;\n        }\n      }\n    },\n  };\n};\n\nfunction removeMultipleAndShift<T1, T2>(\n  items: { [virtialIndex: number]: T1 },\n  toRemove: { [virtialIndex: number]: T2 },\n): { [virtialIndex: number]: T1 } {\n  const newItems: { [virtialIndex: number]: T1 } = {};\n  const sortedIndexes = Object.keys(items || {})\n    .map(Number)\n    .sort((a, b) => a - b);\n  const lastIndex = sortedIndexes[sortedIndexes.length - 1];\n  let shift = 0;\n  for (let i = 0; i <= lastIndex; i++) {\n    if (toRemove[i] !== undefined) {\n      shift++;\n\n      // skip already removed\n      if (items[i] !== undefined) {\n        continue;\n      }\n    }\n    if (items[i] !== undefined) {\n      newItems[i - shift] = items[i];\n    }\n  }\n  return newItems;\n}\n","/**\n * Storing pre-calculated\n * Dimension information and sizes\n */\nimport reduce from 'lodash/reduce';\nimport { createStore } from '@stencil/store';\n\nimport { setStore, Observable } from '../../utils';\nimport { calculateDimensionData } from './dimension.helpers';\nimport {\n  DimensionCalc,\n  DimensionSettingsState,\n  ViewSettingSizeProp,\n  MultiDimensionType,\n} from '@type';\nimport { recalculateRealSizePlugin } from './dimension.recalculate.plugin';\nimport { trimmedPlugin } from './dimension.trim.plugin';\n\nexport type DimensionStoreCollection = {\n  [T in MultiDimensionType]: DimensionStore;\n};\n\ntype Item = keyof DimensionSettingsState;\n\nfunction initialBase(): DimensionCalc {\n  return {\n    indexes: [],\n    count: 0,\n\n    // hidden items\n    trimmed: null,\n\n    // virtual item index to size\n    sizes: {},\n    // order in indexes[] to coordinate\n    positionIndexToItem: {},\n    // initial element to coordinate ^\n    indexToItem: {},\n    positionIndexes: [],\n  };\n}\n\nfunction initialState(): DimensionSettingsState {\n  return {\n    ...initialBase(),\n    // size which all items can take\n    realSize: 0,\n\n    // initial item size if it wasn't changed\n    originItemSize: 0,\n  };\n}\n\nexport class DimensionStore {\n  readonly store: Observable<DimensionSettingsState>;\n  constructor(public readonly type: MultiDimensionType) {\n    this.store = createStore(initialState());\n    this.store.use(trimmedPlugin({\n      store: this.store,\n      setSizes: this.setDimensionSize.bind(this),\n    }));\n    this.store.use(recalculateRealSizePlugin({\n      store: this.store,\n      setStore: this.setStore.bind(this),\n    }));\n  }\n\n  getCurrentState(): DimensionSettingsState {\n    const state = initialState();\n    const keys = Object.keys(state);\n    return reduce(\n      keys,\n      (r: DimensionSettingsState, k: Item) => {\n        const data = this.store.get(k);\n        r[k] = data as never;\n        return r;\n      },\n      state,\n    );\n  }\n\n  dispose() {\n    setStore(this.store, initialState());\n  }\n\n  setStore<T extends Record<string, any>>(data: Partial<T>) {\n    setStore(this.store, data);\n  }\n\n  drop() {\n    setStore(this.store, initialBase());\n  }\n\n  /**\n   * Set custom dimension sizes and overwrite old\n   * Generates new indexes based on sizes\n   * @param sizes - sizes to set\n   */\n  setDimensionSize(sizes: ViewSettingSizeProp = {}) {\n    const dimensionData = calculateDimensionData(\n      this.store.get('originItemSize'),\n      sizes,\n    );\n    setStore(this.store, {\n      ...dimensionData,\n      sizes,\n    });\n  }\n\n  updateSizesPositionByIndexes(newItemsOrder: number[], prevItemsOrder: number[] = []) {\n    // Move custom sizes to new order\n    const customSizes = {...this.store.get('sizes')};\n    if (!Object.keys(customSizes).length) {\n      return;\n    }\n    // Step 1: Create a map of original indices, but allow duplicates by storing arrays of indices\n    const originalIndices: Record<number, number[]> = {};\n    prevItemsOrder.forEach((physIndex, virtIndex) => {\n      if (!originalIndices[physIndex]) {\n        originalIndices[physIndex] = [];\n      }\n      originalIndices[physIndex].push(virtIndex); // Store all indices for each value\n    });\n\n    // Step 2: Create new sizes based on new item order\n    const newSizes: Record<number, number> = {};\n\n    newItemsOrder.forEach((physIndex, virtIndex) => {\n      const indices = originalIndices[physIndex]; // Get all original indices for this value\n      \n      if (indices && indices.length > 0) {\n        const originalIndex = indices.shift(); // Get the first available original index\n\n        if (originalIndex !== undefined && originalIndex !== virtIndex && customSizes[originalIndex]) {\n          newSizes[virtIndex] = customSizes[originalIndex];\n          delete customSizes[originalIndex];\n        }\n      }\n    });\n\n    // Step 3: Set new sizes if there are changes\n    if (Object.keys(newSizes).length) {\n      this.setDimensionSize({\n        ...customSizes,\n        ...newSizes,\n      });\n    }\n  }\n}\n","import type { DimensionCols, DimensionRows } from '@type';\n\nexport * from './dataSource';\nexport * from './dimension';\nexport * from './selection';\nexport * from './vp';\n\nexport const rowTypes: DimensionRows[] = ['rowPinStart', 'rgRow', 'rowPinEnd'];\nexport const columnTypes: DimensionCols[] = [\n  'colPinStart',\n  'rgCol',\n  'colPinEnd',\n];\n\nexport function isRowType(type: DimensionRows | any): type is DimensionRows {\n  return rowTypes.indexOf(type) > -1;\n}\n","import { h } from '@stencil/core';\nimport type { PluginProviders, PluginBaseComponent, RevoGridCustomEvent } from '..';\n\n\nexport type WatchConfig = { immediate: boolean };\n\n/**\n * Base layer for plugins\n * Provide minimal starting core for plugins to work\n * Extend this class to create plugin\n */\nexport class BasePlugin implements PluginBaseComponent {\n  readonly h = h;\n  readonly subscriptions: Record<string, (...args: any[]) => void> = {};\n  constructor(public revogrid: HTMLRevoGridElement, public providers: PluginProviders) {}\n  /**\n   *\n   * @param eventName - event name to subscribe to in revo-grid component (e.g. 'beforeheaderclick')\n   * @param callback - callback function for event\n   */\n  addEventListener<K extends keyof HTMLRevoGridElementEventMap>(\n    eventName: K,\n    callback: (this: BasePlugin, e: RevoGridCustomEvent<HTMLRevoGridElementEventMap[K]>) => void,\n  ) {\n    this.revogrid.addEventListener(eventName as string, callback);\n    this.subscriptions[eventName as string] = callback;\n  }\n\n  /**\n   * Subscribe to property change in revo-grid component\n   * You can return false in callback to prevent default value set\n   *\n   * @param prop - property name\n   * @param callback - callback function\n   * @param immediate - trigger callback immediately with current value\n   */\n  watch<T extends any>(\n    prop: string,\n    callback: (arg: T) => boolean | void,\n    { immediate }: Partial<WatchConfig> = { immediate: false },\n  ) {\n    const nativeValueDesc =\n      Object.getOwnPropertyDescriptor(this.revogrid, prop) ||\n      Object.getOwnPropertyDescriptor(this.revogrid.constructor.prototype, prop);\n\n    // Overwrite property descriptor for this instance\n    Object.defineProperty(this.revogrid, prop, {\n      set(val: T) {\n        const keepDefault = callback(val);\n        if (keepDefault === false) {\n          return;\n        }\n        // Continue with native behavior\n        return nativeValueDesc?.set?.call(this, val);\n      },\n      get() {\n        // Continue with native behavior\n        return nativeValueDesc?.get?.call(this);\n      },\n    });\n    if (immediate) {\n      callback(nativeValueDesc?.value);\n    }\n  }\n\n  /**\n   * Remove event listener\n   * @param eventName\n   */\n  removeEventListener(eventName: string) {\n    this.revogrid.removeEventListener(eventName, this.subscriptions[eventName]);\n    delete this.subscriptions[eventName];\n  }\n\n  /**\n   * Emit event from revo-grid component\n   * Event can be cancelled by calling event.preventDefault() in callback\n   */\n  emit<T = any>(eventName: string, detail?: T) {\n    const event = new CustomEvent<T>(eventName, { detail, cancelable: true });\n    this.revogrid.dispatchEvent(event);\n    return event;\n  }\n\n  /**\n   * Clear all subscriptions\n   */\n  clearSubscriptions() {\n    for (let type in this.subscriptions) {\n      this.removeEventListener(type);\n    }\n  }\n\n  /**\n   * Destroy plugin and clear all subscriptions\n   */\n  destroy() {\n    this.clearSubscriptions();\n  }\n}\n\nexport type GridPlugin = (typeof BasePlugin);\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nexport default arrayEach;\n","import identity from './identity.js';\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nexport default castFunction;\n","import arrayEach from './_arrayEach.js';\nimport baseEach from './_baseEach.js';\nimport castFunction from './_castFunction.js';\nimport isArray from './isArray.js';\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nexport default forEach;\n","/**\n * Plugin module for revo-grid grid system\n * Add support for automatic column resize\n */\nimport each from 'lodash/each';\nimport reduce from 'lodash/reduce';\n\nimport { BasePlugin } from './base.plugin';\nimport { getSourceItem, columnTypes } from '@store';\nimport {\n  DimensionCols,\n  DimensionRows,\n  ColumnRegular,\n  DataType,\n  InitialHeaderClick,\n  ViewSettingSizeProp,\n  BeforeSaveDataDetails,\n  BeforeRangeSaveDataDetails,\n  PluginProviders,\n} from '@type';\nimport { ColumnCollection, getColumnType } from '../utils/column.utils';\n\ninterface Column extends ColumnRegular {\n  index: number;\n}\n\ntype AutoSizeColumns = Record<DimensionCols, ColumnRecords>;\ntype ColumnRecords = Record<any, Column>;\ntype SourceSetEvent = { type: DimensionRows; source: DataType[] };\ntype EditEvent = BeforeSaveDataDetails | BeforeRangeSaveDataDetails;\ntype Resolve = (cols: Partial<AutoSizeColumns>) => void;\ntype Reject = () => void;\n\nexport type AutoSizeColumnConfig = {\n  // ui behavior mode\n  mode?: ColumnAutoSizeMode;\n  /**\n   * autoSize for all columns\n   * if allColumnes true all columns treated as autoSize, worse for performance\n   * false by default\n   */\n  allColumns?: boolean;\n  /**\n   * assumption per characted size\n   * by default defined as 8, can be changed in this config\n   */\n  letterBlockSize?: number;\n  /** make size calculation exact\n   * by default it based on assumption each character takes some space defined in letterBlockSize */\n  preciseSize?: boolean;\n};\n\nconst LETTER_BLOCK_SIZE = 7;\n\nenum ColumnAutoSizeMode {\n  // increases column width on header click according the largest text value\n  headerClickAutosize = 'headerClickAutoSize',\n  // increases column width on data set and text edit, decreases performance\n  autoSizeOnTextOverlap = 'autoSizeOnTextOverlap',\n  // increases and decreases column width based on all items sizes, worst for performance\n  autoSizeAll = 'autoSizeAll',\n}\n\nexport class AutoSizeColumnPlugin extends BasePlugin {\n  autoSizeColumns: Partial<AutoSizeColumns> | null = null;\n  readonly letterBlockSize: number;\n\n  /** for config option when @preciseSize enabled */\n  readonly precsizeCalculationArea: HTMLElement;\n\n  /** for edge case when no columns defined before data */\n  dataResolve: Resolve | null = null;\n  dataReject: Reject | null = null;\n\n  constructor(\n    revogrid: HTMLRevoGridElement,\n    public providers: PluginProviders,\n    public config?: AutoSizeColumnConfig,\n  ) {\n    super(revogrid, providers);\n    this.letterBlockSize = config?.letterBlockSize || LETTER_BLOCK_SIZE;\n\n    // create test container to check text width\n    if (config?.preciseSize) {\n      this.precsizeCalculationArea = this.initiatePresizeElement();\n      revogrid.appendChild(this.precsizeCalculationArea);\n    }\n\n    const aftersourceset = ({\n      detail: { source },\n    }: CustomEvent<SourceSetEvent>) => {\n      this.setSource(source);\n    };\n    const afteredit = ({ detail }: CustomEvent<EditEvent>) => {\n      this.afteredit(detail);\n    };\n    const afterEditAll = ({ detail }: CustomEvent<EditEvent>) => {\n      this.afterEditAll(detail);\n    };\n    const beforecolumnsset = ({\n      detail: { columns },\n    }: CustomEvent<ColumnCollection>) => {\n      this.columnSet(columns);\n    };\n    const headerDblClick = ({ detail }: CustomEvent<InitialHeaderClick>) => {\n      const type = getColumnType(detail.column);\n      const size = this.getColumnSize(detail.index, type);\n      if (size) {\n        this.providers.dimension.setCustomSizes(\n          type,\n          {\n            [detail.index]: size,\n          },\n          true,\n        );\n      }\n    };\n    this.addEventListener('beforecolumnsset', beforecolumnsset);\n    switch (config?.mode) {\n      case ColumnAutoSizeMode.autoSizeOnTextOverlap:\n        this.addEventListener('aftersourceset', aftersourceset);\n        this.addEventListener('afteredit', afteredit);\n        break;\n      case ColumnAutoSizeMode.autoSizeAll:\n        this.addEventListener('aftersourceset', aftersourceset);\n        this.addEventListener('afteredit', afterEditAll);\n        break;\n      default:\n        this.addEventListener('headerdblclick', headerDblClick);\n        break;\n    }\n  }\n\n  async setSource(source: DataType[]): Promise<void> {\n    let autoSize = this.autoSizeColumns;\n    if (this.dataReject) {\n      this.dataReject();\n      this.clearPromise();\n    }\n\n    /** If data set first and no column provided await until get one */\n    if (!autoSize) {\n      const request = new Promise((resolve: Resolve, reject: Reject) => {\n        this.dataResolve = resolve;\n        this.dataReject = reject;\n      });\n      try {\n        autoSize = await request;\n      } catch (e) {\n        return;\n      }\n    }\n\n    // calculate sizes\n    each(autoSize, (_v, type: DimensionCols) => {\n      const sizes: ViewSettingSizeProp = {};\n      each(autoSize[type], rgCol => {\n        // calculate size\n        rgCol.size = sizes[rgCol.index] = source.reduce(\n          (prev, rgRow) => Math.max(prev, this.getLength(rgRow[rgCol.prop])),\n          this.getLength(rgCol.name || ''),\n        );\n      });\n      this.providers.dimension.setCustomSizes(type, sizes, true);\n    });\n  }\n\n  getLength(len?: any): number {\n    const padding = 15;\n    if (!len) {\n      return 0;\n    }\n    try {\n      const str = len.toString();\n\n      /**if exact calculation required proxy with html element, slow operation */\n      if (this.config?.preciseSize) {\n        this.precsizeCalculationArea.innerText = str;\n        return this.precsizeCalculationArea.scrollWidth + padding * 2;\n      }\n      return str.length * this.letterBlockSize + padding * 2;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  afteredit(e: EditEvent) {\n    let data: Record<string, DataType>;\n    if (this.isRangeEdit(e)) {\n      data = e.data;\n    } else {\n      data = { 0: { [e.prop]: e.val } };\n    }\n    each(this.autoSizeColumns, (columns, type: DimensionCols) => {\n      const sizes: ViewSettingSizeProp = {};\n\n      each(columns, rgCol => {\n        // calculate size\n        const size = reduce(\n          data,\n          (prev: number | undefined, rgRow) => {\n            if (typeof rgRow[rgCol.prop] === 'undefined') {\n              return prev;\n            }\n            return Math.max(prev || 0, this.getLength(rgRow[rgCol.prop]));\n          },\n          undefined,\n        );\n\n        if (size && (rgCol.size ?? 0) < size) {\n          rgCol.size = sizes[rgCol.index] = size;\n        }\n      });\n\n      this.providers.dimension.setCustomSizes(type, sizes, true);\n    });\n  }\n\n  afterEditAll(e: EditEvent) {\n    const props: Record<any, true> = {};\n    if (this.isRangeEdit(e)) {\n      each(e.data, r => each(r, (_v, p) => (props[p] = true)));\n    } else {\n      props[e.prop] = true;\n    }\n    each(this.autoSizeColumns, (columns, type: DimensionCols) => {\n      const sizes: ViewSettingSizeProp = {};\n\n      each(columns, rgCol => {\n        if (props[rgCol.prop]) {\n          const size = this.getColumnSize(rgCol.index, type);\n          if (size) {\n            sizes[rgCol.index] = size;\n          }\n        }\n      });\n      this.providers.dimension.setCustomSizes(type, sizes, true);\n    });\n  }\n\n  getColumnSize(index: number, type: DimensionCols): number {\n    const rgCol = this.autoSizeColumns?.[type]?.[index];\n    if (!rgCol) {\n      return 0;\n    }\n    return reduce(\n      this.providers.data.stores,\n      (r, s) => {\n        const perStore = reduce(\n          s.store.get('items'),\n          (prev, _row, i) => {\n            const item = getSourceItem(s.store, i);\n            return Math.max(prev || 0, this.getLength(item?.[rgCol.prop]));\n          },\n          0,\n        );\n        return Math.max(r, perStore);\n      },\n      rgCol.size || 0,\n    );\n  }\n\n  columnSet(columns: Record<DimensionCols, ColumnRegular[]>) {\n    for (let t of columnTypes) {\n      const type = t as DimensionCols;\n      const cols = columns[type];\n\n      for (let i in cols) {\n        if (cols[i].autoSize || this.config?.allColumns) {\n          if (!this.autoSizeColumns) {\n            this.autoSizeColumns = {};\n          }\n          if (!this.autoSizeColumns[type]) {\n            this.autoSizeColumns[type] = {};\n          }\n          this.autoSizeColumns[type][i] = {\n            ...cols[i],\n            index: parseInt(i, 10),\n          };\n        }\n      }\n    }\n\n    if (this.dataResolve) {\n      this.dataResolve(this.autoSizeColumns || {});\n      this.clearPromise();\n    }\n  }\n\n  clearPromise() {\n    this.dataResolve = null;\n    this.dataReject = null;\n  }\n\n  isRangeEdit(e: EditEvent): e is BeforeRangeSaveDataDetails {\n    return !!(e as BeforeRangeSaveDataDetails).data;\n  }\n\n  initiatePresizeElement(): HTMLElement {\n    const styleForFontTest: Partial<CSSStyleDeclaration> = {\n      position: 'absolute',\n      fontSize: '14px',\n      height: '0',\n      width: '0',\n      whiteSpace: 'nowrap',\n      top: '0',\n      overflowX: 'scroll',\n    };\n\n    const el = document.createElement('div');\n    for (let s in styleForFontTest) {\n      el.style[s] = styleForFontTest[s] ?? '';\n    }\n    el.classList.add('revo-test-container');\n    return el;\n  }\n\n  destroy() {\n    super.destroy();\n    this.precsizeCalculationArea?.remove();\n  }\n}\n","import each from 'lodash/each';\nimport { calculateRowHeaderSize } from '../utils/row-header-utils';\nimport { getScrollbarSize } from '../utils';\nimport { BasePlugin } from './base.plugin';\nimport { DimensionCols, DimensionType, PluginBaseComponent, PluginProviders, ColumnRegular } from '@type';\nimport { ColumnCollection } from '../utils/column.utils';\n\n/**\n * This plugin serves to recalculate columns initially\n * Base on empty space if there is any\n * Currently plugin supports only increasing last column\n */\ntype ScrollChange = {\n  type: DimensionType;\n  hasScroll: boolean;\n};\ntype StretchedData = {\n  initialSize: number;\n  size: number;\n  index: number;\n};\n\nexport class StretchColumn extends BasePlugin {\n  private stretchedColumn: StretchedData | null = null;\n  private readonly scrollSize;\n  constructor(\n    revogrid: HTMLRevoGridElement,\n    public providers: PluginProviders,\n  ) {\n    super(revogrid, providers);\n\n    // calculate scroll bar size for current user session\n    this.scrollSize = getScrollbarSize(document);\n\n    // subscribe to column changes\n    const beforecolumnapplied = ({\n      detail: { columns },\n    }: CustomEvent<ColumnCollection>) => this.applyStretch(columns);\n    this.addEventListener('beforecolumnapplied', beforecolumnapplied);\n  }\n\n  private setScroll({ type, hasScroll }: ScrollChange) {\n    if (\n      type === 'rgRow' &&\n      this.stretchedColumn &&\n      this.stretchedColumn?.initialSize === this.stretchedColumn.size\n    ) {\n      if (hasScroll) {\n        this.stretchedColumn.size -= this.scrollSize;\n        this.apply();\n        this.dropChanges();\n      }\n    }\n  }\n\n  private activateChanges() {\n    const setScroll = ({ detail }: CustomEvent<ScrollChange>) =>\n      this.setScroll(detail);\n    this.addEventListener('scrollchange', setScroll);\n  }\n\n  private dropChanges() {\n    this.stretchedColumn = null;\n    this.removeEventListener('scrollchange');\n  }\n\n  private apply() {\n    if (!this.stretchedColumn) {\n      return;\n    }\n    const type: DimensionCols = 'rgCol';\n    const sizes = this.providers.dimension.stores[type].store.get('sizes');\n    this.providers.dimension.setCustomSizes(\n      type,\n      {\n        ...sizes,\n        [this.stretchedColumn.index]: this.stretchedColumn.size,\n      },\n      true,\n    );\n  }\n\n  /**\n   * Apply stretch changes\n   */\n  applyStretch(columns: Record<DimensionCols, ColumnRegular[]>) {\n    // unsubscribe from all events\n    this.dropChanges();\n    // calculate grid size\n    let sizeDifference = this.revogrid.clientWidth - 1;\n    each(columns, (_, type: DimensionCols) => {\n      const realSize =\n        this.providers.dimension.stores[type].store.get('realSize');\n      sizeDifference -= realSize;\n    });\n    if (this.revogrid.rowHeaders) {\n      const itemsLength =\n        this.providers.data.stores.rgRow.store.get('source').length;\n      const header = this.revogrid.rowHeaders;\n      const rowHeaderSize = calculateRowHeaderSize(\n        itemsLength,\n        typeof header === 'object' ? header : undefined,\n      );\n      if (rowHeaderSize) {\n        sizeDifference -= rowHeaderSize;\n      }\n    }\n    if (sizeDifference > 0) {\n      // currently plugin accepts last column only\n      const index = columns.rgCol.length - 1;\n      const last = columns.rgCol[index];\n      /**\n       * has column\n       * no auto size applied\n       * size for column shouldn't be defined\n       */\n      const colSize = last?.size || this.revogrid.colSize || 0;\n      const size = sizeDifference + colSize - 1;\n\n      if (last && !last.autoSize && colSize < size) {\n        this.stretchedColumn = {\n          initialSize: size,\n          index,\n          size,\n        };\n        this.apply();\n        this.activateChanges();\n      }\n    }\n  }\n}\n\n/**\n * Check plugin type is Stretch\n */\nexport function isStretchPlugin(\n  plugin: PluginBaseComponent | StretchColumn,\n): plugin is StretchColumn {\n  return !!(plugin as StretchColumn).applyStretch;\n}\n","/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nexport default baseClamp;\n","import baseClamp from './_baseClamp.js';\nimport toInteger from './toInteger.js';\n\n/** Used as references for the maximum length and index of an array. */\nvar MAX_ARRAY_LENGTH = 4294967295;\n\n/**\n * Converts `value` to an integer suitable for use as the length of an\n * array-like object.\n *\n * **Note:** This method is based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toLength(3.2);\n * // => 3\n *\n * _.toLength(Number.MIN_VALUE);\n * // => 0\n *\n * _.toLength(Infinity);\n * // => 4294967295\n *\n * _.toLength('3.2');\n * // => 3\n */\nfunction toLength(value) {\n  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n}\n\nexport default toLength;\n","import toInteger from './toInteger.js';\nimport toLength from './toLength.js';\n\n/**\n * The base implementation of `_.fill` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n */\nfunction baseFill(array, value, start, end) {\n  var length = array.length;\n\n  start = toInteger(start);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : toInteger(end);\n  if (end < 0) {\n    end += length;\n  }\n  end = start > end ? 0 : toLength(end);\n  while (start < end) {\n    array[start++] = value;\n  }\n  return array;\n}\n\nexport default baseFill;\n","import baseFill from './_baseFill.js';\nimport isIterateeCall from './_isIterateeCall.js';\n\n/**\n * Fills elements of `array` with `value` from `start` up to, but not\n * including, `end`.\n *\n * **Note:** This method mutates `array`.\n *\n * @static\n * @memberOf _\n * @since 3.2.0\n * @category Array\n * @param {Array} array The array to fill.\n * @param {*} value The value to fill `array` with.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns `array`.\n * @example\n *\n * var array = [1, 2, 3];\n *\n * _.fill(array, 'a');\n * console.log(array);\n * // => ['a', 'a', 'a']\n *\n * _.fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * _.fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n */\nfunction fill(array, value, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n    start = 0;\n    end = length;\n  }\n  return baseFill(array, value, start, end);\n}\n\nexport default fill;\n","import { getGroupingName, isGrouping } from '../groupingRow/grouping.service';\nimport { CSVFormat, DataInput, Formatter } from './types';\n\nconst INITIAL: CSVFormat = {\n  mime: 'text/csv',\n  fileKind: 'csv',\n  // BOM signature\n  bom: true,\n  columnDelimiter: ',',\n  rowDelimiter: '\\r\\n',\n  encoding: '',\n};\n\nexport type CSVFormatter = (options: Partial<CSVFormat>, data: DataInput) => string;\n\n// The ASCII character code 13 is called a Carriage Return or CR.\nconst CARRIAGE_RETURN = String.fromCharCode(13);\n// Chr(13) followed by a Chr(10) that compose a proper CRLF.\nconst LINE_FEED = String.fromCharCode(10);\nconst DOUBLE_QT = String.fromCharCode(34);\nconst NO_BREAK_SPACE = String.fromCharCode(0xfeff);\nconst escapeRegex = new RegExp('\"', 'g');\n\nexport class ExportCsv implements Formatter {\n  readonly options: Readonly<CSVFormat>;\n  constructor(options: Partial<CSVFormat> = {}) {\n    this.options = { ...INITIAL, ...options };\n  }\n\n  doExport({ data, headers, props }: DataInput) {\n    let result = this.options.bom ? NO_BREAK_SPACE : '';\n\n    // any header\n    if (headers?.length > 0) {\n      headers.forEach(header => {\n        // ignore empty\n        if (!header.length) {\n          return;\n        }\n        result += this.prepareHeader(header, this.options.columnDelimiter);\n        result += this.options.rowDelimiter;\n      });\n    }\n\n    data.forEach((rgRow, index) => {\n      if (index > 0) {\n        result += this.options.rowDelimiter;\n      }\n      // support grouping\n      if (isGrouping(rgRow)) {\n        result += this.parseCell(getGroupingName(rgRow), this.options.columnDelimiter);\n        return;\n      }\n      result += props.map(p => this.parseCell(rgRow[p], this.options.columnDelimiter)).join(this.options.columnDelimiter);\n    });\n\n    return result;\n  }\n\n  private prepareHeader(columnHeaders: string[], columnDelimiter: string) {\n    let result = '';\n    const newColumnHeaders = columnHeaders.map(v => this.parseCell(v, columnDelimiter, true));\n    result += newColumnHeaders.join(columnDelimiter);\n    return result;\n  }\n\n  private parseCell(value: any, columnDelimiter: string, force = false) {\n    let escape = value;\n    if (typeof value !== 'string') {\n      escape = JSON.stringify(value);\n    }\n    const toEscape = [CARRIAGE_RETURN, DOUBLE_QT, LINE_FEED, columnDelimiter];\n    if (typeof escape === 'undefined') {\n      return '';\n    }\n    if (escape !== '' && (force || toEscape.some(i => escape.indexOf(i) >= 0))) {\n      return `\"${escape.replace(escapeRegex, '\"\"')}\"`;\n    }\n\n    return escape;\n  }\n}\n","import fill from 'lodash/fill';\nimport { columnTypes, rowTypes, Group, Groups } from '@store';\n\nimport { timeout } from '../../utils';\nimport { BasePlugin } from '../base.plugin';\nimport { ExportCsv } from './csv';\nimport type { ColSource, CSVFormat, DataInput, Formatter } from './types';\nimport { DimensionCols, ColumnProp, DataType } from '@type';\n\nexport * from './csv';\nexport * from './types';\n\nenum ExportTypes {\n  csv = 'csv',\n}\n\nexport type ExportFormat = Partial<CSVFormat>;\n\nexport class ExportFilePlugin extends BasePlugin {\n  /** Exports string */\n  async exportString(options: ExportFormat = {}, t: ExportTypes = ExportTypes.csv) {\n    const data = await this.beforeexport();\n    if (!data) {\n      return null;\n    }\n    return this.formatter(t, options).doExport(data);\n  }\n\n  /** Exports Blob */\n  async exportBlob(options: ExportFormat = {}, t: ExportTypes = ExportTypes.csv) {\n    return await this.getBlob(this.formatter(t, options));\n  }\n\n  /** Export file */\n  async exportFile(options: ExportFormat = {}, t: ExportTypes = ExportTypes.csv) {\n    const formatter = this.formatter(t, options);\n\n    // url\n    const URL = window.URL || window.webkitURL;\n\n    const a = document.createElement('a');\n    const { filename, fileKind } = formatter.options;\n    const name = `${filename}.${fileKind}`;\n\n    const blob = await this.getBlob(formatter);\n    const url = blob ? URL.createObjectURL(blob) : '';\n\n    a.style.display = 'none';\n    a.setAttribute('href', url);\n    a.setAttribute('download', name);\n    this.revogrid.appendChild(a);\n    a.dispatchEvent(new MouseEvent('click'));\n    this.revogrid.removeChild(a);\n\n    // delay for revoke, correct for some browsers\n    await timeout(120);\n    URL.revokeObjectURL(url);\n  }\n\n  /** Blob object */\n  async getBlob(formatter: Formatter) {\n    const type = `${formatter.options.mime};charset=${formatter.options.encoding}`;\n    if (typeof Blob !== 'undefined') {\n      const data = await this.beforeexport();\n      if (!data) {\n        return null;\n      }\n      return new Blob([formatter.doExport(data)], { type });\n    }\n    return null;\n  }\n\n  // before event\n  private async beforeexport() {\n    let data = await this.getData();\n    const event: CustomEvent<{ data: DataInput }> = this.emit('beforeexport', { data });\n    if (event.defaultPrevented) {\n      return null;\n    }\n    return event.detail.data;\n  }\n\n  private async getData(): Promise<DataInput> {\n    const data = await this.getSource();\n    const colSource: ColSource[] = [];\n    const colPromises: Promise<ColSource>[] = [];\n    columnTypes.forEach((t, i) => {\n      colPromises.push(this.getColPerSource(t).then(s => (colSource[i] = s)));\n    });\n    await Promise.all(colPromises);\n    const columns: ColSource = {\n      headers: [],\n      props: [],\n    };\n    for (let source of colSource) {\n      source.headers.forEach((h, i) => {\n        if (!columns.headers[i]) {\n          columns.headers[i] = [];\n        }\n        columns.headers[i].push(...h);\n      });\n      columns.props.push(...source.props);\n    }\n    return {\n      data,\n      ...columns,\n    };\n  }\n\n  private async getColPerSource(t: DimensionCols) {\n    const store = await this.revogrid.getColumnStore(t);\n    const source = store.get('source');\n    const virtualIndexes = store.get('items');\n    const depth = store.get('groupingDepth');\n    const groups = store.get('groups');\n    const colNames: string[] = [];\n    const colProps: ColumnProp[] = [];\n    const visibleItems = virtualIndexes.reduce((r: Record<string, number>, v: number, virtualIndex: number) => {\n      const prop = source[v].prop;\n      colNames.push(source[v].name || '');\n      colProps.push(prop);\n      r[prop] = virtualIndex;\n      return r;\n    }, {});\n    const rows: string[][] = this.getGroupHeaders(depth, groups, virtualIndexes, visibleItems);\n    rows.push(colNames);\n    return {\n      headers: rows,\n      props: colProps,\n    };\n  }\n\n  private getGroupHeaders(depth: number, groups: Groups, items: number[], visibleItems: Record<string, number>) {\n    const rows: string[][] = [];\n    const template = fill(new Array(items.length), '');\n    for (let d = 0; d < depth; d++) {\n      const rgRow = [...template];\n      rows.push(rgRow);\n      if (!groups[d]) {\n        continue;\n      }\n      const levelGroups = groups[d];\n\n      // add names of groups\n      levelGroups.forEach((group: Group) => {\n        const minIndex = this.findGroupStartIndex(group.ids, visibleItems);\n        if (typeof minIndex === 'number') {\n          rgRow[minIndex] = group.name;\n        }\n      });\n    }\n    return rows;\n  }\n\n  private findGroupStartIndex(ids: (string | number)[], visibleItems: Record<string, number>): number | undefined {\n    let min: number | undefined;\n    ids.forEach(id => {\n      const current = visibleItems[id];\n      if (typeof current === 'number') {\n        if (typeof min !== 'number' || min > current) {\n          min = current;\n        }\n      }\n    });\n    return min;\n  }\n\n  private async getSource() {\n    const data: DataType[][] = [];\n    const promisesData: Promise<number>[] = [];\n    rowTypes.forEach(t => {\n      const dataPart: DataType[] = [];\n      data.push(dataPart);\n      const promise = this.revogrid.getVisibleSource(t).then((d: DataType[]) => dataPart.push(...d));\n      promisesData.push(promise);\n    });\n    await Promise.all(promisesData);\n    return data.reduce((r, v) => {\n      r.push(...v);\n      return r;\n    }, []);\n  }\n\n  // get correct class for future multiple types support\n  private formatter(type: ExportTypes, options: ExportFormat = {}) {\n    switch (type) {\n      case ExportTypes.csv:\n        return new ExportCsv(options);\n      default:\n        throw new Error('Unknown format');\n    }\n  }\n}\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam, ExtraField } from '../filter.types';\n\nconst eq: LogicFunction = (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) => {\n  if (typeof value === 'undefined' || (value === null && !extra)) {\n    return true;\n  }\n  if (typeof value !== 'string') {\n    value = JSON.stringify(value);\n  }\n\n  const filterVal = extra?.toString().toLocaleLowerCase();\n  if (filterVal?.length === 0) {\n    return true;\n  }\n  \n  return value.toLocaleLowerCase() === filterVal;\n};\n\nexport const notEq: LogicFunction = (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) => !eq(value, extra);\nnotEq.extra = 'input' as ExtraField;\neq.extra = 'input' as ExtraField;\nexport default eq;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\n\nconst gtThan: LogicFunction = function (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) {\n  let conditionValue: number;\n\n  if (typeof value === 'number' && typeof extra !== 'undefined' && extra !== null) {\n    conditionValue = parseFloat(extra?.toString());\n    return value > conditionValue;\n  }\n  return false;\n};\n\ngtThan.extra = 'input';\nexport default gtThan;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\nimport eq from '../equal';\nimport gt from './greaterThan';\n\nconst gtThanEq: LogicFunction = function (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) {\n  return eq(value, extra) || gt(value, extra);\n};\n\ngtThanEq.extra = 'input';\nexport default gtThanEq;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\n\nconst lt: LogicFunction = function (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) {\n  let conditionValue: number;\n  if (typeof value === 'number' && typeof extra !== 'undefined' && extra !== null) {\n    conditionValue = parseFloat(extra.toString());\n    return value < conditionValue;\n  } else {\n    return false;\n  }\n};\n\nlt.extra = 'input';\nexport default lt;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\nimport eq from '../equal';\nimport lt from './lessThan';\n\nconst lsEq: LogicFunction = function (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) {\n  return eq(value, extra) || lt(value, extra);\n};\n\nlsEq.extra = 'input';\nexport default lsEq;\n","import { LogicFunction, LogicFunctionParam } from '../filter.types';\n\nconst set: LogicFunction = (value: LogicFunctionParam) => !(value === '' || value === null || value === void 0);\nexport const notSet: LogicFunction = (value: LogicFunctionParam) => !set(value);\nexport default set;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\n\nconst beginsWith: LogicFunction = (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) => {\n  if (!value) {\n    return false;\n  }\n  if (!extra) {\n    return true;\n  }\n  if (typeof value !== 'string') {\n    value = JSON.stringify(value);\n  }\n  if (typeof extra !== 'string') {\n    extra = JSON.stringify(extra);\n  }\n  return value.toLocaleLowerCase().indexOf(extra.toLocaleLowerCase()) === 0;\n};\n\nbeginsWith.extra = 'input';\nexport default beginsWith;\n","import { LogicFunction, LogicFunctionExtraParam, LogicFunctionParam } from '../../filter.types';\n\nconst contains: LogicFunction = (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) => {\n  if (!extra) {\n    return true;\n  }\n  if (!value) {\n    return false;\n  }\n  if (extra) {\n    if (typeof value !== 'string') {\n      value = JSON.stringify(value);\n    }\n    return value.toLocaleLowerCase().indexOf(extra.toString().toLowerCase()) > -1;\n  }\n  return true;\n};\n\nexport const notContains: LogicFunction = (value: LogicFunctionParam, extra?: LogicFunctionExtraParam) => {\n  return !contains(value, extra);\n};\nnotContains.extra = 'input';\ncontains.extra = 'input';\nexport default contains;\n","// filter.indexed.ts\n\nimport eq, { notEq } from './conditions/equal';\nimport gtThan from './conditions/number/greaterThan';\nimport gtThanEq from './conditions/number/greaterThanOrEqual';\nimport lt from './conditions/number/lessThan';\nimport lsEq from './conditions/number/lessThanOrEqual';\nimport set, { notSet } from './conditions/set';\nimport beginsWith from './conditions/string/beginswith';\nimport contains, { notContains } from './conditions/string/contains';\nimport { LogicFunction } from './filter.types';\n\n\nexport const filterCoreFunctionsIndexedByType: Record<FilterType, LogicFunction> = {\n  none: () => true,\n  empty: notSet,\n  notEmpty: set,\n  eq: eq,\n  notEq: notEq,\n  begins: beginsWith,\n  contains: contains,\n  notContains: notContains,\n\n  eqN: eq,\n  neqN: notEq,\n  gt: gtThan,\n  gte: gtThanEq,\n  lt: lt,\n  lte: lsEq,\n};\n\nexport const filterTypes: Record<string, FilterType[]> = {\n  string: ['notEmpty', 'empty', 'eq', 'notEq', 'begins', 'contains', 'notContains'],\n  number: ['notEmpty', 'empty', 'eqN', 'neqN', 'gt', 'gte', 'lt', 'lte'],\n};\n\nexport const filterNames = {\n  none: 'None',\n  empty: 'Not set',\n  notEmpty: 'Set',\n\n  eq: 'Equal',\n  notEq: 'Not equal',\n  begins: 'Begins with',\n  contains: 'Contains',\n  notContains: 'Does not contain',\n\n  eqN: '=',\n  neqN: '!=',\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<=',\n};\n\nexport type FilterType = keyof typeof filterNames;\n","// filter.plugin.tsx\nimport { h, type VNode } from '@stencil/core';\n\nimport type {\n  ColumnProp,\n  ColumnRegular,\n  DataType,\n  PluginProviders,\n} from '@type';\nimport { BasePlugin } from '../base.plugin';\nimport { FILTER_PROP, isFilterBtn } from './filter.button';\nimport {\n  filterCoreFunctionsIndexedByType,\n  filterNames,\n  filterTypes,\n} from './filter.indexed';\n\nimport type {\n  ColumnFilterConfig,\n  FilterCollectionItem,\n  FilterData,\n  LogicFunction,\n  MultiFilterItem,\n  ShowData,\n} from './filter.types';\n\nimport { getCellDataParsed } from '../../utils';\n\nexport * from './filter.types';\nexport * from './filter.indexed';\nexport * from './filter.button';\n\nexport const FILTER_TRIMMED_TYPE = 'filter';\nexport const FILTER_CONFIG_CHANGED_EVENT = 'filterconfigchanged';\nexport const FILTE_PANEL = 'revogr-filter-panel';\n\n/**\n * @typedef ColumnFilterConfig\n * @type {object}\n *\n * @property {MultiFilterItem|undefined} multiFilterItems - data for multi filtering with relation\n *\n * @property {Record<ColumnProp, FilterCollectionItem>|undefined} collection - preserved filter data, relation for filters will be applied as 'and'\n *\n * @property {string[]|undefined} include - filters to be included, if defined everything else out of scope will be ignored\n *\n * @property {Record<string, CustomFilter>|undefined} customFilters - hash map of {FilterType:CustomFilter}.\n *\n * @property {FilterLocalization|undefined} localization - translation for filter popup captions.\n *\n * @property {boolean|undefined} disableDynamicFiltering - disables dynamic filtering. A way to apply filters on Save only.\n */\n/**\n * @internal\n */\n\nexport class FilterPlugin extends BasePlugin {\n  pop?: HTMLRevogrFilterPanelElement;\n  filterCollection: Record<ColumnProp, FilterCollectionItem> = {};\n  multiFilterItems: MultiFilterItem = {};\n\n  /**\n   * Filter types\n   * @example\n   * {\n   *    string: ['contains', 'beginswith'],\n   *    number: ['eqN', 'neqN', 'gt']\n   *  }\n   */\n  filterByType: Record<string, string[]> = { ...filterTypes };\n  filterNameIndexByType: Record<string, string> = {\n    ...filterNames,\n  };\n  filterFunctionsIndexedByType: Record<string, LogicFunction> = {\n    ...filterCoreFunctionsIndexedByType,\n  };\n\n  filterProp = FILTER_PROP;\n\n  extraHyperContent?: (data: ShowData) => VNode | VNode[];\n\n  constructor(\n    public revogrid: HTMLRevoGridElement,\n    providers: PluginProviders,\n    public config?: ColumnFilterConfig,\n  ) {\n    super(revogrid, providers);\n    if (config) {\n      this.initConfig(config);\n    }\n\n    const existingNodes = this.revogrid.registerVNode.filter(\n      n => typeof n === 'object' && n.$tag$ !== FILTE_PANEL,\n    );\n    this.revogrid.registerVNode = [\n      ...existingNodes,\n      <revogr-filter-panel\n        filterNames={this.filterNameIndexByType}\n        filterEntities={this.filterFunctionsIndexedByType}\n        filterCaptions={config?.localization?.captions}\n        onFilterChange={e => this.onFilterChange(e.detail)}\n        onResetChange={e => this.onFilterReset(e.detail)}\n        disableDynamicFiltering={config?.disableDynamicFiltering}\n        ref={e => (this.pop = e)}\n      >\n        {' '}\n        {this.extraContent()}\n      </revogr-filter-panel>,\n    ];\n\n    const aftersourceset = async () => {\n      const filterCollectionProps = Object.keys(this.filterCollection);\n      if (filterCollectionProps.length > 0) {\n        // handle old way of filtering by reworking FilterCollection to new MultiFilterItem\n        filterCollectionProps.forEach((prop, index) => {\n          if (!this.multiFilterItems[prop]) {\n            this.multiFilterItems[prop] = [\n              {\n                id: index,\n                type: this.filterCollection[prop].type,\n                value: this.filterCollection[prop].value,\n                relation: 'and',\n              },\n            ];\n          }\n        });\n      }\n      if (Object.keys(this.multiFilterItems).length === 0) {\n        return;\n      }\n      await this.runFiltering(this.multiFilterItems);\n    };\n    this.addEventListener('headerclick', e => this.headerclick(e));\n    this.addEventListener(\n      FILTER_CONFIG_CHANGED_EVENT,\n      ({ detail }: CustomEvent<ColumnFilterConfig | boolean>) => {\n        if (\n          !detail ||\n          (typeof detail === 'object' &&\n            (!detail.multiFilterItems ||\n              !Object.keys(detail.multiFilterItems).length))\n        ) {\n          this.clearFiltering();\n          return;\n        }\n        if (typeof detail === 'object') {\n          this.initConfig(detail);\n        }\n        aftersourceset();\n      },\n    );\n    this.addEventListener('aftersourceset', aftersourceset);\n    this.addEventListener('filter', ({ detail }: CustomEvent) =>\n      this.onFilterChange(detail),\n    );\n  }\n\n  beforeshow(_: ShowData) {\n    // used as hook for filter panel\n  }\n\n  extraContent(): any {\n    return null;\n  }\n\n  initConfig(config: ColumnFilterConfig) {\n    if (config.multiFilterItems) {\n      this.multiFilterItems = { ...config.multiFilterItems };\n    } else {\n      this.multiFilterItems = {};\n    }\n    // Add custom filters\n    if (config.customFilters) {\n      for (let customFilterType in config.customFilters) {\n        const cFilter = config.customFilters[customFilterType];\n        if (!this.filterByType[cFilter.columnFilterType]) {\n          this.filterByType[cFilter.columnFilterType] = [];\n        }\n        // add custom filter type\n        this.filterByType[cFilter.columnFilterType].push(customFilterType);\n        // add custom filter function\n        this.filterFunctionsIndexedByType[customFilterType] = cFilter.func;\n        // add custom filter name\n        this.filterNameIndexByType[customFilterType] = cFilter.name;\n      }\n    }\n\n    // Add filterProp if provided in config\n    if (config.filterProp) {\n      this.filterProp = config.filterProp;\n    }\n\n    /**\n     * which filters has to be included/excluded\n     * convinient way to exclude system filters\n     */\n    const cfgInlcude = config.include;\n    if (cfgInlcude) {\n      const filters: Record<string, string[]> = {};\n\n      for (let t in this.filterByType) {\n        // validate filters, if appropriate function present\n        const newTypes = this.filterByType[t].filter(\n          f => cfgInlcude.indexOf(f) > -1,\n        );\n        if (newTypes.length) {\n          filters[t] = newTypes;\n        }\n      }\n      // if any valid filters provided show them\n      if (Object.keys(filters).length > 0) {\n        this.filterByType = filters;\n      }\n    }\n\n    if (config.collection) {\n      const filtersWithFilterFunctionPresent = Object.entries(\n        config.collection,\n      ).filter(([, item]) => this.filterFunctionsIndexedByType[item.type]);\n      this.filterCollection = Object.fromEntries(\n        filtersWithFilterFunctionPresent,\n      );\n    } else {\n      this.filterCollection = {};\n    }\n\n    if (config.localization) {\n      if (config.localization.filterNames) {\n        Object.entries(config.localization.filterNames).forEach(([k, v]) => {\n          if (this.filterNameIndexByType[k] != void 0) {\n            this.filterNameIndexByType[k] = v;\n          }\n        });\n      }\n    }\n  }\n\n  async headerclick(e: CustomEvent<ColumnRegular>) {\n    const el = e.detail.originalEvent?.target as HTMLElement;\n    if (!isFilterBtn(el)) {\n      return;\n    }\n    e.preventDefault();\n    if (!this.pop) {\n      return;\n    }\n\n    // filter button clicked, open filter dialog\n    const gridPos = this.revogrid.getBoundingClientRect();\n    const buttonPos = el.getBoundingClientRect();\n    const prop = e.detail.prop;\n\n    const data: ShowData = {\n      ...e.detail,\n      ...this.filterCollection[prop],\n      x: buttonPos.x - gridPos.x,\n      y: buttonPos.y - gridPos.y + buttonPos.height,\n      autoCorrect: true,\n      filterTypes: this.getColumnFilter(e.detail.filter),\n      filterItems: this.multiFilterItems,\n      extraContent: this.extraHyperContent,\n    };\n    this.beforeshow?.(data);\n    this.pop.show(data);\n  }\n\n  getColumnFilter(\n    type?: boolean | string | string[],\n  ): Record<string, string[]> {\n    let filterType = 'string';\n    if (!type) {\n      return { [filterType]: this.filterByType[filterType] };\n    }\n\n    // if custom column filter\n    if (this.isValidType(type)) {\n      filterType = type;\n\n      // if multiple filters applied\n    } else if (typeof type === 'object' && type.length) {\n      return type.reduce((r: Record<string, string[]>, multiType) => {\n        if (this.isValidType(multiType)) {\n          r[multiType] = this.filterByType[multiType];\n        }\n        return r;\n      }, {});\n    }\n    return { [filterType]: this.filterByType[filterType] };\n  }\n\n  isValidType(type: any): type is string {\n    return !!(typeof type === 'string' && this.filterByType[type]);\n  }\n\n  /**\n   * Called on internal component change\n   */\n  async onFilterChange(filterItems: MultiFilterItem) {\n    // store the filter items\n    this.multiFilterItems = filterItems;\n\n    // run the filtering when the items change\n    this.runFiltering(this.multiFilterItems);\n  }\n\n  onFilterReset(prop?: ColumnProp) {\n    delete this.multiFilterItems[prop ?? ''];\n    this.onFilterChange(this.multiFilterItems);\n  }\n\n  /**\n   * Triggers grid filtering\n   */\n  async doFiltering(\n    collection: Record<ColumnProp, FilterCollectionItem>,\n    source: DataType[],\n    columns: ColumnRegular[],\n    filterItems: MultiFilterItem,\n  ) {\n    const columnsToUpdate: ColumnRegular[] = [];\n\n    /**\n     * Loop through the columns and update the columns that need to be updated with the `hasFilter` property.\n     */\n    const columnByProp: Record<string, ColumnRegular> = {};\n    columns.forEach(rgCol => {\n      const column = { ...rgCol };\n      const hasFilter = filterItems[column.prop];\n      columnByProp[column.prop] = column;\n\n      /**\n       * If the column has a filter and it's not already marked as filtered, update the column.\n       */\n      if (column[this.filterProp] && !hasFilter) {\n        delete column[this.filterProp];\n        columnsToUpdate.push(column);\n      }\n\n      /**\n       * If the column does not have a filter and it's marked as filtered, update the column.\n       */\n\n      if (!column[this.filterProp] && hasFilter) {\n        columnsToUpdate.push(column);\n        column[this.filterProp] = true;\n      }\n    });\n    const itemsToTrim = this.getRowFilter(source, filterItems, columnByProp);\n    // check is filter event prevented\n    const { defaultPrevented, detail } = this.emit('beforefiltertrimmed', {\n      collection,\n      itemsToFilter: itemsToTrim,\n      source,\n      filterItems,\n    });\n    if (defaultPrevented) {\n      return;\n    }\n\n    // check is trimmed event prevented\n    const isAddedEvent = await this.revogrid.addTrimmed(\n      detail.itemsToFilter,\n      FILTER_TRIMMED_TYPE,\n    );\n    if (isAddedEvent.defaultPrevented) {\n      return;\n    }\n\n    // applies the hasFilter to the columns to show filter icon\n    this.providers.column.updateColumns(columnsToUpdate);\n    this.emit('afterfilterapply', {\n      multiFilterItems: filterItems,\n      source,\n      collection,\n    });\n  }\n\n  async clearFiltering() {\n    this.multiFilterItems = {};\n    await this.runFiltering(this.multiFilterItems);\n  }\n\n  async runFiltering(multiFilterItems: MultiFilterItem) {\n    const collection: Record<ColumnProp, FilterCollectionItem> = {};\n\n    // handle old filterCollection to return the first filter only (if any) from multiFilterItems\n    const filterProps = Object.keys(multiFilterItems);\n\n    for (const prop of filterProps) {\n      // check if we have any filter for a column\n      if (multiFilterItems[prop].length > 0) {\n        const firstFilterItem = multiFilterItems[prop][0];\n        collection[prop] = {\n          type: firstFilterItem.type,\n          value: firstFilterItem.value,\n        };\n      }\n    }\n\n    this.filterCollection = collection;\n    const columns = this.providers.column.getColumns();\n    // run the filtering on the main source only\n    const source = this.providers.data.stores['rgRow'].store.get('source');\n\n    const { defaultPrevented, detail } = this.emit('beforefilterapply', {\n      collection: this.filterCollection,\n      source,\n      columns,\n      filterItems: this.multiFilterItems,\n    });\n    if (defaultPrevented) {\n      return;\n    }\n    this.doFiltering(\n      detail.collection,\n      detail.source,\n      detail.columns,\n      detail.filterItems,\n    );\n  }\n\n  /**\n   * Get trimmed rows based on filter\n   */\n  getRowFilter(\n    rows: DataType[],\n    filterItems: MultiFilterItem,\n    columnByProp: Record<string, ColumnRegular>,\n  ): Record<number, boolean> {\n    const propKeys = Object.keys(filterItems);\n\n    const trimmed: Record<number, boolean> = {};\n\n    // each rows\n    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n      // check filter by column properties\n      for (const prop of propKeys) {\n        // add to the list of removed/trimmed rows of filter condition is satisfied\n        if (\n          this.shouldTrimRow(\n            filterItems[prop],\n            prop,\n            columnByProp[prop],\n            rows[rowIndex],\n          )\n        ) {\n          trimmed[rowIndex] = true;\n        }\n      } // end of for-of propKeys\n    }\n    return trimmed;\n  }\n\n  private shouldTrimRow(\n    propFilters: FilterData[],\n    prop: ColumnProp,\n    column?: ColumnRegular,\n    model: DataType = {},\n  ) {\n    // reset the count of satisfied filters\n    let propFilterSatisfiedCount = 0;\n    // reset the array of last filter results\n    let lastFilterResults: boolean[] = [];\n\n    // testing each filter for a prop\n    for (const [filterIndex, filterData] of propFilters.entries()) {\n      // the filter LogicFunction based on the type\n      const filterFunc = this.filterFunctionsIndexedByType[filterData.type];\n\n      // THE MAGIC OF FILTERING IS HERE\n      // If there is no column but user wants to filter by a property\n      const value = column ? getCellDataParsed(model, column) : model[prop];\n      // OR relation\n      if (filterData.relation === 'or') {\n        // reset the array of last filter results\n        lastFilterResults = [];\n        // if the filter is satisfied, continue to the next filter\n        if (filterFunc(value, filterData.value)) {\n          continue;\n        }\n        // if the filter is not satisfied, count it\n        propFilterSatisfiedCount++;\n\n        // AND relation\n      } else {\n        // 'and' relation will need to know the next filter\n        // so we save this current filter to include it in the next filter\n        lastFilterResults.push(!filterFunc(value, filterData.value));\n\n        if (isFinalAndFilter(filterIndex, propFilters)) {\n          // let's just continue since for sure propFilterSatisfiedCount cannot be satisfied\n          if (allAndConditionsSatisfied(lastFilterResults)) {\n            // reset the array of last filter results\n            lastFilterResults = [];\n            continue;\n          }\n\n          // we need to add all of the lastFilterResults since we need to satisfy all\n          propFilterSatisfiedCount += lastFilterResults.length;\n          // reset the array of last filter results\n          lastFilterResults = [];\n        }\n      }\n    } // end of propFilters forEach\n    return propFilterSatisfiedCount === propFilters.length;\n  }\n}\n/**\n * Checks if the current filter is the final one in an AND sequence.\n * @param index - Current filter index in the list.\n * @param filters - Array of filters for the property.\n * @returns True if this is the last AND condition; false otherwise.\n */\nfunction isFinalAndFilter(index: number, filters: MultiFilterItem[string]): boolean {\n  const nextFilter = filters[index + 1]; // Get the next filter in the list.\n  // Return true if there's no next filter or if the next filter defined and is not part of the AND sequence.\n  return !nextFilter || (!!nextFilter.relation && nextFilter.relation !== 'and');\n}\n\n/**\n * Determines if all conditions in an AND sequence are satisfied.\n * @param pendingResults - An array of results from the AND conditions.\n * @returns True if all conditions are satisfied; false otherwise.\n */\nfunction allAndConditionsSatisfied(pendingResults: boolean[]): boolean {\n  // Check if there are any failed conditions in the pending results.\n  return !pendingResults.includes(true);\n}\n","import { DataType } from '@type';\nimport { PSEUDO_GROUP_ITEM_ID, PSEUDO_GROUP_ITEM_VALUE, GROUP_EXPANDED, GROUP_DEPTH } from './grouping.const';\nimport { isGrouping, getParsedGroup, isSameGroup } from './grouping.service';\n\n// provide collapse data\nexport function doCollapse(pIndex: number, source: DataType[]) {\n  const model = source[pIndex];\n  const collapseValue = model[PSEUDO_GROUP_ITEM_VALUE];\n  const trimmed: Record<number, boolean> = {};\n  let i = pIndex + 1;\n  const total = source.length;\n  while (i < total) {\n    const currentModel = source[i];\n    if (isGrouping(currentModel)) {\n      const currentValue = currentModel[PSEUDO_GROUP_ITEM_VALUE];\n      if (!currentValue.length || !currentValue.startsWith(collapseValue + ',')) {\n        break;\n      }\n      currentModel[GROUP_EXPANDED] = false;\n    }\n    trimmed[i++] = true;\n  }\n  model[GROUP_EXPANDED] = false;\n  return { trimmed };\n}\n\n/**\n *\n * @param pIndex - physical index\n * @param vIndex - virtual index, need to update item collection\n * @param source - data source\n * @param rowItemsIndexes - rgRow indexes\n */\nexport function doExpand(vIndex: number, source: DataType[], rowItemsIndexes: number[]) {\n  const physicalIndex = rowItemsIndexes[vIndex];\n  const model = source[physicalIndex];\n  const currentGroup = getParsedGroup(model[PSEUDO_GROUP_ITEM_ID]);\n  const trimmed: Record<number, boolean> = {};\n\n  // no group found\n  if (!currentGroup) {\n    return { trimmed };\n  }\n\n  const groupItems: number[] = [];\n  model[GROUP_EXPANDED] = true;\n  let i = physicalIndex + 1;\n  const total = source.length;\n  let groupLevelOnly = 0;\n\n  // go through all rows\n  while (i < total) {\n    const currentModel = source[i];\n    const isGroup = isGrouping(currentModel);\n    // group found\n    if (isGroup) {\n      if (!isSameGroup(currentGroup, model, currentModel)) {\n        break;\n      } else if (!groupLevelOnly) {\n        // if get group first it's group only level\n        groupLevelOnly = currentModel[GROUP_DEPTH];\n      }\n    }\n    // level 0 or same depth\n    if (!groupLevelOnly || (isGroup && groupLevelOnly === currentModel[GROUP_DEPTH])) {\n      trimmed[i] = false;\n      groupItems.push(i);\n    }\n    i++;\n  }\n  const result: {\n    trimmed: Record<number, boolean>;\n    items?: number[];\n  } = {\n    trimmed,\n  };\n  if (groupItems.length) {\n    const items = [...rowItemsIndexes];\n    items.splice(vIndex + 1, 0, ...groupItems);\n    result.items = items;\n  }\n  return result;\n}\n","import { gatherTrimmedItems, Trimmed, TrimmedEntity } from '@store';\n\nexport const TRIMMED_GROUPING = 'grouping';\n\n/**\n * Prepare trimming updated indexes for grouping\n * @param initiallyTrimed\n * @param firstLevelMap\n * @param secondLevelMap\n */\nexport function processDoubleConversionTrimmed(initiallyTrimed: Trimmed, firstLevelMap: Record<number, number>, secondLevelMap?: Record<number, number>) {\n  const trimemedOptionsToUpgrade: Trimmed = {};\n  /**\n   * go through all groups except grouping\n   */\n  for (let type in initiallyTrimed) {\n    if (type === TRIMMED_GROUPING) {\n      continue;\n    }\n    const items = initiallyTrimed[type];\n    const newItems: TrimmedEntity = {};\n\n    for (let initialIndex in items) {\n      /**\n       * if item exists we find it in collection\n       * we support 2 level of conversions\n       */\n      let newConversionIndex = firstLevelMap[initialIndex];\n      if (secondLevelMap) {\n        newConversionIndex = secondLevelMap[newConversionIndex];\n      }\n\n      /**\n       * if item was trimmed previously\n       * trimming makes sense to apply\n       */\n      if (items[initialIndex]) {\n        newItems[newConversionIndex] = true;\n        /**\n         * If changes present apply changes to new source\n         */\n        if (newConversionIndex !== parseInt(initialIndex, 10)) {\n          trimemedOptionsToUpgrade[type] = newItems;\n        }\n      }\n    }\n  }\n  return trimemedOptionsToUpgrade;\n}\n\nexport function filterOutEmptyGroups(allTrimmedGroups: Trimmed, childrenByGroup: Record<number, number[]> = {}) {\n  const trimmedGroup: TrimmedEntity = {};\n  const allTrimmed = gatherTrimmedItems(allTrimmedGroups);\n  // find is groups are filled\n  for (let groupIndex in childrenByGroup) {\n    const hasChidlren = childrenByGroup[groupIndex].filter(childIndex => !allTrimmed[childIndex]).length > 0;\n    if (!hasChidlren) {\n      trimmedGroup[groupIndex] = true;\n    }\n  }\n  return trimmedGroup;\n}\n","import baseGetTag from './_baseGetTag.js';\nimport isArray from './isArray.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nexport default isString;\n","import baseProperty from './_baseProperty.js';\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = baseProperty('length');\n\nexport default asciiSize;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nexport default hasUnicode;\n","/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\n\nexport default unicodeSize;\n","import asciiSize from './_asciiSize.js';\nimport hasUnicode from './_hasUnicode.js';\nimport unicodeSize from './_unicodeSize.js';\n\n/**\n * Gets the number of symbols in `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the string size.\n */\nfunction stringSize(string) {\n  return hasUnicode(string)\n    ? unicodeSize(string)\n    : asciiSize(string);\n}\n\nexport default stringSize;\n","import baseKeys from './_baseKeys.js';\nimport getTag from './_getTag.js';\nimport isArrayLike from './isArrayLike.js';\nimport isString from './isString.js';\nimport stringSize from './_stringSize.js';\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable string keyed properties for objects.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the collection size.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  if (collection == null) {\n    return 0;\n  }\n  if (isArrayLike(collection)) {\n    return isString(collection) ? stringSize(collection) : collection.length;\n  }\n  var tag = getTag(collection);\n  if (tag == mapTag || tag == setTag) {\n    return collection.size;\n  }\n  return baseKeys(collection).length;\n}\n\nexport default size;\n","import type { DataType } from '@type';\nimport type { SortingOrderFunction } from './sorting.types';\nimport { isGrouping } from '../groupingRow/grouping.service';\n\nexport function sortIndexByItems(\n  indexes: number[],\n  source: DataType[],\n  sortingFunc: SortingOrderFunction = {},\n): number[] {\n  // if no sorting - return unsorted indexes\n  if (Object.entries(sortingFunc).length === 0) {\n    // Unsorted indexes\n    return [...Array(indexes.length).keys()];\n  }\n  //\n  /**\n   * go through all indexes and align in new order\n   * performs a multi-level sorting by applying multiple comparison functions to determine the order of the items based on different properties.\n   */\n  return indexes.sort((a, b) => {\n    const itemA = source[a];\n    const itemB = source[b];\n    for (const [prop, cmp] of Object.entries(sortingFunc)) {\n      if (isGrouping(itemA)) {\n        if (itemA['__rvgr-prop'] !== prop) {\n          return 0;\n        }\n      }\n      if (isGrouping(itemB)) {\n        if (itemB['__rvgr-prop'] !== prop) {\n          return 0;\n        }\n      }\n      /**\n       * If the comparison function returns a non-zero value (sorted), it means that the items should be sorted based on the given property. In such a case, the function immediately returns the sorted value, indicating the order in which the items should be arranged.\n       * If none of the comparison functions result in a non-zero value, indicating that the items are equal or should remain in the same order, the function eventually returns 0.\n       */\n      const sorted = cmp?.(prop, itemA, itemB);\n      if (sorted) {\n        return sorted;\n      }\n    }\n    return 0;\n  });\n}\n","import size from 'lodash/size';\nimport debounce from 'lodash/debounce';\n\nimport { BasePlugin } from '../base.plugin';\nimport type {\n  ColumnProp,\n  Order,\n  CellCompareFunc,\n  ColumnRegular,\n  DataType,\n  DimensionRows,\n  PluginProviders,\n} from '@type';\nimport type { SortingConfig, SortingOrder, SortingOrderFunction } from './sorting.types';\nimport { getCellRaw, getColumnByProp } from '../../utils/column.utils';\nimport { rowTypes } from '@store';\nimport { sortIndexByItems } from './sorting.func';\n\n/**\n * Lifecycle\n * 1. @event `beforesorting` - Triggered when sorting just starts. Nothing has happened yet. This can be triggered from a column or from the source. If the type is from rows, the column will be undefined.\n * 2. @method `updateColumnSorting` - Updates the column sorting icon on the grid and the column itself, but the data remains untouched.\n * 3. @event `beforesortingapply` - Triggered before the sorting data is applied to the data source. You can prevent this event, and the data will not be sorted. This event is only called from a column sorting click.\n * 4. @event `aftersortingapply` - Triggered after sorting has been applied and completed. This event occurs for both row and column sorting.\n *\n * Note: If you prevent an event, it will not proceed to the subsequent steps.\n */\n\nexport class SortingPlugin extends BasePlugin {\n  // sorting order per column\n  sorting?: SortingOrder;\n\n  // sorting function per column, multiple columns sorting supported\n  sortingFunc?: SortingOrderFunction;\n  sortingPromise: (() => void) | null = null;\n  postponeSort = debounce(\n    (order?: SortingOrder, comparison?: SortingOrderFunction, ignoreViewportUpdate?: boolean) =>\n      this.runSorting(order, comparison, ignoreViewportUpdate),\n    50,\n  );\n\n  runSorting(\n    order?: SortingOrder,\n    comparison?: SortingOrderFunction,\n    ignoreViewportUpdate?: boolean\n  ) {\n    this.sort(order, comparison, undefined, ignoreViewportUpdate);\n    this.sortingPromise?.();\n    this.sortingPromise = null;\n  }\n\n  constructor(\n    public revogrid: HTMLRevoGridElement,\n    providers: PluginProviders,\n    config?: SortingConfig,\n  ) {\n    super(revogrid, providers);\n\n    const setConfig = (cfg?: SortingConfig) => {\n      if (cfg) {\n        const sortingFunc: SortingOrderFunction = {};\n        const order: SortingOrder = {};\n        cfg.columns?.forEach(col => {\n          sortingFunc[col.prop] = this.getComparer(col, col.order);\n          order[col.prop] = col.order;\n        });\n\n        // // set sorting\n        this.sorting = order;\n        this.sortingFunc = sortingFunc;\n      }\n    }\n\n    setConfig(config);\n\n    this.addEventListener('sortingconfigchanged', ({ detail }) => {\n      config = detail;\n      setConfig(detail);\n      this.startSorting(this.sorting, this.sortingFunc);\n    });\n\n    this.addEventListener('beforeanysource', ({\n      detail: { type },\n    }) => {\n      // if sorting was provided - sort data\n      if (!!this.sorting && this.sortingFunc) {\n        const beforeEvent = this.emit('beforesorting', { type });\n        if (beforeEvent.defaultPrevented) {\n          return;\n        }\n        this.startSorting(this.sorting, this.sortingFunc);\n      }\n    });\n    this.addEventListener('aftercolumnsset', ({\n      detail: { order },\n    }) => {\n      // if config provided - do nothing, read from config\n      if (config) {\n        return;\n      }\n\n      const columns = this.providers.column.getColumns();\n      const sortingFunc: SortingOrderFunction = {};\n\n      for (let prop in order) {\n        const cmp = this.getComparer(\n          getColumnByProp(columns, prop),\n          order[prop],\n        );\n        sortingFunc[prop] = cmp;\n      }\n\n      // set sorting\n      this.sorting = order;\n      this.sortingFunc = order && sortingFunc;\n    });\n    this.addEventListener('beforeheaderclick', (e) => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      if (!e.detail?.column?.sortable) {\n        return;\n      }\n\n      this.headerclick(\n        e.detail.column,\n        e.detail.index,\n        e.detail?.originalEvent?.shiftKey,\n      );\n    });\n  }\n\n  startSorting(order?: SortingOrder, sortingFunc?: SortingOrderFunction, ignoreViewportUpdate?: boolean) {\n    if (!this.sortingPromise) {\n      // add job before render\n      this.revogrid.jobsBeforeRender.push(\n        new Promise<void>(resolve => {\n          this.sortingPromise = resolve;\n        }),\n      );\n    }\n    this.postponeSort(order, sortingFunc, ignoreViewportUpdate);\n  }\n\n  getComparer(column: Partial<ColumnRegular> | undefined, order: Order): CellCompareFunc | undefined {\n    const cellCmp: CellCompareFunc =\n      column?.cellCompare?.bind({ order }) || this.defaultCellCompare?.bind({ column, order });\n    if (order == 'asc') {\n      return cellCmp;\n    }\n    if (order == 'desc') {\n      return this.descCellCompare(cellCmp);\n    }\n    return undefined;\n  }\n\n  /**\n   * Apply sorting to data on header click\n   * If additive - add to existing sorting, multiple columns can be sorted\n   */\n  headerclick(column: ColumnRegular, index: number, additive: boolean) {\n    let order: Order = this.getNextOrder(column.order);\n    const beforeEvent = this.emit('beforesorting', { column, order, additive });\n    if (beforeEvent.defaultPrevented) {\n      return;\n    }\n    order = beforeEvent.detail.order;\n    const newCol = this.providers.column.updateColumnSorting(\n      beforeEvent.detail.column,\n      index,\n      order,\n      additive,\n    );\n\n    // apply sort data\n    const beforeApplyEvent = this.emit('beforesortingapply', {\n      column: newCol,\n      order,\n      additive,\n    });\n    if (beforeApplyEvent.defaultPrevented) {\n      return;\n    }\n    const cmp = this.getComparer(beforeApplyEvent.detail.column, beforeApplyEvent.detail.order);\n\n    if (beforeApplyEvent.detail.additive && this.sorting) {\n      const sorting: SortingOrder = {};\n      const sortingFunc: SortingOrderFunction = {};\n\n      this.sorting = {\n        ...this.sorting,\n        ...sorting,\n      };\n      // extend sorting function with new sorting for multiple columns sorting\n      this.sortingFunc = {\n        ...this.sortingFunc,\n        ...sortingFunc,\n      };\n\n      if (column.prop in sorting && size(sorting) > 1 && order === undefined) {\n        delete sorting[column.prop];\n        delete sortingFunc[column.prop];\n      } else {\n        sorting[column.prop] = order;\n        sortingFunc[column.prop] = cmp;\n      }\n    } else {\n      if (order) {\n        // reset sorting\n        this.sorting = { [column.prop]: order };\n        this.sortingFunc = { [column.prop]: cmp };\n      } else {\n        delete this.sorting?.[column.prop];\n        delete this.sortingFunc?.[column.prop];\n      }\n    }\n\n    this.startSorting(this.sorting, this.sortingFunc);\n  }\n\n  /**\n   * Sort items by sorting function\n   * @requires proxyItems applied to row store\n   * @requires source applied to row store\n   *\n   * @param sorting - per column sorting\n   * @param data - this.stores['rgRow'].store.get('source')\n   */\n  sort(\n    sorting?: SortingOrder,\n    sortingFunc?: SortingOrderFunction,\n    types: DimensionRows[] = rowTypes,\n    ignoreViewportUpdate = false\n  ) {\n    // if no sorting - reset\n    if (!Object.keys(sorting || {}).length) {\n      for (let type of types) {\n        const storeService = this.providers.data.stores[type];\n        // row data\n        const source = storeService.store.get('source');\n        // row indexes\n        const proxyItems = storeService.store.get('proxyItems');\n        // row indexes\n        const newItemsOrder = Array.from({ length: source.length }, (_, i) => i); // recover indexes range(0, source.length)\n        this.providers.dimension.updateSizesPositionByNewDataIndexes(type, newItemsOrder, proxyItems);\n        storeService.setData({ proxyItems: newItemsOrder, source: [...source], });\n      }\n    } else {\n      for (let type of types) {\n        const storeService = this.providers.data.stores[type];\n        // row data\n        const source = storeService.store.get('source');\n        // row indexes\n        const proxyItems = storeService.store.get('proxyItems');\n\n        const newItemsOrder = sortIndexByItems(\n          [...proxyItems],\n          source,\n          sortingFunc,\n        );\n       \n        // take row indexes before trim applied and proxy items\n        const prevItems = storeService.store.get('items');\n        storeService.setData({\n          proxyItems: newItemsOrder,\n          source: [...source],\n        });\n        // take currently visible row indexes\n        const newItems = storeService.store.get('items');\n        if (!ignoreViewportUpdate) {\n          this.providers.dimension\n            .updateSizesPositionByNewDataIndexes(type, newItems, prevItems);\n        }\n      }\n    }\n    this.emit('aftersortingapply');\n  }\n\n  defaultCellCompare(this: { column?: ColumnRegular }, prop: ColumnProp, a: DataType, b: DataType) {\n    const aRaw = this.column ? getCellRaw(a, this.column) : a?.[prop];\n    const bRaw = this.column ? getCellRaw(b, this.column) : b?.[prop];\n    const av = aRaw?.toString().toLowerCase();\n    const bv = bRaw?.toString().toLowerCase();\n\n    return av == bv ? 0 : av > bv ? 1 : -1;\n  }\n\n  descCellCompare(cmp: CellCompareFunc) {\n    return (prop: ColumnProp, a: DataType, b: DataType): number => {\n      return -1 * cmp(prop, a, b);\n    };\n  }\n\n  getNextOrder(currentOrder: Order): Order {\n    switch (currentOrder) {\n      case undefined:\n        return 'asc';\n      case 'asc':\n        return 'desc';\n      case 'desc':\n        return undefined;\n    }\n  }\n}\n","import {\n  getPhysical,\n  setItems,\n  columnTypes,\n  type TrimmedEntity,\n  type DSourceState,\n} from '@store';\nimport { BasePlugin } from '../base.plugin';\nimport { FILTER_TRIMMED_TYPE } from '../filter/filter.plugin';\nimport {\n  GROUPING_ROW_TYPE,\n  PSEUDO_GROUP_COLUMN,\n} from './grouping.const';\nimport { doExpand, doCollapse } from './grouping.row.expand.service';\nimport type {\n  BeforeSourceSetEvent,\n  ExpandedOptions,\n  GroupingOptions,\n  OnExpandEvent,\n} from './grouping.row.types';\nimport {\n  gatherGrouping,\n  getExpanded,\n  getSource,\n  isGrouping,\n  isGroupingColumn,\n} from './grouping.service';\nimport {\n  processDoubleConversionTrimmed,\n  TRIMMED_GROUPING,\n} from './grouping.trimmed.service';\nimport type {\n  BeforeSaveDataDetails,\n  ColumnRegular,\n  DataType,\n  DimensionRows,\n  PluginProviders,\n} from '@type';\nimport type { Observable, ColumnCollection } from '../../utils';\nimport { SortingPlugin } from '../sorting/sorting.plugin';\n\ndeclare global {\n  interface HTMLRevoGridElementEventMap {\n    groupexpandclick: OnExpandEvent;\n  }\n}\n\nexport class GroupingRowPlugin extends BasePlugin {\n  private options: GroupingOptions | undefined;\n\n  getStore(\n    type: DimensionRows = GROUPING_ROW_TYPE,\n  ): Observable<DSourceState<DataType, DimensionRows>> {\n    return this.providers.data.stores[type].store;\n  }\n\n  constructor(\n    public revogrid: HTMLRevoGridElement,\n    public providers: PluginProviders,\n  ) {\n    super(revogrid, providers);\n  }\n\n  // befoce cell focus\n  private onFocus(e: CustomEvent<BeforeSaveDataDetails>) {\n    if (isGrouping(e.detail.model)) {\n      e.preventDefault();\n    }\n  }\n\n  // expand event triggered\n  private onExpand({ virtualIndex }: OnExpandEvent) {\n    const { source } = getSource(\n      this.getStore().get('source'),\n      this.getStore().get('proxyItems'),\n    );\n    let newTrimmed = this.getStore().get('trimmed')[TRIMMED_GROUPING];\n\n    let i = getPhysical(this.getStore(), virtualIndex);\n    const isExpanded = getExpanded(source[i]);\n    if (!isExpanded) {\n      const { trimmed, items } = doExpand(\n        virtualIndex,\n        source,\n        this.getStore().get('items'),\n      );\n      newTrimmed = { ...newTrimmed, ...trimmed };\n      if (items) {\n        setItems(this.getStore(), items);\n      }\n    } else {\n      const { trimmed } = doCollapse(i, source);\n      newTrimmed = { ...newTrimmed, ...trimmed };\n      this.revogrid.clearFocus();\n    }\n\n    this.getStore().set('source', source);\n    this.revogrid.addTrimmed(newTrimmed, TRIMMED_GROUPING);\n  }\n\n  private setColumnGrouping(cols?: ColumnRegular[]) {\n    // if 0 column as holder\n    if (cols?.length) {\n      cols[0][PSEUDO_GROUP_COLUMN] = true;\n      return true;\n    }\n    return false;\n  }\n\n  private setColumns({ columns }: ColumnCollection) {\n    for (let type of columnTypes) {\n      if (this.setColumnGrouping(columns[type])) {\n        break;\n      }\n    }\n  }\n\n  // evaluate drag between groups\n  private onDrag(e: CustomEvent<{ from: number; to: number }>) {\n    const { from, to } = e.detail;\n    const isDown = to - from >= 0;\n    const { source } = getSource(\n      this.getStore().get('source'),\n      this.getStore().get('proxyItems'),\n    );\n    const items = this.getStore().get('items');\n    let i = isDown ? from : to;\n    const end = isDown ? to : from;\n    for (; i < end; i++) {\n      const model = source[items[i]];\n      const isGroup = isGrouping(model);\n      if (isGroup) {\n        e.preventDefault();\n        return;\n      }\n    }\n  }\n\n  private beforeTrimmedApply(trimmed: Record<number, boolean>, type: string) {\n    /** Before filter apply remove grouping filtering */\n    if (type === FILTER_TRIMMED_TYPE) {\n      const source = this.getStore().get('source');\n      for (let index in trimmed) {\n        if (trimmed[index] && isGrouping(source[index])) {\n          trimmed[index] = false;\n        }\n      }\n    }\n  }\n\n  private isSortingRunning() {\n    const sortingPlugin = this.providers.plugins.getByClass(SortingPlugin);\n    return !!sortingPlugin?.sortingPromise;\n  }\n\n  // subscribe to grid events to process them accordingly\n  private subscribe() {\n    /** if grouping present and new data source arrived */\n    this.addEventListener('beforesourceset', ({ detail }) => {\n      if (!(this.options?.props?.length && detail?.source?.length)) {\n        return;\n      }\n      // if sorting is running don't apply grouping, wait for sorting, then it'll apply in @aftersortingapply\n      if (this.isSortingRunning()) {\n        return;\n      }\n      this.onDataSet(detail);\n    });\n    this.addEventListener('beforecolumnsset', ({ detail }) => {\n      this.setColumns(detail);\n    });\n\n    /**\n     * filter applied need to clear grouping and apply again\n     * based on new results can be new grouping\n     */\n    this.addEventListener(\n      'beforetrimmed',\n      ({ detail: { trimmed, trimmedType } }) =>\n        this.beforeTrimmedApply(trimmed, trimmedType),\n    );\n    /**\n     * sorting applied need to clear grouping and apply again\n     * based on new results whole grouping order will changed\n     */\n    this.addEventListener('aftersortingapply', () => {\n      if (!this.options?.props?.length) {\n        return;\n      }\n      this.doSourceUpdate({ ...this.options });\n    });\n\n    /**\n     * Apply logic for focus inside of grouping\n     * We can't focus on grouping rows, navigation only inside of groups for now\n     */\n    this.addEventListener('beforecellfocus', e => this.onFocus(e));\n    /**\n     * Prevent rgRow drag outside the group\n     */\n    this.addEventListener('roworderchanged', e => this.onDrag(e));\n\n    /**\n     * When grouping expand icon was clicked\n     */\n    this.addEventListener('groupexpandclick', e => this.onExpand(e.detail));\n  }\n\n  /**\n   * Starts global source update with group clearing and applying new one\n   * Initiated when need to reapply grouping\n   */\n  private doSourceUpdate(options?: ExpandedOptions) {\n    /**\n     * Get source without grouping\n     * @param newOldIndexMap - provides us mapping with new indexes vs old indexes, we would use it for trimmed mapping\n     */\n    const { source, prevExpanded, oldNewIndexes } = getSource(\n      this.getStore().get('source'),\n      this.getStore().get('proxyItems'),\n      true,\n    );\n    const expanded: ExpandedOptions = {\n      prevExpanded,\n      ...options,\n    };\n    /**\n     * Group again\n     * @param oldNewIndexMap - provides us mapping with new indexes vs old indexes\n     */\n    const {\n      sourceWithGroups,\n      depth,\n      trimmed,\n      oldNewIndexMap,\n      childrenByGroup,\n    } = gatherGrouping(source, this.options?.props || [], expanded);\n\n    const customRenderer = options?.groupLabelTemplate;\n\n    // setup source\n    this.providers.data.setData(\n      sourceWithGroups,\n      GROUPING_ROW_TYPE,\n      this.revogrid.disableVirtualY,\n      { depth, customRenderer },\n      true,\n    );\n    this.updateTrimmed(\n      trimmed,\n      childrenByGroup,\n      oldNewIndexes ?? {},\n      oldNewIndexMap,\n    );\n  }\n\n  /**\n   * Apply grouping on data set\n   * Clear grouping from source\n   * If source came from other plugin\n   */\n  private onDataSet(data: BeforeSourceSetEvent) {\n    let preservedExpanded: ExpandedOptions['prevExpanded'] = {};\n    if (this.options?.preserveGroupingOnUpdate !== false) {\n      let { prevExpanded } = getSource(\n        this.getStore().get('source'),\n        this.getStore().get('proxyItems'),\n        true,\n      );\n      preservedExpanded = prevExpanded;\n    }\n    const source = data.source.filter(s => !isGrouping(s));\n    const options: ExpandedOptions = {\n      ...(this.revogrid.grouping || {}),\n      prevExpanded: preservedExpanded,\n    };\n    const {\n      sourceWithGroups,\n      depth,\n      trimmed,\n      oldNewIndexMap,\n      childrenByGroup,\n    } = gatherGrouping(source, this.options?.props || [], options);\n    data.source = sourceWithGroups;\n    this.providers.data.setGrouping({ depth });\n    this.updateTrimmed(trimmed, childrenByGroup, oldNewIndexMap);\n  }\n\n  /**\n   * Externam call to apply grouping. Called by revogrid when prop changed.\n   */\n  setGrouping(options: GroupingOptions) {\n    // unsubscribe from all events when group applied\n    this.clearSubscriptions();\n    this.options = options;\n    // clear props, no grouping exists\n    if (!this.options?.props?.length) {\n      this.clearGrouping();\n      return;\n    }\n    // props exist and source inited\n    const { source } = getSource(\n      this.getStore().get('source'),\n      this.getStore().get('proxyItems'),\n    );\n    if (source.length) {\n      this.doSourceUpdate({ ...options });\n    }\n    // props exist and columns inited\n    for (let t of columnTypes) {\n      if (this.setColumnGrouping(this.providers.column.getColumns(t))) {\n        this.providers.column.refreshByType(t);\n        break;\n      }\n    }\n\n    // if has any grouping subscribe to events again\n    this.subscribe();\n  }\n\n  // clear grouping\n  clearGrouping() {\n    // clear columns\n    columnTypes.forEach(t => {\n      const cols = this.providers.column.getColumns(t);\n      let deleted = false;\n      cols.forEach(c => {\n        if (isGroupingColumn(c)) {\n          delete c[PSEUDO_GROUP_COLUMN];\n          deleted = true;\n        }\n      });\n      // if column store had grouping clear and refresh\n      if (deleted) {\n        this.providers.column.refreshByType(t);\n      }\n    });\n    // clear rows\n    const { source, oldNewIndexes } = getSource(\n      this.getStore().get('source'),\n      this.getStore().get('proxyItems'),\n      true,\n    );\n    this.providers.data.setData(\n      source,\n      GROUPING_ROW_TYPE,\n      this.revogrid.disableVirtualY,\n      undefined,\n      true,\n    );\n    this.updateTrimmed(undefined, undefined, oldNewIndexes);\n  }\n\n  private updateTrimmed(\n    trimmedGroup: TrimmedEntity = {},\n    _childrenByGroup: Record<number, number[]> = {},\n    firstLevelMap: Record<number, number> = {},\n    secondLevelMap?: Record<number, number>,\n  ) {\n    // map previously trimmed data\n    const trimemedOptionsToUpgrade = processDoubleConversionTrimmed(\n      this.getStore().get('trimmed'),\n      firstLevelMap,\n      secondLevelMap,\n    );\n    for (let type in trimemedOptionsToUpgrade) {\n      this.revogrid.addTrimmed(trimemedOptionsToUpgrade[type], type);\n    }\n\n    // const emptyGroups = this.filterOutEmptyGroups(trimemedOptionsToUpgrade, childrenByGroup);\n\n    // setup trimmed data for grouping\n    this.revogrid.addTrimmed({ ...trimmedGroup }, TRIMMED_GROUPING);\n  }\n}\n","const COLUMN_DRAG_CLASS = 'column-drag-start';\n\nexport class ColumnOrderHandler {\n  private element?: HTMLDivElement;\n  private autoscrollEl?: HTMLElement;\n  private offset = 0;\n\n  renderAutoscroll(_: MouseEvent, parent: HTMLElement | null) {\n    if (!parent) {\n      return;\n    }\n    this.autoscrollEl = document.createElement('div');\n    this.autoscrollEl.classList.add('drag-auto-scroll-y');\n    parent.appendChild(this.autoscrollEl);\n  }\n\n  autoscroll(pos: number, dataContainerSize: number, direction = 'translateX') {\n    if (!this.autoscrollEl) {\n      return;\n    }\n    const helperOffset = 10;\n    // calculate current y position inside of the grid active holder\n    // 3 - size of element + border\n    const maxScroll = Math.min(pos + helperOffset, dataContainerSize - 3);\n\n    this.autoscrollEl.style.transform = `${direction}(${maxScroll}px)`;\n    this.autoscrollEl.scrollIntoView({\n      block: 'nearest',\n      inline: 'nearest',\n    });\n  }\n\n  start(e: MouseEvent, { dataEl, gridRect, scrollEl, gridEl }: {\n    dataEl: HTMLElement;\n    gridRect: DOMRect;\n    scrollEl: Element;\n    gridEl: Element;\n  }, dir: 'top' | 'left'  = 'left') {\n    gridEl.classList.add(COLUMN_DRAG_CLASS);\n    const scrollContainerRect = scrollEl.getBoundingClientRect();\n    if (scrollContainerRect) {\n      this.offset = scrollContainerRect[dir] - gridRect[dir];\n    }\n    this.renderAutoscroll(e, dataEl);\n  }\n\n  stop(gridEl: Element) {\n    gridEl.classList.remove(COLUMN_DRAG_CLASS);\n    if (this.element) {\n      this.element.hidden = true;\n    }\n    this.offset = 0;\n    this.autoscrollEl?.remove();\n    this.autoscrollEl = undefined;\n  }\n\n  showHandler(pos: number, size: number, direction = 'translateX') {\n    if (!this.element) {\n      return;\n    }\n    // do not allow overcross top of the scrollable area, header excluded\n    if (this.offset) {\n      pos = Math.max(pos, this.offset);\n    }\n    // can not be bigger then grid end\n    pos = Math.min(pos, size);\n    this.element.style.transform = `${direction}(${pos}px)`;\n    this.element.hidden = false;\n  }\n\n  render() {\n    const el = this.element = document.createElement('div');\n    el.classList.add('drag-position-y');\n    el.hidden = true;\n    return el;\n  }\n}\n","/**\n * Plugin for column manual move\n */\nimport debounce from 'lodash/debounce';\nimport each from 'lodash/each';\nimport { getItemByPosition } from '@store';\nimport { BasePlugin } from '../base.plugin';\nimport { ColumnOrderHandler } from './order-column.handler';\nimport { dispatch } from '../dispatcher';\nimport type { ColumnPropProp, ColumnTemplateProp, DimensionSettingsState, PositionItem, DimensionCols, MultiDimensionType, PluginProviders } from '@type';\nimport { ON_COLUMN_CLICK } from '../../components/header/header-cell-renderer';\nimport { isColGrouping } from '../../utils/column.utils';\n\nconst COLUMN_CLICK = ON_COLUMN_CLICK;\nconst MOVE = 'columndragmousemove';\nconst DRAG_END = 'columndragend';\nconst BEFORE_DRAG_END = 'beforecolumndragend';\n\n// use this event subscription to drop D&D for particular columns\nconst DRAG_START = 'columndragstart';\n\nexport type DragStartEventDetails = {\n  event: MouseEvent;\n  data: ColumnPropProp;\n};\n\ntype StaticData = {\n  startPos: number;\n  startItem: PositionItem;\n  data: ColumnTemplateProp;\n  dataEl: HTMLElement;\n  scrollEl: Element;\n  gridEl: HTMLElement;\n  cols: DimensionSettingsState;\n};\n\ntype LocalSubscriptions = Record<string, LocalSubscription>;\ntype LocalSubscription = {\n  target: Element | Document;\n  callback(...params: any[]): void;\n};\nexport type ColumnDragEventData = {\n  elRect: DOMRect;\n  gridRect: DOMRect;\n  scrollOffset: number;\n  type: DimensionCols;\n};\nexport class ColumnMovePlugin extends BasePlugin {\n  private moveFunc = debounce((e: MouseEvent) => this.doMove(e), 5);\n  private staticDragData: StaticData | null = null;\n  private dragData: ColumnDragEventData | null = null;\n  private readonly orderUi: ColumnOrderHandler;\n  protected readonly localSubscriptions: LocalSubscriptions = {};\n  constructor(public revogrid: HTMLRevoGridElement, public providers: PluginProviders) {\n    super(revogrid, providers);\n    this.orderUi = new ColumnOrderHandler();\n    revogrid.appendChild(this.orderUi.render());\n    revogrid.classList.add('column-draggable');\n\n    // Register events\n    this.localSubscriptions['mouseleave'] = {\n      target: document,\n      callback: (e: MouseEvent) => this.onMouseOut(e),\n    };\n    this.localSubscriptions['mouseup'] = {\n      target: document,\n      callback: (e: MouseEvent) => this.onMouseUp(e),\n    };\n\n    this.localSubscriptions['mousemove'] = {\n      target: document,\n      callback: (e: MouseEvent) => this.move(e),\n    };\n\n    this.addEventListener(COLUMN_CLICK, ({ detail }) => this.dragStart(detail));\n  }\n\n  dragStart({ event, data }: DragStartEventDetails) {\n    if (event.defaultPrevented) {\n      return;\n    }\n    const { defaultPrevented } = dispatch(this.revogrid, DRAG_START, data);\n    // check if allowed to drag particulat column\n    if (defaultPrevented) {\n      return;\n    }\n    this.clearOrder();\n    const { mouseleave, mouseup, mousemove } = this.localSubscriptions;\n    mouseleave.target.addEventListener('mouseleave', mouseleave.callback);\n    mouseup.target.addEventListener('mouseup', mouseup.callback);\n\n    const dataEl = (event.target as HTMLElement).closest('revogr-header');\n    const scrollEl = (event.target as HTMLElement).closest('revogr-viewport-scroll');\n    if (!dataEl || !scrollEl) {\n      return;\n    }\n\n    // no grouping drag and no row header column drag\n    if (isColGrouping(data) || data.providers.type === 'rowHeaders') {\n      return;\n    }\n\n    const cols = this.getDimension(data.pin || 'rgCol');\n    const gridRect = this.revogrid.getBoundingClientRect();\n    const elRect = dataEl.getBoundingClientRect();\n    const startItem = getItemByPosition(\n      cols,\n      getLeftRelative(event.x, gridRect.left, elRect.left - gridRect.left));\n  \n    this.staticDragData = {\n      startPos: event.x,\n      startItem,\n      data,\n      dataEl,\n      scrollEl,\n      gridEl: this.revogrid,\n      cols,\n    };\n    this.dragData = this.getData(this.staticDragData);\n    mousemove.target.addEventListener('mousemove', mousemove.callback);\n    this.orderUi.start(event, {\n      ...this.dragData,\n      ...this.staticDragData,\n    });\n  }\n\n  doMove(e: MouseEvent) {\n    if (!this.staticDragData) {\n      return;\n    }\n\n    const dragData = (this.dragData = this.getData(this.staticDragData));\n    if (!dragData) {\n      return;\n    }\n    const start = this.staticDragData.startPos;\n    if (Math.abs(start - e.x) > 10) {\n      const x = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);\n      const rgCol = getItemByPosition(this.staticDragData.cols, x);\n      this.orderUi.autoscroll(x, dragData.elRect.width);\n\n      // prevent position change if out of bounds\n      if (rgCol.itemIndex >= this.staticDragData.cols.count) {\n        return;\n      }\n      this.orderUi.showHandler(\n        rgCol.end + dragData.scrollOffset,\n        dragData.gridRect.width\n      );\n    }\n  }\n\n  move(e: MouseEvent) {\n    dispatch(this.revogrid, MOVE, e);\n    // then do move\n    this.moveFunc(e);\n  }\n  onMouseOut(_: MouseEvent) {\n    this.clearOrder();\n  }\n  onMouseUp(e: MouseEvent) {\n    // apply new positions\n    if (this.dragData && this.staticDragData) {\n      let relativePos = getLeftRelative(e.x, this.dragData.gridRect.left, this.dragData.scrollOffset);\n      if (relativePos < 0) {\n        relativePos = 0;\n      }\n      const newPosition = getItemByPosition(this.staticDragData.cols, relativePos);\n\n      const store = this.providers.column.stores[this.dragData.type].store;\n      const newItems = [...store.get('items')];\n\n      // prevent position change if needed\n      const { defaultPrevented: stopDrag } = dispatch(this.revogrid, BEFORE_DRAG_END, {\n        ...this.staticDragData,\n        startPosition: this.staticDragData.startItem,\n        newPosition,\n        newItem: store.get('source')[newItems[this.staticDragData.startItem.itemIndex]]\n      });\n      if (!stopDrag) {\n        const prevItems = [...newItems];\n        // todo: if move item out of group remove item from group\n        const toMove = newItems.splice(this.staticDragData.startItem.itemIndex, 1);\n        newItems.splice(newPosition.itemIndex, 0, ...toMove);\n        store.set('items', newItems);\n        this.providers.dimension.updateSizesPositionByNewDataIndexes(this.dragData.type, newItems, prevItems);\n      }\n      dispatch(this.revogrid, DRAG_END, this.dragData);\n    }\n    this.clearOrder();\n  }\n\n  private clearLocalSubscriptions() {\n    each(this.localSubscriptions, ({ target, callback }, key) => target.removeEventListener(key, callback));\n  }\n\n  clearOrder() {\n    this.staticDragData = null;\n    this.dragData = null;\n    this.clearLocalSubscriptions();\n    this.orderUi.stop(this.revogrid);\n  }\n  /**\n   * Clearing subscription\n   */\n  clearSubscriptions() {\n    super.clearSubscriptions();\n    this.clearLocalSubscriptions();\n  }\n\n  private getData({\n    gridEl,\n    dataEl,\n    data,\n  }: StaticData): ColumnDragEventData {\n    const gridRect = gridEl.getBoundingClientRect();\n    const elRect = dataEl.getBoundingClientRect();\n    const scrollOffset = elRect.left - gridRect.left;\n    return {\n      elRect,\n      gridRect,\n      type: data.pin || 'rgCol',\n      scrollOffset,\n    };\n  }\n  private getDimension(type: MultiDimensionType) {\n    return this.providers.dimension.stores[type].getCurrentState();\n  }\n}\n\nexport function getLeftRelative(\n  absoluteX: number,\n  gridPos: number,\n  offset: number\n): number {\n  return absoluteX - gridPos - offset;\n}\n"],"mappings":"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","ignoreList":[]}