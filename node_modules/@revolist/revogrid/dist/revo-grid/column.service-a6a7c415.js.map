{"version":3,"names":["arrayReduce","array","iteratee","accumulator","initAccum","index","length","createBaseFor","fromRight","object","keysFunc","iterable","Object","props","key","baseFor","baseFor$1","baseForOwn","keys","createBaseEach","eachFunc","collection","isArrayLike","baseEach","baseEach$1","baseReduce","value","reduce","func","isArray","arguments","baseIteratee","getCellData","val","getCellRaw","model","column","cellParser","prop","getCellDataParsed","getColumnType","rgCol","pin","getColumnSizes","cols","res","i","c","entries","size","isColGrouping","colData","children","getColumns","columns","level","types","colPinStart","colPinEnd","columnByProp","columnGrouping","maxLevel","sort","gatherGroup","columnDefinitionFromType","columnType","regularColumn","assign","push","order","beforeSetup","group","ids","k","resultItem","collectionItem","map","item","Math","max","findColumn","found","undefined","getColumnByProp","defaultState","range","tempRange","tempRangeType","focus","edit","lastCell","nextFocus","SelectionStore","constructor","this","unsubscribe","store","createStore","on","newVal","set","onChange","propName","cb","clearFocus","setStore","setFocus","end","getRange","setNextFocus","setTempArea","area","type","clearTemp","setRangeArea","setRange","start","setLastCell","setEdit","get","x","y","dispose","forEach","f","EMPTY_INDEX","SelectionStoreConnector","dirty","stores","columnStores","rowStores","storesByType","storesXToType","storesYToType","sections","focusedStore","focused","_a","entity","cell","position","parseInt","selectedRange","registerSection","e","indexOf","beforeUpdate","registerColumn","isHiddenStore","registerRow","register","_b","destroy","setEditByCell","storePos","editCell","focusByCell","beforeNextFocusCell","next","getNextStore","currentStorePointer","getCurrentStorePointer","cropCellToMax","s","nextItem","nextCell","nextStore","nextItemCoord","getXStores","getYStores","nextLastCell","clearAll","selectAll","pos","t","croppedCell","cellCoordinates","coordinate","min","x1","y1","isRangeSingleCell","a","GROUP_DEPTH","GRID_INTERNALS","PSEUDO_GROUP_ITEM","PSEUDO_GROUP_ITEM_ID","PSEUDO_GROUP_ITEM_VALUE","PSEUDO_GROUP_COLUMN","GROUP_EXPANDED","GROUP_COLUMN_PROP","GROUP_ORIGINAL_INDEX","GROUP_EXPAND_BTN","GROUPING_ROW_TYPE","getGroupValueDefault","getSource","source","items","withoutGrouping","result","prevExpanded","oldNewIndexes","isGrouping","getExpanded","gatherGrouping","columnProps","expandedAll","getGroupValue","groupedItems","Map","originalIndex","groupLevelValues","groupId","lastLevelValue","pop","currentGroupLevel","has","lastLevelItems","itemIndex","groupingDepth","trimmed","oldNewIndexMap","pseudoGroupTest","sourceWithGroups","flattenGroupMaps","groupedValues","parentIds","isExpanded","depth","innerGroupedValues","levelIds","mergedIds","join","isGroupExpanded","JSON","stringify","Array","pseudoGroupTestIds","_value","slice","pseudoGroupTestId","childrenByGroup","getGroupingName","rgRow","isGroupingColumn","measureEqualDepth","groupA","groupB","ln","getParsedGroup","id","parseGroup","parse","isSameGroup","currentGroup","currentModel","nextModel","nextGroup","baseSlice","isIterateeCall","toInteger","ColumnService","getVisibleSourceItem","dataStore","hasGrouping","checkGrouping","isReadOnly","r","readOnly","readonly","data","rowDataModel","mergeProperties","defaultProps","schemaModel","class","CELL_CLASS","DISABLED_CLASS","extra","cellProperties","call","doPropMerge","getRowClass","getSourceItem","getSaveData","rowIndex","colIndex","getCellEditor","_r","editors","editor","colType","getRangeData","d","changed","copyColLength","oldRange","copyRowLength","mapping","newRange","oldRowIndex","copyRow","j","copyColIndex","copyColumnProp","colProp","getTransformedDataToApply","colLength","rowLength","maxCol","p","currentCol","getRangeStaticData","getRangeTransformedToProps","copyRangeArray","v","toCopy","isRowDragService","rowDrag","mergeClasses","class1","class2","existing","className","style"],"sources":["node_modules/lodash/_arrayReduce.js","node_modules/lodash/_createBaseFor.js","node_modules/lodash/_baseFor.js","node_modules/lodash/_baseForOwn.js","node_modules/lodash/_createBaseEach.js","node_modules/lodash/_baseEach.js","node_modules/lodash/_baseReduce.js","node_modules/lodash/reduce.js","src/utils/column.utils.ts","src/store/selection/selection.store.ts","src/services/selection.store.connector.ts","src/store/selection/selection.helpers.ts","src/plugins/groupingRow/grouping.const.ts","src/plugins/groupingRow/grouping.service.ts","node_modules/lodash/_baseSlice.js","node_modules/lodash/slice.js","src/components/data/column.service.ts"],"sourcesContent":["/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nexport default arrayReduce;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nexport default createBaseFor;\n","import createBaseFor from './_createBaseFor.js';\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nexport default baseFor;\n","import baseFor from './_baseFor.js';\nimport keys from './keys.js';\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nexport default baseForOwn;\n","import isArrayLike from './isArrayLike.js';\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nexport default createBaseEach;\n","import baseForOwn from './_baseForOwn.js';\nimport createBaseEach from './_createBaseEach.js';\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nexport default baseEach;\n","/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nexport default baseReduce;\n","import arrayReduce from './_arrayReduce.js';\nimport baseEach from './_baseEach.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseReduce from './_baseReduce.js';\nimport isArray from './isArray.js';\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nexport default reduce;\n","import isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\n\nimport {\n  ColumnData,\n  ColumnGrouping,\n  ColumnProp,\n  ColumnRegular,\n  ColumnTypes,\n  DataType,\n  DimensionCols,\n  ViewSettingSizeProp,\n} from '@type';\nimport { Group as StoreGroup } from '@store';\n\nexport type ColumnItems = Record<DimensionCols, ColumnRegular[]>;\nexport interface ColumnGroup extends StoreGroup {\n  level: number;\n}\nexport type ColumnGroupingCollection = Record<DimensionCols, ColumnGroup[]>;\n\nexport function getCellData(val?: any) {\n  if (typeof val === 'undefined' || val === null) {\n    return '';\n  }\n  return val;\n}\n\nexport function getCellRaw(model: DataType, column?: ColumnRegular) {\n  if (!column) {\n    return;\n  }\n  if (column.cellParser) {\n    return column.cellParser(model, column);\n  }\n  return model[column.prop];\n}\n\nexport function getCellDataParsed(model: DataType, column: ColumnRegular) {\n  return getCellData(getCellRaw(model, column));\n}\n\n/**\n * Column collection definition.\n * Used to access indexed data for columns.\n * Can be accessed via different events.\n */\nexport type ColumnCollection = {\n  /**\n   * Columns as they are in stores\n   */\n  columns: Record<DimensionCols, ColumnRegular[]>;\n  /**\n   * Columns indexed by prop for quick access, it's possible to have multiple columns with same prop but not recommended\n   */\n  columnByProp: Record<ColumnProp, ColumnRegular[]>;\n  /**\n   * Grouped columns\n   */\n  columnGrouping: ColumnGroupingCollection;\n  /**\n   * Max level of grouping\n   */\n  maxLevel: number;\n  /**\n   * Sorting\n   */\n  sort: Record<ColumnProp, ColumnRegular>;\n};\n\n/**\n * Get column type from column data\n */\nexport function getColumnType(rgCol: ColumnRegular): DimensionCols {\n  if (rgCol.pin) {\n    return rgCol.pin;\n  }\n  return 'rgCol';\n}\n\nexport function getColumnSizes(cols: ColumnRegular[]): ViewSettingSizeProp {\n  const res: ViewSettingSizeProp = {};\n  for (const [i, c] of cols.entries()) {\n    if (c.size) {\n      res[i] = c.size;\n    }\n  }\n  return res;\n}\n\n\n/**\n * Check if column is grouping column\n */\nexport function isColGrouping(\n  colData: ColumnGrouping | ColumnRegular,\n): colData is ColumnGrouping {\n  return !!(colData as ColumnGrouping).children;\n}\n\n/**\n * This function is used to create a collection of columns.\n */\nexport function getColumns(\n  columns: ColumnData,\n  level = 0,\n  types?: ColumnTypes,\n): ColumnCollection {\n  const collection: ColumnCollection = {\n    // columns as they are in stores per type\n    columns: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // columns indexed by prop for quick access\n    columnByProp: {},\n    // column grouping\n    columnGrouping: {\n      rgCol: [],\n      colPinStart: [],\n      colPinEnd: [],\n    },\n    // max depth level for column grouping\n    maxLevel: level,\n    // sorting\n    sort: {},\n  };\n\n  return reduce(\n    columns,\n    (res: ColumnCollection, colData: ColumnGrouping | ColumnRegular) => {\n      // Grouped column\n      if (isColGrouping(colData)) {\n        res = gatherGroup(\n          res,\n          colData,\n          getColumns(colData.children, level + 1, types),\n          level,\n        );\n        return res;\n      }\n      // Column type\n      const columnDefinitionFromType = colData.columnType && types?.[colData.columnType];\n      // Regular column\n      const regularColumn = {\n        ...columnDefinitionFromType,\n        ...colData,\n      };\n      // Regular column, no Pin\n      if (!regularColumn.pin) {\n        res.columns.rgCol.push(regularColumn);\n        // Pin\n      } else {\n        res.columns[regularColumn.pin].push(regularColumn);\n      }\n      if (regularColumn.order) {\n        res.sort[regularColumn.prop] = regularColumn;\n      }\n      // it's possible that some columns have same prop, but better to avoid it\n      if (!res.columnByProp[regularColumn.prop]) {\n        res.columnByProp[regularColumn.prop] = [];\n      }\n      res.columnByProp[regularColumn.prop].push(regularColumn);\n\n      // trigger setup hook if present\n      regularColumn.beforeSetup && regularColumn.beforeSetup(regularColumn);\n      return res;\n    },\n    collection,\n  );\n}\n\nexport function gatherGroup<T extends ColumnCollection>(\n  res: T,\n  colData: ColumnGrouping,\n  collection: T,\n  level = 0,\n): T {\n  // group template\n  const group: ColumnGroup = {\n    ...colData,\n    level,\n    ids: [],\n  };\n\n  // check columns for update\n  for (let k in collection.columns) {\n    const key = k as keyof ColumnCollection['columns'];\n    const resultItem = res.columns[key];\n    const collectionItem = collection.columns[key];\n\n    // if column data\n    if (isArray(resultItem) && isArray(collectionItem)) {\n      // fill columns\n      resultItem.push(...collectionItem);\n\n      // fill grouping\n      if (collectionItem.length) {\n        res.columnGrouping[key].push({\n          ...group,\n          ids: collectionItem.map(item => item.prop),\n        });\n      }\n    }\n  }\n  // merge column groupings\n  for (let k in collection.columnGrouping) {\n    const key = k as DimensionCols;\n    const collectionItem = collection.columnGrouping[key];\n    res.columnGrouping[key].push(...collectionItem);\n  }\n  res.maxLevel = Math.max(res.maxLevel, collection.maxLevel);\n  res.sort = { ...res.sort, ...collection.sort };\n  res.columnByProp = {\n    ...res.columnByProp,\n    ...collection.columnByProp,\n  };\n  return res;\n}\n\nfunction findColumn(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  for (const c of columns) {\n    if (isColGrouping(c)) {\n      const found = findColumn(c.children, prop);\n      if (found) {\n        return found;\n      }\n    } else if (c.prop === prop) {\n      return c;\n    }\n  }\n  return undefined;\n}\n\nexport function getColumnByProp(\n  columns: ColumnData,\n  prop: ColumnProp,\n): ColumnRegular | undefined {\n  return findColumn(columns, prop);\n}\n","/**\n * Selection store\n */\n\nimport { setStore, Observable } from '../../utils';\nimport { getRange } from '@store';\nimport { SelectionStoreState, Cell, TempRange, RangeArea, Nullable } from '@type';\nimport { createStore } from '@stencil/store';\n\nfunction defaultState(): SelectionStoreState {\n  return {\n    range: null,\n    tempRange: null,\n    tempRangeType: null,\n    focus: null,\n    edit: null,\n    lastCell: null,\n    nextFocus: null,\n  };\n}\n\nexport class SelectionStore {\n  readonly store: Observable<SelectionStoreState>;\n  private unsubscribe: { (): void }[] = [];\n  constructor() {\n    this.store = createStore(defaultState());\n    this.store.on('set', (key, newVal) => {\n      if (key === 'tempRange' && !newVal) {\n        this.store.set('tempRangeType', null);\n      }\n    });\n  }\n\n  onChange<Key extends keyof SelectionStoreState>(propName: Key, cb: (newValue: SelectionStoreState[Key]) => void) {\n    this.unsubscribe.push(this.store.onChange(propName, cb));\n  }\n\n  clearFocus() {\n    setStore(this.store, { focus: null, range: null, edit: null, tempRange: null });\n  }\n\n  setFocus(focus: Cell, end?: Cell) {\n    if (!end) {\n      setStore(this.store, { focus });\n    } else {\n      setStore(this.store, {\n        focus,\n        range: getRange(focus, end),\n        edit: null,\n        tempRange: null,\n      });\n    }\n  }\n\n  setNextFocus(focus: Cell) {\n    setStore(this.store, { nextFocus: focus });\n  }\n\n  setTempArea(range: Nullable<TempRange> | null) {\n    setStore(this.store, { tempRange: range?.area, tempRangeType: range?.type, edit: null });\n  }\n\n  clearTemp() {\n    setStore(this.store, { tempRange: null });\n  }\n\n  /** Can be applied from selection change or from simple keyboard change clicks */\n  setRangeArea(range: RangeArea | null) {\n    setStore(this.store, { range, edit: null, tempRange: null });\n  }\n  setRange(start: Cell, end: Cell) {\n    const range = getRange(start, end);\n    this.setRangeArea(range);\n  }\n\n  setLastCell(lastCell: Cell) {\n    setStore(this.store, { lastCell });\n  }\n\n  setEdit(val?: string | boolean) {\n    const focus = this.store.get('focus');\n    if (focus && typeof val === 'string') {\n      setStore(this.store, {\n        edit: { x: focus.x, y: focus.y, val },\n      });\n      return;\n    }\n    setStore(this.store, { edit: null });\n  }\n\n  dispose() {\n    this.unsubscribe.forEach(f => f());\n    this.store.dispose();\n  }\n}\n","import { cropCellToMax, isHiddenStore, nextCell, SelectionStore } from '@store';\nimport type {\n  MultiDimensionType,\n  DimensionCols,\n  DimensionRows,\n  Cell,\n  EditCellStore,\n  RangeArea,\n} from '@type';\n\ntype StoreByDimension = Record<number, SelectionStore>;\ntype FocusedStore = {\n  entity: SelectionStore;\n  cell: Cell;\n  position: Cell;\n};\n\ntype StoresMapping<T> = { [xOrY: number]: Partial<T> };\n\nexport const EMPTY_INDEX = -1;\n\nexport class SelectionStoreConnector {\n  // dirty flag required to cleanup whole store in case visibility of panels changed\n  private dirty = false;\n  readonly stores: { [y: number]: { [x: number]: SelectionStore } } = {};\n\n  readonly columnStores: StoreByDimension = {};\n  readonly rowStores: { [y: number]: SelectionStore } = {};\n\n  /**\n   * Helpers for data conversion\n   */\n  readonly storesByType: Partial<Record<MultiDimensionType, number>> = {};\n  readonly storesXToType: StoresMapping<DimensionCols> = {};\n  readonly storesYToType: StoresMapping<DimensionRows> = {};\n\n  get focusedStore(): FocusedStore | null {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const focused = this.stores[y][x]?.store.get('focus');\n        if (focused) {\n          return {\n            entity: this.stores[y][x],\n            cell: focused,\n            position: {\n              x: parseInt(x, 10),\n              y: parseInt(y, 10),\n            },\n          };\n        }\n      }\n    }\n    return null;\n  }\n\n  get edit(): EditCellStore | null | undefined {\n    return this.focusedStore?.entity.store.get('edit');\n  }\n\n  get focused(): Cell | null | undefined {\n    return this.focusedStore?.entity.store.get('focus');\n  }\n\n  get selectedRange(): RangeArea | null | undefined {\n    return this.focusedStore?.entity.store.get('range');\n  }\n\n  private readonly sections: Element[] = [];\n\n  registerSection(e?: Element) {\n    if (!e) {\n      this.sections.length = 0;\n      // some elements removed, rebuild stores\n      this.dirty = true;\n      return;\n    }\n    if (this.sections.indexOf(e) === -1) {\n      this.sections.push(e);\n    }\n  }\n\n  // check if require to cleanup all stores\n  beforeUpdate() {\n    if (this.dirty) {\n      for (let y in this.stores) {\n        for (let x in this.stores[y]) {\n          this.stores[y][x].dispose();\n        }\n      }\n      this.dirty = false;\n    }\n  }\n\n  registerColumn(x: number, type: DimensionCols): SelectionStore {\n    // if hidden just create store but no operations needed\n    if (isHiddenStore(x)) {\n      return new SelectionStore();\n    }\n    if (this.columnStores[x]) {\n      return this.columnStores[x];\n    }\n    this.columnStores[x] = new SelectionStore();\n    // build cross-linking type to position\n    this.storesByType[type] = x;\n    this.storesXToType[x] = type;\n    return this.columnStores[x];\n  }\n\n  registerRow(y: number, type: DimensionRows): SelectionStore {\n    // if hidden just create store\n    if (isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (this.rowStores[y]) {\n      return this.rowStores[y];\n    }\n    this.rowStores[y] = new SelectionStore();\n    // build cross linking type to position\n    this.storesByType[type] = y;\n    this.storesYToType[y] = type;\n    return this.rowStores[y];\n  }\n\n  /**\n   * Cross store proxy, based on multiple dimensions\n   */\n  register({ x, y }: Cell): SelectionStore {\n    // if hidden just create store\n    if (isHiddenStore(x) || isHiddenStore(y)) {\n      return new SelectionStore();\n    }\n    if (!this.stores[y]) {\n      this.stores[y] = {};\n    }\n    if (this.stores[y][x]) {\n      // Store already registered. Do not register twice\n      return this.stores[y][x];\n    }\n    this.stores[y][x] = new SelectionStore();\n    // proxy update, column store trigger only range area\n    this.stores[y][x]?.onChange('range', c => {\n      this.columnStores[x].setRangeArea(c);\n      this.rowStores[y].setRangeArea(c);\n    });\n    // clean up on remove\n    this.stores[y][x]?.store.on('dispose', () => this.destroy(x, y));\n    return this.stores[y][x];\n  }\n\n  private destroy(x: number, y: number) {\n    this.columnStores[x]?.dispose();\n    this.rowStores[y]?.dispose();\n\n    delete this.rowStores[y];\n    delete this.columnStores[x];\n    // clear x cross-link\n    if (this.storesXToType[x]) {\n      const type = this.storesXToType[x];\n      delete this.storesXToType[x];\n      delete this.storesByType[type];\n    }\n    // clear y cross-link\n    if (this.storesYToType[y]) {\n      const type = this.storesYToType[y];\n      delete this.storesYToType[y];\n      delete this.storesByType[type];\n    }\n    if (this.stores[y]) {\n      delete this.stores[y][x];\n    }\n    // clear empty rows\n    if (!Object.keys(this.stores[y] || {}).length) {\n      delete this.stores[y];\n    }\n  }\n\n  setEditByCell<T extends Cell>(storePos: T, editCell: T) {\n    this.focusByCell(storePos, editCell, editCell);\n    this.setEdit('');\n  }\n\n  /**\n   * Sets the next focus cell before the current one.\n   * \n   * @param focus - The cell to set as the next focus.\n   */\n  beforeNextFocusCell(focus: Cell) {\n    // If there is no focused store, return early.\n    if (!this.focusedStore) {\n      return;\n    }\n\n    // Get the next store based on the current focus and the last cell.\n    const lastCell = this.focusedStore.entity.store.get('lastCell');\n    const next = lastCell && this.getNextStore(focus, this.focusedStore.position, lastCell);\n\n    // Set the next focus cell in the store.\n    next?.store?.setNextFocus({ ...focus, ...next.item });\n  }\n\n  focusByCell<T extends Cell>(storePos: T, start: T, end: T) {\n    const store = this.stores[storePos.y][storePos.x];\n    this.focus(store, { focus: start, end });\n  }\n\n  focus(store: SelectionStore, { focus, end }: { focus: Cell; end: Cell }) {\n    const currentStorePointer = this.getCurrentStorePointer(store);\n    if (!currentStorePointer) {\n      return null;\n    }\n\n    // check for the focus in nearby store/viewport\n    const lastCell = store.store.get('lastCell');\n    const next = lastCell && this.getNextStore(focus, currentStorePointer, lastCell);\n\n    // if next store present - update\n    if (next?.store) {\n      const item = { ...focus, ...next.item };\n      this.focus(next.store, { focus: item, end: item });\n      return null;\n    }\n\n    if (lastCell) {\n      focus = cropCellToMax(focus, lastCell);\n      end = cropCellToMax(end, lastCell);  \n    }\n    store.setFocus(focus, end);\n    return focus;\n  }\n\n  /**\n   * Retrieves the current store pointer based on the active store.\n   * Clears focus from all stores except the active one.\n   */\n  getCurrentStorePointer(store: SelectionStore) {\n    let currentStorePointer: Cell | undefined;\n\n    // Iterate through all stores\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const s = this.stores[y][x];\n\n        // Clear focus from stores other than the active one\n        if (s !== store) {\n          s.clearFocus();\n        } else {\n          // Update the current store pointer with the active store coordinates\n          currentStorePointer = { \n            x: parseInt(x, 10), \n            y: parseInt(y, 10) \n          };\n        }\n      }\n    }\n\n    return currentStorePointer;\n  }\n\n  /**\n   * Retrieves the next store based on the focus cell and current store pointer.\n   * If the next store exists, returns an object with the next store and the item in the new store.\n   * If the next store does not exist, returns null.\n   */\n  getNextStore(\n    focus: Cell,\n    currentStorePointer: Cell,\n    lastCell: Cell,\n  ) {\n    // item in new store\n    const nextItem: Partial<Cell> | null = nextCell(focus, lastCell);\n\n    let nextStore: SelectionStore | undefined;\n    if (nextItem) {\n      Object.entries(nextItem).forEach(([type, nextItemCoord]: [keyof Cell, number]) => {\n        let stores;\n        switch (type) {\n          case 'x':\n            // Get the X stores for the current Y coordinate of the current store pointer\n            stores = this.getXStores(currentStorePointer.y);\n            break;\n          case 'y':\n            // Get the Y stores for the current X coordinate of the current store pointer\n            stores = this.getYStores(currentStorePointer.x);\n            break;\n        }\n\n        // Get the next store based on the item in the new store\n        if (nextItemCoord >= 0) {\n          nextStore = stores[++currentStorePointer[type]];\n        } else {\n          nextStore = stores[--currentStorePointer[type]];\n          const nextLastCell = nextStore?.store.get('lastCell');\n          if (nextLastCell) {\n            nextItem[type] = nextLastCell[type] + nextItemCoord;\n          }\n        }\n    });\n  }\n    return {\n      store: nextStore,\n      item: nextItem,\n    };\n  }\n\n  clearAll() {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        this.stores[y][x]?.clearFocus();\n      }\n    }\n  }\n\n  setEdit(val?: string | boolean) {\n    if (!this.focusedStore) {\n      return;\n    }\n    this.focusedStore.entity.setEdit(val);\n  }\n\n  /**\n   * Select all cells across all stores\n   */\n  selectAll() {\n    for (let y in this.stores) {\n      for (let x in this.stores[y]) {\n        const store = this.stores[y][x];\n        if (!store) {\n          continue;\n        }\n        const lastCell = store.store.get('lastCell');\n        if (lastCell) {\n          store.setRange(\n            { x: 0, y: 0 },\n            { x: lastCell.x - 1, y: lastCell.y - 1 },\n          );\n        }\n      }\n    }\n  }\n\n  private getXStores(y: number) {\n    return this.stores[y];\n  }\n\n  private getYStores(x: number) {\n    const stores: { [p: number]: SelectionStore } = {};\n    for (let i in this.stores) {\n      stores[i] = this.stores[i][x];\n    }\n    return stores;\n  }\n}\n","import { EMPTY_INDEX } from '../../services/selection.store.connector';\nimport { Cell, RangeArea } from '@type';\n\nexport function isHiddenStore(pos: number) {\n  return pos === EMPTY_INDEX;\n}\n\nexport function nextCell(cell: Cell, lastCell: Cell): Partial<Cell> | null {\n  const nextItem: Partial<Cell> = {};\n  let types: (keyof Cell)[] = ['x', 'y'];\n\n  // previous item check\n  for (let t of types) {\n    if (cell[t] < 0) {\n      nextItem[t] = cell[t];\n      return nextItem;\n    }\n  }\n  // next item check\n  for (let t of types) {\n    if (cell[t] >= lastCell[t]) {\n      nextItem[t] = cell[t] - lastCell[t];\n      return nextItem;\n    }\n  }\n  return null;\n}\n\nexport function cropCellToMax(cell: Cell, lastCell: Cell): Cell {\n  const croppedCell: Cell = { ...cell };\n  const cellCoordinates: (keyof Cell)[] = ['x', 'y'];\n\n  for (const coordinate of cellCoordinates) {\n    if (cell[coordinate] < 0) {\n      croppedCell[coordinate] = 0;\n    } else if (cell[coordinate] >= lastCell[coordinate]) {\n      croppedCell[coordinate] = lastCell[coordinate] - 1;\n    }\n  }\n\n  return croppedCell;\n}\n\nexport function getRange(start?: Cell | null, end?: Cell | null): RangeArea | null {\n  return start && end\n    ? {\n        x: Math.min(start.x, end.x),\n        y: Math.min(start.y, end.y),\n        x1: Math.max(start.x, end.x),\n        y1: Math.max(start.y, end.y),\n      }\n    : null;\n}\n\nexport function isRangeSingleCell(a: RangeArea): boolean {\n  return a.x === a.x1 && a.y === a.y1;\n}\n","import { DimensionRows } from '@type';\nimport { GRID_INTERNALS } from '../../utils/consts';\n\nexport const GROUP_DEPTH = `${GRID_INTERNALS}-depth`;\nexport const PSEUDO_GROUP_ITEM = `${GRID_INTERNALS}-name`;\nexport const PSEUDO_GROUP_ITEM_ID = `${GRID_INTERNALS}-id`;\nexport const PSEUDO_GROUP_ITEM_VALUE = `${GRID_INTERNALS}-value`;\nexport const PSEUDO_GROUP_COLUMN = `${GRID_INTERNALS}-column`;\nexport const GROUP_EXPANDED = `${GRID_INTERNALS}-expanded`;\nexport const GROUP_COLUMN_PROP = `${GRID_INTERNALS}-prop`;\nexport const GROUP_ORIGINAL_INDEX = `${GRID_INTERNALS}-original-index`;\nexport const GROUP_EXPAND_BTN = `group-expand`;\nexport const GROUP_EXPAND_EVENT = `groupexpandclick`;\nexport const GROUPING_ROW_TYPE: DimensionRows = 'rgRow';\n","import type { DataType, ColumnProp, ColumnRegular } from '@type';\nimport {\n  GROUP_DEPTH,\n  GROUP_EXPANDED,\n  PSEUDO_GROUP_COLUMN,\n  PSEUDO_GROUP_ITEM,\n  PSEUDO_GROUP_ITEM_ID,\n  PSEUDO_GROUP_ITEM_VALUE,\n  GROUP_ORIGINAL_INDEX,\n  GROUP_COLUMN_PROP,\n} from './grouping.const';\nimport type { ExpandedOptions, SourceGather } from './grouping.row.types';\n\n\ntype GroupedData = Map<string, GroupedData | DataType[]>;\n\nfunction getGroupValueDefault(item: DataType, prop: string | number) {\n  return item[prop] || null;\n}\n\n// get source based on proxy item collection to preserve rgRow order\nexport function getSource(\n  source: DataType[],\n  items: number[],\n  withoutGrouping = false,\n) {\n  let index = 0;\n  const result: Required<SourceGather> = {\n    source: [],\n    prevExpanded: {},\n    oldNewIndexes: {},\n  };\n  // order important here, expected parent is first, then others\n  items.forEach(i => {\n    const model = source[i];\n    if (!withoutGrouping) {\n      result.source.push(model);\n      return;\n    }\n\n    // grouping filter\n    if (isGrouping(model)) {\n      if (getExpanded(model)) {\n        result.prevExpanded[model[PSEUDO_GROUP_ITEM_VALUE]] = true;\n      }\n    } else {\n      result.source.push(model);\n      result.oldNewIndexes[i] = index;\n      index++;\n    }\n  });\n  return result;\n}\n\nexport function getExpanded(model: DataType = {}) {\n  return model[GROUP_EXPANDED];\n}\n\n/**\n * Gather data for grouping\n * @param array - flat data array\n * @param columnProps - ids of groups\n * @param expanded - potentially expanded items if present\n */\nexport function gatherGrouping(\n  array: DataType[],\n  columnProps: ColumnProp[],\n  {\n    prevExpanded,\n    expandedAll,\n    getGroupValue = getGroupValueDefault,\n  }: ExpandedOptions,\n) {\n  const groupedItems: GroupedData = new Map();\n  array.forEach((item, originalIndex) => {\n    const groupLevelValues = columnProps.map(groupId =>\n      getGroupValue(item, groupId),\n    );\n    const lastLevelValue = groupLevelValues.pop();\n    let currentGroupLevel = groupedItems;\n    groupLevelValues.forEach(value => {\n      if (!currentGroupLevel.has(value)) {\n        currentGroupLevel.set(value, new Map());\n      }\n      currentGroupLevel = currentGroupLevel.get(value) as GroupedData;\n    });\n    if (!currentGroupLevel.has(lastLevelValue)) {\n      currentGroupLevel.set(lastLevelValue, []);\n    }\n    const lastLevelItems = currentGroupLevel.get(lastLevelValue) as DataType[];\n    lastLevelItems.push({\n      ...item,\n      [GROUP_ORIGINAL_INDEX]: originalIndex,\n    });\n  });\n\n  let itemIndex = -1;\n  const groupingDepth = columnProps.length;\n  // collapse all groups in the beginning\n  const trimmed: Record<number, boolean> = {};\n  // index mapping\n  const oldNewIndexMap: Record<number, number> = {};\n  // check if group header exists\n  const pseudoGroupTest: Record<string, number[]> = {};\n  const sourceWithGroups: DataType[] = [];\n  function flattenGroupMaps(\n    groupedValues: GroupedData,\n    parentIds: string[],\n    isExpanded: boolean,\n  ) {\n    const depth = parentIds.length;\n    groupedValues.forEach((innerGroupedValues, groupId) => {\n      const levelIds = [...parentIds, groupId];\n      const mergedIds = levelIds.join(',');\n      const isGroupExpanded =\n        isExpanded && (!!expandedAll || !!prevExpanded?.[mergedIds]);\n      sourceWithGroups.push({\n        [PSEUDO_GROUP_ITEM]: groupId,\n        [GROUP_DEPTH]: depth,\n        [PSEUDO_GROUP_ITEM_ID]: JSON.stringify(levelIds),\n        [PSEUDO_GROUP_ITEM_VALUE]: mergedIds,\n        [GROUP_EXPANDED]: isGroupExpanded,\n        [GROUP_COLUMN_PROP]: columnProps[depth],\n        [columnProps[depth]]: groupId,\n      });\n      itemIndex += 1;\n      if (!isGroupExpanded && depth) {\n        trimmed[itemIndex] = true;\n      }\n      if (Array.isArray(innerGroupedValues)) {\n        innerGroupedValues.forEach(value => {\n          itemIndex += 1;\n          if (!isGroupExpanded) {\n            trimmed[itemIndex] = true;\n          }\n          oldNewIndexMap[value[GROUP_ORIGINAL_INDEX]] = itemIndex;\n          const pseudoGroupTestIds = levelIds.map((_value, index) =>\n            levelIds.slice(0, index + 1).join(','),\n          );\n          pseudoGroupTestIds.forEach(pseudoGroupTestId => {\n            if (!pseudoGroupTest[pseudoGroupTestId]) {\n              pseudoGroupTest[pseudoGroupTestId] = [];\n            }\n            pseudoGroupTest[pseudoGroupTestId].push(itemIndex);\n          });\n        });\n        sourceWithGroups.push(...innerGroupedValues);\n      } else {\n        flattenGroupMaps(innerGroupedValues, levelIds, isGroupExpanded);\n      }\n    });\n  }\n  flattenGroupMaps(groupedItems, [], true);\n\n  return {\n    sourceWithGroups, // updates source mirror\n    depth: groupingDepth, // largest depth for grouping\n    trimmed, // used for expand/collapse grouping values\n    oldNewIndexMap, // used for mapping old values to new\n    childrenByGroup: pseudoGroupTest, // used to get child items in group\n  };\n}\n\nexport function getGroupingName(rgRow?: DataType) {\n  return rgRow && rgRow[PSEUDO_GROUP_ITEM];\n}\n\ntype GroupingItem = {\n  [PSEUDO_GROUP_ITEM]: string;\n  [GROUP_EXPANDED]: boolean;\n  [PSEUDO_GROUP_ITEM_VALUE]: string;\n  [GROUP_DEPTH]: number;\n  [GROUP_COLUMN_PROP]: ColumnProp;\n};\n\nexport function isGrouping(rgRow?: DataType): rgRow is GroupingItem {\n  return typeof rgRow?.[PSEUDO_GROUP_ITEM] !== 'undefined';\n}\n\nexport function isGroupingColumn(column?: ColumnRegular) {\n  return typeof column?.[PSEUDO_GROUP_COLUMN] !== 'undefined';\n}\n\nexport function measureEqualDepth<T>(groupA: T[], groupB: T[]) {\n  const ln = groupA.length;\n  let i = 0;\n  for (; i < ln; i++) {\n    if (groupA[i] !== groupB[i]) {\n      return i;\n    }\n  }\n  return i;\n}\n\nexport function getParsedGroup(id: string) {\n  const parseGroup = JSON.parse(id);\n  // extra precaution and type safeguard\n  if (!Array.isArray(parseGroup)) {\n    return null;\n  }\n  return parseGroup;\n}\n\n// check if items is child of current clicked group\nexport function isSameGroup(\n  currentGroup: any[],\n  currentModel: DataType,\n  nextModel: DataType,\n) {\n  const nextGroup = getParsedGroup(nextModel[PSEUDO_GROUP_ITEM_ID]);\n  if (!nextGroup) {\n    return false;\n  }\n\n  const depth = measureEqualDepth(currentGroup, nextGroup);\n  return currentModel[GROUP_DEPTH] < depth;\n}\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nexport default baseSlice;\n","import baseSlice from './_baseSlice.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toInteger from './toInteger.js';\n\n/**\n * Creates a slice of `array` from `start` up to, but not including, `end`.\n *\n * **Note:** This method is used instead of\n * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n * returned.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction slice(array, start, end) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n    start = 0;\n    end = length;\n  }\n  else {\n    start = start == null ? 0 : toInteger(start);\n    end = end === undefined ? length : toInteger(end);\n  }\n  return baseSlice(array, start, end);\n}\n\nexport default slice;\n","import { DSourceState, getSourceItem, getVisibleSourceItem } from '@store';\nimport {\n  Observable,\n  CELL_CLASS,\n  DISABLED_CLASS,\n  getCellRaw,\n  getCellData,\n} from '../../utils';\nimport { getRange } from '@store';\n\nimport { isGroupingColumn } from '../../plugins/groupingRow/grouping.service';\nimport slice from 'lodash/slice';\nimport {\n  DimensionCols,\n  DimensionRows,\n  RowDrag,\n  ColumnRegular,\n  DataType,\n  CellProps,\n  ColumnDataSchemaModel,\n  ColumnProp,\n  DataLookup,\n  DataFormat,\n  ChangedRange,\n  OldNewRangeMapping,\n  Cell,\n  RangeArea,\n  BeforeSaveDataDetails,\n  EditorCtr,\n  Editors,\n  CellTemplateProp,\n} from '@type';\nimport { JSXBase } from '@stencil/core/internal';\n\nexport type ColumnStores = {\n  [T in DimensionCols]: Observable<DSourceState<ColumnRegular, DimensionCols>>;\n};\nexport type RowStores = {\n  [T in DimensionRows]: Observable<DSourceState<DataType, DimensionRows>>;\n};\n\nexport default class ColumnService {\n  private unsubscribe: { (): void }[] = [];\n  get columns(): ColumnRegular[] {\n    return getVisibleSourceItem(this.source);\n  }\n\n  hasGrouping = false;\n  type: DimensionCols;\n\n  constructor(\n    private dataStore: Observable<DSourceState<DataType, DimensionRows>>,\n    private source: Observable<DSourceState<ColumnRegular, DimensionCols>>,\n  ) {\n    this.unsubscribe.push(\n      source.onChange('source', s => this.checkGrouping(s)),\n    );\n    this.checkGrouping(source.get('source'));\n    this.type = source.get('type');\n  }\n\n  private checkGrouping(cols: ColumnRegular[]) {\n    for (let rgCol of cols) {\n      if (isGroupingColumn(rgCol)) {\n        this.hasGrouping = true;\n        return;\n      }\n      this.hasGrouping = false;\n    }\n  }\n\n  isReadOnly(r: number, c: number) {\n    const readOnly = this.columns[c]?.readonly;\n    if (typeof readOnly === 'function') {\n      const data = this.rowDataModel(r, c);\n      return readOnly(data);\n    }\n    return !!readOnly;\n  }\n\n  mergeProperties(\n    r: number,\n    c: number,\n    defaultProps: CellProps,\n    schemaModel: CellTemplateProp,\n  ): CellProps {\n    const props: CellProps = {\n      ...defaultProps,\n    };\n    props.class = {\n      ...(typeof props.class === 'string'\n        ? { [props.class]: true }\n        : props.class),\n      [CELL_CLASS]: true,\n      [DISABLED_CLASS]: this.isReadOnly(r, c),\n    };\n\n    const extra = schemaModel.column?.cellProperties?.(schemaModel);\n    if (!extra) {\n      return props;\n    }\n    return doPropMerge(props, extra);\n  }\n\n  getRowClass(r: number, prop: string): string {\n    const model = getSourceItem(this.dataStore, r) || {};\n    return model[prop] || '';\n  }\n\n  getSaveData(\n    rowIndex: number,\n    colIndex: number,\n    val?: string,\n  ): BeforeSaveDataDetails {\n    const data = this.rowDataModel(rowIndex, colIndex);\n    if (typeof val === 'undefined') {\n      val = getCellData(data.value);\n    }\n    return {\n      ...data,\n      val,\n    };\n  }\n\n  getCellEditor(\n    _r: number,\n    c: number,\n    editors: Editors,\n  ): EditorCtr | undefined {\n    const editor = this.columns[c]?.editor;\n    if (!editor) {\n      return undefined;\n    }\n    // reference\n    if (typeof editor === 'string') {\n      return editors[editor];\n    }\n    return editor;\n  }\n\n  /**\n   * Get cell data model for given rowIndex and colIndex\n   * Used to pass data to editor/renderer\n   */\n  rowDataModel(rowIndex: number, colIndex: number): ColumnDataSchemaModel {\n    const column = this.columns[colIndex];\n    const prop = column?.prop;\n    const model = getSourceItem(this.dataStore, rowIndex) || {};\n    const type = this.dataStore.get('type');\n    return {\n      prop,\n      model,\n      data: this.dataStore.get('source'),\n      column,\n      rowIndex,\n      colIndex,\n      colType: this.type,\n      type,\n      value: getCellRaw(model, column),\n    };\n  }\n\n  getRangeData(\n    d: ChangedRange,\n    columns: ColumnRegular[],\n  ): {\n    changed: DataLookup;\n    mapping: OldNewRangeMapping;\n  } {\n    const changed: DataLookup = {};\n\n    // get original length sizes\n    const copyColLength = d.oldRange.x1 - d.oldRange.x + 1;\n    const copyRowLength = d.oldRange.y1 - d.oldRange.y + 1;\n    const mapping: OldNewRangeMapping = {};\n\n    // rows\n    for (\n      let rowIndex = d.newRange.y, i = 0;\n      rowIndex < d.newRange.y1 + 1;\n      rowIndex++, i++\n    ) {\n      // copy original data link\n      const oldRowIndex = d.oldRange.y + (i % copyRowLength);\n      const copyRow = getSourceItem(this.dataStore, oldRowIndex) || {};\n\n      // columns\n      for (\n        let colIndex = d.newRange.x, j = 0;\n        colIndex < d.newRange.x1 + 1;\n        colIndex++, j++\n      ) {\n        // check if old range area\n        if (\n          rowIndex >= d.oldRange.y &&\n          rowIndex <= d.oldRange.y1 &&\n          colIndex >= d.oldRange.x &&\n          colIndex <= d.oldRange.x1\n        ) {\n          continue;\n        }\n\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const prop = this.columns[colIndex]?.prop;\n        const copyColIndex = d.oldRange.x + (j % copyColLength);\n        const copyColumnProp = columns[copyColIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][prop] = copyRow[copyColumnProp];\n          /** Generate mapping object */\n          if (!mapping[rowIndex]) {\n            mapping[rowIndex] = {};\n          }\n          mapping[rowIndex][prop] = {\n            colIndex: copyColIndex,\n            colProp: copyColumnProp,\n            rowIndex: oldRowIndex,\n          };\n        }\n      }\n    }\n    return {\n      changed,\n      mapping,\n    };\n  }\n\n  getTransformedDataToApply(\n    start: Cell,\n    data: DataFormat[][],\n  ): {\n    changed: DataLookup;\n    range: RangeArea | null;\n  } {\n    const changed: DataLookup = {};\n    const copyRowLength = data.length;\n    const colLength = this.columns.length;\n    const rowLength = this.dataStore.get('items').length;\n    // rows\n    let rowIndex = start.y;\n    let maxCol = 0;\n    for (\n      let i = 0;\n      rowIndex < rowLength && i < copyRowLength;\n      rowIndex++, i++\n    ) {\n      // copy original data link\n      const copyRow = data[i % copyRowLength];\n      const copyColLength = copyRow?.length || 0;\n      // columns\n      let colIndex = start.x;\n      for (\n        let j = 0;\n        colIndex < colLength && j < copyColLength;\n        colIndex++, j++\n      ) {\n        const p = this.columns[colIndex].prop;\n        const currentCol = j % colLength;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = copyRow[currentCol];\n        }\n      }\n      maxCol = Math.max(maxCol, colIndex - 1);\n    }\n    const range = getRange(start, {\n      y: rowIndex - 1,\n      x: maxCol,\n    });\n    return {\n      changed,\n      range,\n    };\n  }\n\n  getRangeStaticData(d: RangeArea, value: DataFormat): DataLookup {\n    const changed: DataLookup = {};\n\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        // requested column beyond range\n        if (!this.columns[colIndex]) {\n          continue;\n        }\n        const p = this.columns[colIndex].prop;\n\n        /** if can write */\n        if (!this.isReadOnly(rowIndex, colIndex)) {\n          /** to show before save */\n          if (!changed[rowIndex]) {\n            changed[rowIndex] = {};\n          }\n          changed[rowIndex][p] = value;\n        }\n      }\n    }\n    return changed;\n  }\n\n  getRangeTransformedToProps(\n    d: RangeArea,\n    store: Observable<DSourceState<DataType, DimensionRows>>,\n  ) {\n    const area: {\n      prop: ColumnProp;\n      rowIndex: number;\n      colIndex: number;\n      model?: DataType;\n      colType: DimensionCols;\n      type: DimensionRows;\n    }[] = [];\n\n    const type = this.dataStore.get('type');\n    // rows\n    for (let rowIndex = d.y, i = 0; rowIndex < d.y1 + 1; rowIndex++, i++) {\n      // columns\n      for (let colIndex = d.x, j = 0; colIndex < d.x1 + 1; colIndex++, j++) {\n        const prop = this.columns[colIndex]?.prop;\n        area.push({\n          prop,\n          rowIndex,\n          colIndex,\n          model: getSourceItem(store, rowIndex),\n          type,\n          colType: this.type,\n        });\n      }\n    }\n    return area;\n  }\n\n  copyRangeArray(\n    range: RangeArea,\n    store: Observable<DSourceState<DataType, DimensionRows>>,\n  ) {\n    const cols = [...this.columns];\n    const props = slice(cols, range.x, range.x1 + 1).map(v => v.prop);\n    const toCopy: DataFormat[][] = [];\n    const mapping: { [rowIndex: number]: { [colProp: ColumnProp]: any } } = {};\n\n    // rows indexes\n    for (let i = range.y; i <= range.y1; i++) {\n      const rgRow: DataFormat[] = [];\n      mapping[i] = {};\n\n      // columns indexes\n      for (let prop of props) {\n        const item = getSourceItem(store, i);\n\n        // if no item - skip\n        if (!item) {\n          continue;\n        }\n        const val = item[prop];\n        rgRow.push(val);\n        mapping[i][prop] = val;\n      }\n\n      toCopy.push(rgRow);\n    }\n    return {\n      data: toCopy,\n      mapping,\n    };\n  }\n\n  destroy() {\n    this.unsubscribe.forEach(f => f());\n  }\n}\n\n/**\n * Checks if the given rowDrag is a service for dragging rows.\n */\nexport function isRowDragService(\n  rowDrag: RowDrag,\n  model: ColumnDataSchemaModel,\n): boolean {\n  if (typeof rowDrag === 'function') {\n    return rowDrag(model);\n  }\n  return !!rowDrag;\n}\n\nfunction mergeClasses(\n  class1: JSXBase.HTMLAttributes<HTMLElement>['class'] = {},\n  class2: JSXBase.HTMLAttributes<HTMLElement>['class'] = {},\n) {\n  if (typeof class1 === 'string') {\n    class1 = { [class1]: true };\n  }\n  if (typeof class2 === 'string') {\n    class2 = { [class2]: true };\n  }\n  return { ...class1, ...class2 };\n}\n\nexport function doPropMerge(existing: CellProps, extra: CellProps) {\n  // if className is provided - remove it from props it messing with stencil\n  if (extra.className) {\n    extra.class = mergeClasses(extra.class, extra.className);\n    delete extra.className;\n  }\n  let props: CellProps = { ...extra, ...existing };\n  // extend existing props\n  if (extra.class) {\n    props.class = mergeClasses(props.class, extra.class);\n  }\n  if (extra.style) {\n    props.style = { ...extra.style, ...props.style };\n  }\n  return props;\n}\n"],"mappings":"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","ignoreList":[]}